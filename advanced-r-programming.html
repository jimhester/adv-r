<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>+/- </title>





<style type="text/css">

</style>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- jQuery -->
<script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.2/jquery-ui.min.js"></script>

<!-- highlight.js -->
<link href="http://yandex.st/highlightjs/7.3/styles/default.min.css" rel="stylesheet">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
<script src="http://yandex.st/highlightjs/7.3/languages/r.min.js"></script>

<!-- bootstrap -->
<link href=http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css rel="stylesheet">
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- tocify -->
<script src="http://gregfranko.com/jquery.tocify.js/js/jquery.tocify.min.js"></script>

<!-- Manific Popup -->
<script src="http://dimsemenov.com/plugins/magnific-popup/dist/jquery.magnific-popup.min.js"></script>
<link rel="stylesheet" href="http://dimsemenov.com/plugins/magnific-popup/dist/magnific-popup.css">

<script>
/* run scripts when document is ready */
$(function() {
  "use strict";

  document.title = $('h1').first().text();

  /* size of thumbnails */
  var thumbsize = "col-md-3";

  var show_code =  true ;

  var show_output =  false ;

  var show_figure =  true ;

  /* included languages */
  var languages = [];

  /* Using render_html, so add in code block */
  $('pre.knitr').each(function(){
    $(this).removeClass('knitr');
    if($(this).find('code').length < 1){
      $(this).wrapInner('<code class=' + $(this).attr('class') + '></code>');
    }
  });

  /* style tables */
  $('table').addClass('table table-striped table-bordered table-hover table-condensed');

  /* add toggle panel to rcode blocks */
  $('div.rcode div').not('.rimage').each(function() {
    var button = $('<h5 class="panel-title">+/- </h5>');

    if($(this).hasClass('source')){
      var code_block = $(this).find('code');
      var lang_type = code_block.attr('class');
      button.text(button.text() + lang_type + ' Code');
      button.addClass('source ' + lang_type);
      languages[lang_type]=0;
      code_block.each(function(i, e) {
        hljs.highlightBlock(e);
      });
      $(this).addClass('panel panel-primary ' + lang_type);
    }
    else if($(this).hasClass('output')){
      button.text(button.text() + 'Output');
      button.addClass('output');
      $(this).addClass('panel panel-success');
    }
    else if($(this).hasClass('message')){
      button.text(button.text() + 'Message');
      button.addClass('message');
      $(this).addClass('panel panel-info');
    }
    else if($(this).hasClass('warning')){
      button.text(button.text() + 'Warning');
      button.addClass('warning');
      $(this).addClass('panel panel-warning');
    }
    else if($(this).hasClass('error')){
      button.text(button.text() + 'Error');
      button.addClass('error');
      $(this).addClass('panel panel-danger');
    }
    else {
      console.log($(this));
    }
    $(this).prepend($('<div class="panel-heading toggle" />').append(button));
  });

  /* give images a lightbox and thumbnail classes to allow lightbox and thumbnails TODO: make gallery if graphs are grouped */
  $('div.rimage').each(function(){
    var imgs = $(this).children('img');

    var source = $(this).prev('.source');
    source.addClass('media-body');

    $(this).add(source).wrapAll('<div class="media" />');

    //remove div
    $(this).remove();

    //remove images
    imgs.remove();

    //add images before source
    source.before(imgs);

    //add wrapping links to images
    imgs.wrap('<a href="#" class="media-object pull-left mfp-image thumbnail ' + thumbsize + '"></a>');
  });

  /* Magnific Popup */
  $(".thumbnail").each(function(){
    $(this).magnificPopup({
      disableOn: 768,
      closeOnContentClick: true,

      type: 'image',
      items: {
        src: $(this).find('img').attr('src'),
      }
    });
  });

  /* add bootstrap classes */
  $('body').wrapInner('<div class="container"><div class="row"><div class="contents">');

  var create_language_links = function(){
    var text='';
    var language;
    for(language in languages){
      if(languages.hasOwnProperty(language)){
        text += '<li><a href=# class="toggle-global source ' + language + '" type="source.' + language + '">' + language + '</a></li>\n';
      }
    }
    return text;
  }

  var navbar =
  '<div class="navbar navbar-fixed-bottom navbar-inverse">\
    <div class="container">\
      <div class="navbar-header">\
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">\
          <span class="icon-bar"></span>\
          <span class="icon-bar"></span>\
          <span class="icon-bar"></span>\
        </button>\
      </div>\
      <div id="bottom-navbar" class="navbar-collapse collapse navbar-responsive-collapse">\
        <ul class="nav navbar-nav navbar-right">\
          <li class="nav"><p class="navbar-text">Toggle</p></li>\
          <li class="dropup">\
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <b class="caret"></b></a>\
            <ul class="dropdown-menu">\
              <li class="dropdown-header">Languages</li>'
              + create_language_links() +
              '<li><a href="#" type="all-source" class="toggle-global">All</a></li>\
            </ul>\
          </li>\
          <li class="dropup">\
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Output <b class="caret"></b></a>\
            <ul class="dropdown-menu">\
              <li class="dropdown-header">Type</li>\
                <li><a href="#" type="output" class="toggle-global">Output</a></li>\
                <li><a href="#" type="message" class="toggle-global">Message</a></li>\
                <li><a href="#" type="warning" class="toggle-global">Warning</a></li>\
                <li><a href="#" type="error" class="toggle-global">Error</a></li>\
                <li><a href="#" type="all-output" class="toggle-global">All</a></li>\
            </ul>\
          </li>\
          <li><a href="#" class="toggle-figure">Figures</a></li>\
        </ul>\
      </div><!-- /.nav-collapse -->\
    </div><!-- /.container -->\
  </div>';
  /* add navbar */
  $('.container').append(navbar);

  /* onclick toggle next code block */
  $('.toggle').click(function() {
    $(this).next('pre').slideToggle();
    return false;
  });

  // global toggles
  $('.toggle-global').click(function(){
    var type = $(this).attr('type');
    if(type == 'all-source'){
      for(var language in languages){
        $('li a[type="source.' + language + '"]').click();
      }
    }
    if(type == 'all-output'){
      $('li a[type=output], li a[type=message], li a[type=warning], li a[type=error]').click();
    }
    else {
      if($(this).closest('li').hasClass('active')){
        $('div.' + type).children('pre').slideUp();
      }
      else {
        $('div.' + type).children('pre').slideDown();
      }
    }
    $(this).closest('li').toggleClass('active');
    return false;
  });
  // global toggles figure, this is more complicated than just slideToggle because you have to hide the parent div as well
  $('.toggle-figure').click(function(){
    var imgs = $('.thumbnail img');
    if(imgs.is(":visible")){
      imgs.slideUp(400, function(){ $(this).parent().toggle(); });
    }
    else {
      imgs.parent().show();
      imgs.slideDown();
    }
    $(this).closest('li').toggleClass('active');
    return false;
  });

  /* add footer */
  $('body').wrapInner('<div id="wrap" />');
  $('#wrap').append('<div id="push" />');
  var p = $('p:contains("Author:")');
  var last_p = p.filter(':last');
  p.detach();
  last_p.addClass('muted').attr('id','credit');
  last_p.append('<p>styled with <a href="https://github.com/jimhester/knitrBootstrap">knitrBootstrap</a></p>');
  last_p.appendTo("body");
  last_p.wrap('<div id="footer">');

  $('.container > .row').prepend('<div class="col-md-3"><div id="toc" class="well sidebar sidenav affix hidden-print"/></div>');

  $('.contents').addClass('col-md-offset-3');

  /* table of contents */
  $('#toc').tocify({extendPage: false});

  if(show_code){
    /* toggle source buttons pressed */
    $('a.toggle-global.source').closest('li').addClass('active');
  }
  else {
    /* hide code blocks */
    $('div.source pre').hide();
  }

  if(show_output){
    /* toggle output buttons pressed */
    $('li a[type=output], li a[type=message], li a[type=warning], li a[type=error], li a[type=all-output]').closest('li').addClass('active');
  }
  else {
    /* hide output blocks */
    $('div.output pre').hide();
  }

  if(show_figure){
    /* toggle figure button pressed */
    $('li a.toggle-figure').closest('li').addClass('active');
  }
  else {
    /* hide figures */
    $('.thumbnail').hide();
  }

  /* remove paragraphs with no content */
  $('p:empty').remove();

});

</script>
<style>
/* Knitr_bootstrap styles */
#wrap .container-fluid {
  padding: 0;
  overflow: hidden;
}
.toggle{
  text-transform: capitalize;
}

.toggle-global{
  text-transform: capitalize;
}

/* Sticky footer styles */
* {
  margin:0;
}
html,
body {
    height: 100%;
    padding:0 !important;
    /* The html and body elements cannot have any padding or margin. */
    /*overflow-x: hidden;*/
}

/* Wrapper for page content to push down footer */
#wrap {
    min-height: 100%;
    height: auto !important;
    height: 100%;
    /* Negative indent footer by it's height */
    margin: 0 auto -120px;
}

/* Set the fixed height of the footer here */
#push,
#footer {
    height: 120px;
}

#footer {
  text-align: center;
}

/* Top level subheader elements.  These are the first nested items underneath a header element. */
.header li {
  font-size: 20px;
}

/* Makes the font smaller for all subheader elements. */
.sub-header li {
    font-size: 12px;
}

button.thumbnails {
  margin-left:0px;
}

.mfp-image img{
  background: white;
}
.mfp-figure:after {
  background: white;
}
/*
 * Side navigation
 *
 * Scrollspy and affixed enhanced navigation to highlight sections and secondary
 * sections of docs content.
 */

/* By default it's not affixed in mobile views, so undo that */
.sidebar.affix {
  position: static;
}

/* First level of nav */
.sidenav {
  margin-top: 30px;
  margin-bottom: 30px;
  padding-top:    10px;
  padding-bottom: 10px;
  border-radius: 5px;
}

/* All levels of nav */
.sidebar .nav > li > a {
  display: block;
  padding: 5px 20px;
}
.sidebar .nav > li > a:hover,
.sidebar .nav > li > a:focus {
  text-decoration: none;
  border-right: 1px solid;
}
.sidebar .nav > .active > a,
.sidebar .nav > .active:hover > a,
.sidebar .nav > .active:focus > a {
  font-weight: bold;
  background-color: transparent;
  border-right: 1px solid;
}

/* Nav: second level (shown on .active) */
.sidebar .nav .nav {
  display: none; /* Hide by default, but at >768px, show it */
  margin-bottom: 8px;
}
.sidebar .nav .nav > li > a {
  padding-top:    3px;
  padding-bottom: 3px;
  padding-left: 30px;
  font-size: 90%;
}

/* Show and affix the side nav when space allows it */
@media screen and (min-width: 992px) {
  .sidebar .nav > .active > ul {
    display: block;
  }
  /* Widen the fixed sidebar */
  .sidebar.affix,
  .sidebar.affix-bottom {
    width: 213px;
  }
  .sidebar.affix {
    position: fixed; /* Undo the static from mobile first approach */
    top: 30px;
  }
  .sidebar.affix-bottom {
    position: absolute; /* Undo the static from mobile first approach */
  }
  .sidebar.affix-bottom .sidenav,
  .sidebar.affix .sidenav {
    margin-top: 0;
    margin-bottom: 0;
  }
}
@media screen and (min-width: 1200px) {
  /* Widen the fixed sidebar again */
  .sidebar.affix-bottom,
  .sidebar.affix {
    width: 263px;
  }
}

#toc {
  padding: 10px 0px;
  margin:0;
  border:0;
}


.panel pre {
  border-radius: 0;
  border: 0;
  margin: 0;
  padding: 0;
}
.panel pre code {
  border-radius: 0;
}

</style>
<link href=http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css rel="stylesheet" id='style'>
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" title="Default" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/amelia/bootstrap.min.css" title="Amelia" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/cerulean/bootstrap.min.css" title="Cerulean" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/cosmo/bootstrap.min.css" title="Cosmo" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/cyborg/bootstrap.min.css" title="Cyborg" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/flatly/bootstrap.min.css" title="Flatly" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/journal/bootstrap.min.css" title="Journal" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/readable/bootstrap.min.css" title="Readable" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/simplex/bootstrap.min.css" title="Simplex" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/slate/bootstrap.min.css" title="Slate" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/spacelab/bootstrap.min.css" title="Spacelab" media="screen">
<link rel="alternate stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootswatch/3.0.0/united/bootstrap.min.css" title="United" media="screen">

          <!--<li><a class="style-switch" title="Superhero" href="#" >Superhero</a>  </li> \-->
          <!--<li><a class="style-switch" title="Spruce" href="#"    >Spruce</a>     </li> \-->
<script>
$(function() {
    $('#bottom-navbar').append(
    '<ul class="nav navbar-nav navbar-left">\
      <li class="dropup">\
        <a class="dropdown-toggle" data-toggle="dropdown" href="#">Bootstrap Style</a>\
        <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">\
           <li class="active"><a class="style-switch" title="Default" href="#"   >Default</a></li> \
           <li><a class="style-switch" title="Amelia" href="#"                   >Amelia</a></li> \
           <li><a class="style-switch" title="Cerulean" href="#"                 >Cerulean</a></li> \
           <li><a class="style-switch" title="Cosmo" href="#"                    >Cosmo</a></li> \
           <li><a class="style-switch" title="Cyborg" href="#"                   >Cyborg</a></li> \
           <li><a class="style-switch" title="Flatly" href="#"                   >Flatly</a></li> \
           <li><a class="style-switch" title="Journal" href="#"                  >Journal</a></li> \
           <li><a class="style-switch" title="Readable" href="#"                 >Readable</a></li> \
           <li><a class="style-switch" title="Simplex" href="#"                  >Simplex</a></li> \
           <li><a class="style-switch" title="Slate" href="#"                    >Slate</a></li> \
           <li><a class="style-switch" title="Spacelab" href="#"                 >Spacelab</a></li> \
           <li><a class="style-switch" title="United" href="#"                   >United</a></li> \
        </ul>\
      </li>\
    </ul>');
    $('.style-switch').click(function(){
      var css = $('link[title=' + $(this).attr('title') + ']');
      $('#style[rel=stylesheet]').attr('href', css.attr('href'));
      $('.style-switch').closest('li').removeClass('active');
      $(this).closest('li').addClass('active');
      return false;
    });
  }
);
</script>

<link href="http://yandex.st/highlightjs/7.3/styles/default.min.css" id="code-style" rel="stylesheet">
<link title="Default-Code" href="http://yandex.st/highlightjs/7.3/styles/default.min.css" rel="alternate stylesheet">
<link title="Dark" href="http://yandex.st/highlightjs/7.3/styles/dark.min.css" rel="alternate stylesheet">
<link title="FAR" href="http://yandex.st/highlightjs/7.3/styles/far.min.css" rel="alternate stylesheet">
<link title="IDEA" href="http://yandex.st/highlightjs/7.3/styles/idea.min.css" rel="alternate stylesheet">
<link title="Sunburst" href="http://yandex.st/highlightjs/7.3/styles/sunburst.min.css" rel="alternate stylesheet">
<link title="Zenburn" href="http://yandex.st/highlightjs/7.3/styles/zenburn.min.css" rel="alternate stylesheet">
<link title="Visual Studio" href="http://yandex.st/highlightjs/7.3/styles/vs.min.css" rel="alternate stylesheet">
<link title="Ascetic" href="http://yandex.st/highlightjs/7.3/styles/ascetic.min.css" rel="alternate stylesheet">
<link title="Magula" href="http://yandex.st/highlightjs/7.3/styles/magula.min.css" rel="alternate stylesheet">
<link title="GitHub" href="http://yandex.st/highlightjs/7.3/styles/github.min.css" rel="alternate stylesheet">
<link title="Google Code" href="http://yandex.st/highlightjs/7.3/styles/googlecode.min.css" rel="alternate stylesheet">
<link title="Brown Paper" href="http://yandex.st/highlightjs/7.3/styles/brown_paper.min.css" rel="alternate stylesheet">
<link title="School Book" href="http://yandex.st/highlightjs/7.3/styles/school_book.min.css" rel="alternate stylesheet">
<link title="IR Black" href="http://yandex.st/highlightjs/7.3/styles/ir_black.min.css" rel="alternate stylesheet">
<link title="Solarized - Dark" href="http://yandex.st/highlightjs/7.3/styles/solarized_dark.min.css" rel="alternate stylesheet">
<link title="Solarized - Light" href="http://yandex.st/highlightjs/7.3/styles/solarized_light.min.css" rel="alternate stylesheet">
<link title="Arta" href="http://yandex.st/highlightjs/7.3/styles/arta.min.css" rel="alternate stylesheet">
<link title="Monokai" href="http://yandex.st/highlightjs/7.3/styles/monokai.min.css" rel="alternate stylesheet">
<link title="XCode" href="http://yandex.st/highlightjs/7.3/styles/xcode.min.css" rel="alternate stylesheet">
<link title="Pojoaque" href="http://yandex.st/highlightjs/7.3/styles/pojoaque.min.css" rel="alternate stylesheet">
<link title="Rainbow" href="http://yandex.st/highlightjs/7.3/styles/rainbow.min.css" rel="alternate stylesheet">
<link title="Tomorrow" href="http://yandex.st/highlightjs/7.3/styles/tomorrow.min.css" rel="alternate stylesheet">
<link title="Tomorrow Night" href="http://yandex.st/highlightjs/7.3/styles/tomorrow-night.min.css" rel="alternate stylesheet">
<link title="Tomorrow Night Bright" href="http://yandex.st/highlightjs/7.3/styles/tomorrow-night-bright.min.css" rel="alternate stylesheet">
<link title="Tomorrow Night Blue" href="http://yandex.st/highlightjs/7.3/styles/tomorrow-night-blue.min.css" rel="alternate stylesheet">
<link title="Tomorrow Night Eighties" href="http://yandex.st/highlightjs/7.3/styles/tomorrow-night-eighties.min.css" rel="alternate stylesheet">

<script>
$(function() {
    $('#bottom-navbar').append(
    '<ul class="nav navbar-nav">\
      <li class="dropdown">\
        <a class="dropdown-toggle" role="button" data-toggle="dropdown" href="#">Code Style</a>\
        <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">\
          <li class="active"><a class="code-style-switch" title="Default-Code" href="#">Default</a></li>\
          <li><a class="code-style-switch" title="Dark" href="#"                       >Dark</a></li>\
          <li><a class="code-style-switch" title="FAR" href="#"                        >FAR</a></li>\
          <li><a class="code-style-switch" title="IDEA" href="#"                       >IDEA</a></li>\
          <li><a class="code-style-switch" title="Sunburst" href="#"                   >Sunburst</a></li>\
          <li><a class="code-style-switch" title="Zenburn" href="#"                    >Zenburn</a></li>\
          <li><a class="code-style-switch" title="Visual Studio" href="#"              >Visual Studio</a></li>\
          <li><a class="code-style-switch" title="Ascetic" href="#"                    >Ascetic</a></li>\
          <li><a class="code-style-switch" title="Magula" href="#"                     >Magula</a></li>\
          <li><a class="code-style-switch" title="GitHub" href="#"                     >GitHub</a></li>\
          <li><a class="code-style-switch" title="Google Code" href="#"                >Google Code</a></li>\
          <li><a class="code-style-switch" title="Brown Paper" href="#"                >Brown Paper</a></li>\
          <li><a class="code-style-switch" title="School Book" href="#"                >School Book</a></li>\
          <li><a class="code-style-switch" title="IR Black" href="#"                   >IR Black</a></li>\
          <li><a class="code-style-switch" title="Solarized - Dark" href="#"           >Solarized - Dark</a></li>\
          <li><a class="code-style-switch" title="Solarized - Light" href="#"          >Solarized - Light</a></li>\
          <li><a class="code-style-switch" title="Arta" href="#"                       >Arta</a></li>\
          <li><a class="code-style-switch" title="Monokai" href="#"                    >Monokai</a></li>\
          <li><a class="code-style-switch" title="XCode" href="#"                      >XCode</a></li>\
          <li><a class="code-style-switch" title="Pojoaque" href="#"                   >Pojoaque</a></li>\
          <li><a class="code-style-switch" title="Rainbow" href="#"                    >Rainbow</a></li>\
          <li><a class="code-style-switch" title="Tomorrow" href="#"                   >Tomorrow</a></li>\
          <li><a class="code-style-switch" title="Tomorrow Night" href="#"             >Tomorrow Night</a></li>\
          <li><a class="code-style-switch" title="Tomorrow Night Bright" href="#"      >Tomorrow Night Bright</a></li>\
          <li><a class="code-style-switch" title="Tomorrow Night Blue" href="#"        >Tomorrow Night Blue</a></li>\
          <li><a class="code-style-switch" title="Tomorrow Night Eighties" href="#"    >Tomorrow Night Eighties</a></li>\
        </ul>\
      </li>\
    </ul>');
    $('.code-style-switch').click(function(){
      var css = $('link[title="' + $(this).attr('title') + '"]');
      $('#code-style[rel=stylesheet]').attr('href', css.attr('href'));
      $('.code-style-switch').closest('li').removeClass('active');
      $(this).closest('li').addClass('active');
      return false;
    });
});
</script>
 

</head>

<body>
<h1>Introduction</h1>

<p>This book has grown out of my 10 years of R programming, and my  constant struggle to understand the best way of doing things. The aim of this book is to help you understand R much much faster than I did, and become an effective R programmer as quickly as possible. R, along with its many add-on packages, is a very broad language, so this book focusses on the areas in which I think are important, but that there is relatively little information already available.</p>

<p>While R has its quirks, I truly believe that at its heart it is an elegant and beautiful language. While R is a fairly mature language, we are still learning how to craft elegant R code: much code seen in the wild is written in haste to solve a pressing problem, and has not been rewritten to aid understanding. </p>

<p>This book is opinionated. You might not agree with everything I say, but it is much easier to learn from a cohesive viewpoint. Just because I don&#39;t talk about it in the book, doesn&#39;t mean it isn&#39;t right or isn&#39;t useful: there are so many techniques to solve problems that there&#39;s no way to include them all. There&#39;s a big difference between &quot;I wouldn&#39;t do it this way&quot;, &quot;I don&#39;t think that&#39;s the right way to do it&quot;, and &quot;that&#39;s the wrong way to do it&quot;, and it&#39;s not always easy to capture that in writing. </p>

<ul>
<li><p>R has a massive set of packages for statistical modelling, machine learning, visualisation, data import, data manipulation and so on (over 4,000 at the time of writing). The chances are if you&#39;re trying to fit some sort of statistical model standard in your field, someone has already implemented it as an R package. This is probably why you&#39;re using R in the first place! </p></li>
<li><p>Many deep language features support data analysis: subsetting, missing values, data frames</p></li>
<li><p>Most people writing R code are not programmers, but are interested in solving their problems with data. This makes the R community unlike the community around most programming languages. There is much less of a culture of best practices and more focus on results, no matter how bad the underlying code is.</p></li>
<li><p>At the heart of R is a tension between interactive data analysis and programming. If you recognise and understand this tension, you&#39;ll understand why some functions drive you crazy when you&#39;re programming. For interactive use, you want functions that require as little typing as possible, and sometimes use a little magic to simplify your life. It&#39;s not a problem if they fail silently because you&#39;ll notice right away. For programming, you want to trade your time now for users&#39; time in the future. You&#39;re willing to spend a little more time to be explicit and verbose and spell out exactly what you want if it&#39;s going to save time in the future or produce more informative error messages.</p></li>
<li><p>R is mostly a functional programming language with a dash of object orientedness. It has three distinct OO frameworks in base R, and others available in add on packages (it&#39;s somewhat like Perl in this sense). Two of the OO styles are built around generic functions, a style of OO that comes from lisp, and is unfamiliar to most contemporary programmers.</p></li>
<li><p>R has a strong ability to compute on the language; not only can functions access the values of their arguments, but they can also access the expressions that computed them. This is a double edged sword: computing on the language gives powerful tools for creating succinct domain specific languages, but if used incorrectly can lead to code that fails in unpredictable ways.</p></li>
</ul>

<h2>Who should read this book</h2>

<p>This book is aimed at two complementary audiences:</p>

<ul>
<li><p>intermediate R programmers who want to dive deeper into R and learn more strategies for solving diverse problems</p></li>
<li><p>programmers from other languages who are learning R, and want to understand why R works the way it does.</p></li>
</ul>

<p>To get the most out of this book, you will need to have written a decent amount of code either in R or in other programming languages. You should be familiar with how functions work in R, although you might not know all the details, and you should be somewhat familiar with the apply family of functions (like <code>apply()</code> and <code>lapply()</code>), although you may currently struggle to use them effectively.</p>

<h2>What you will get out of this book</h2>

<p>This book describes the skills that I think you need to be an advanced R developer, producing reusable code that can be used in a wide variety of circumstances.</p>

<p>After reading this book:</p>

<ul>
<li><p>You will be familiar with the fundamentals of R, so that you can represent complex data types and simplify the operations performed on them. You will have a deep understanding of the language, and know how to override default behaviours when necessary.</p></li>
<li><p>You will be comfortable reading and understanding the majority of R code.  You&#39;ll recognise common idioms (even if you wouldn&#39;t use them yourself) and be able to critique other code.</p></li>
</ul>

<h2>Meta-techniques</h2>

<p>There are two meta-techniques that are tremendously helpful for improving your skills as an R programmer: reading the source, and adopting a scientific mindset.</p>

<p>Reading source code is a tremedously useful technique because it exposes you to new ways of doing things. Over time you&#39;ll develop a sense of taste as an R programmer, and even if you find something your taste violently objects to, it&#39;s still helpful: emulate the things you like and avoid the things you don&#39;t like. I think the clarity of my code increased considerably once I started grading code in the classroom, and was exposed to a lot of code I couldn&#39;t make heads nor tails of! We&#39;ll talk about this much more in the package development section of the book, but I think it&#39;s a great idea to start by reading the source code for the functions and packages that you use most frequently. Reading the source becomes even more important when you start using more esoteric parts of R; often the documentation will be lacking, and you&#39;ll need to figure out how a function works by reading the source and experimenting.</p>

<p>A scientific mindset is extremely helpful when learning R. If you don&#39;t understand how something works, develop a hypothesis, come up with some experiments and then perform them.  This exercise is extremely useful if you can&#39;t figure it out and need to get help from others: you can easily show what you tried, and when you learn the right answer, you&#39;ll be mentally prepared to update your world view. I often find that whenever I make the effort to explain a problem so that others can understand and help be able to solve it (the art of a <a href="http://stackoverflow.com/questions/5963269">reproducible example</a>), I figure out the solution myself.</p>

<h2>Recommended reading</h2>

<p>R is still a relatively young language, and the resources to help you understand it are still maturing. In my personal journey to understand R, I&#39;ve found it particularly helpful to refer to resources from other programming languages. R has aspects of both functional and object-oriented (OO) programming languages, and learning how these aspects are expressed in R, will help you translate your existing knowledge from other programming languages, and to help you identify areas where you can improve.</p>

<p>To understand why R&#39;s object systems work the way they do, I found <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">The structure and interpretation of computer programs</a>, by Harold Abelson and Gerald Jay Sussman, particularly helpful.  It is a concise but deep book, and after reading it I felt for the first time that I could actually design my own object oriented system. It was my first introduction to the generic function style of OO common in R, and it helped me understand. SICP also talks a lot about functional programming, and creating functions that are simple in isolation and powerful in combination.</p>

<p>To understand more generally about the tradeoffs that R has made differently to other programming languages, I found <a href="http://amzn.com/0262220695?tag=devtools-20">Concepts, Techniques and Models of Computer Programming</a> by Peter van Roy and Sef Haridi, extremely helpful. It helped me understand that R&#39;s copy-on-modify semantics make it substantially easier to reason about code, and while their current implementation in R is not so efficient, that it is a solvable problem.</p>

<p>If you want to learn to be a programmer, there&#39;s no place better to turn than <a href="http://amzn.com/020161622X?tag=devtools-20">The pragmatic programmer</a>, by Andrew Hunt and David Thomas.  This book is program language agnostic, and provides great advice for how to be a better programmer.</p>

<h2>Getting help</h2>

<p>Currently, there are two main venues to get help when you are stuck and can&#39;t figure out what&#39;s causing the problem: <a href="http://stackoverflow.com">stackoverflow</a> and the R-help mailing list. You can get fantastic help in both venues, but they do have their own culture and expectations.  It&#39;s usually a good idea to spend a little time lurking, and learning about community expectations before your first post. </p>

<p>Some good general advice:</p>

<ul>
<li><p>Make sure you have the latest version of R, and the package (or packages)
you are having problems with. It may be that your problem is the result of a
bug that has been fixed recently.</p></li>
<li><p>If it&#39;s not clear where the problem is, include the results of
<code>sessionInfo()</code> so others can see your R setup.</p></li>
<li><p>Spend some time creating a <a href="reproducibility.html">reproducible example</a>.  This 
is often a useful process in its own right, because in the course of making 
the problem reproducible you figure out what&#39;s causing the problem.</p></li>
</ul>

<h2>Acknowledgements</h2>

<p>I would particularly like to thank the tireless contributors to R-help and, more recently, <a href="http://stackoverflow.com/questions/tagged/r">stackoverflow</a>. There are too many to name individually,  but I&#39;d particularly like to thank Luke Tierney, John Chambers, Dirk Eddelbuettel, JJ Allaire and Brian Ripley for giving deeply of their time and correcting countless of my misunderstandings.</p>

<p>This book was <a href="https://github.com/hadley/devtools/wiki">written in the open</a>, and chapters were advertised on <a href="https://twitter.com/hadleywickham">twitter</a> when complete. It is truly a community effort: many people read the drafts, fixed typos, suggested improvements and contributed content. Without those contributors, the book wouldn&#39;t be nearly as good as it is, and I&#39;m deeply grateful for their help.</p>

<p>(Before final version, remember to use <code>git shortlog</code> to list all contributors)</p>

<h1>Data structures</h1>

<p>This chapter summarises the most important data structures in base R. I assume you&#39;ve used many (if not all) of them before, but you may not have thought deeply about how they are interrelated.  It is a brief overview: the goal is not to go into depth into individual types, but to show how they fit together as a whole. I also expect that you&#39;ll read the documentation if you want more details on any of the specific functions used in the chapter.</p>

<p>R&#39;s base data structures are summarised in the table below, organised by their dimensionality and whether they&#39;re homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):</p>

<table><thead>
<tr>
<th></th>
<th>Homogenous</th>
<th>Heterogenous</th>
</tr>
</thead><tbody>
<tr>
<td>1d</td>
<td>Atomic vector</td>
<td>List</td>
</tr>
<tr>
<td>2d</td>
<td>Matrix</td>
<td>Data frame</td>
</tr>
<tr>
<td>nd</td>
<td>Array</td>
<td></td>
</tr>
</tbody></table>

<p>Almost all other objects in R are built upon these foundations, and in the <a href="OO-essentials.html">OO field guide</a> you&#39;ll see how R&#39;s object oriented tools build on top of these basics. There are also a few types of more esoteric objects that I don&#39;t describe here, but you&#39;ll learn about in depth in other parts of the book:</p>

<ul>
<li><a href="Functions.html">functions</a>, including closures and promises</li>
<li><a href="Environments.html">environments</a> </li>
<li>names/symbols, calls and expression objects, for <a href="metaprogramming.html">metaprogramming</a></li>
</ul>

<p>When trying to understand the structure of an arbitrary object in R your most important tool is <code>str()</code>, short for structure: it gives  a compact human readable description of any R data structure.</p>

<p>The chapter starts by describing R&#39;s 1d structures (atomic vectors and lists), then detours to discuss attributes (R&#39;s flexible metadata specification) and factors, before returning to discuss high-d structures (matrices, arrays and data frames).</p>

<h2>Quiz</h2>

<p>Take this short quiz to determine if you need to read this chapter or not:</p>

<ul>
<li>What are the three properties of a vector? (apart from its contents)</li>
<li>What are the four common types of atomic vector? What are the two rarer types?</li>
<li>What are attributes? How do you get and set them?</li>
<li>How is a list different to a vector?</li>
<li>How is a matrix different to a data frame?</li>
<li>Can a data frame have a column that is a list?</li>
</ul>

<h2>Vectors</h2>

<p>The basic data structure in R is the vector, which comes in two basic flavours: atomic vectors and lists. As well as their content, vectors have three properties: <code>typeof()</code> (what it is), <code>length()</code> (how long it is) and <code>attributes()</code> (additional arbitrary metadata).  The most common attribute is <code>names()</code>.</p>

<p>Each type of vector comes with an <code>as.*</code> coercion function and an <code>is.*</code> testing function. But beware <code>is.vector()</code>: for historical reasons it returns <code>TRUE</code> only if the object is a vector with no attributes apart from names. Use <code>is.atomic(x) || is.list(x)</code> to test if an object is actually a vector.</p>

<h3>Atomic vectors</h3>

<p>Atomic vectors can be logical, integer, double (often called numeric), or character, or less commonly complex or raw.  Atomic vectors are typically created with <code>c</code>:</p>

<div class="chunk" id="unnamed-chunk-21"><div class="rcode"><div class="source"><pre class="knitr r">logical <- c(T, FALSE, TRUE, FALSE)
numeric <- c(1, 2.5, 4.5)
# Note the L suffix which distinguishes numeric from integers
integer <- c(1L, 6L, 10L)
character <- c("these are", "some strings")
</pre></div>

<p></div></div></p>

<p>Atomic vectors are flat, and nesting <code>c()</code> just creates a flat vector:</p>

<div class="chunk" id="unnamed-chunk-22"><div class="rcode"><div class="source"><pre class="knitr r">c(1, c(2, c(3, 4)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 2 3 4
</pre></div>

<div class="source"><pre class="knitr r"># the same as 
c(1, 2, 3, 4)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 2 3 4
</pre></div>

<p></div></div></p>

<h4>Types and tests</h4>

<p>Given a vector, you can determine what type it is with <code>typeof()</code>, or with the specific tests: <code>is.character()</code>, <code>is.double()</code>, <code>is.integer()</code>, <code>is.logical()</code>, or, more generally, <code>is.atomic()</code>.  </p>

<p>Beware of <code>is.numeric()</code>: it&#39;s a general test for the &quot;numberliness&quot; of a vector, not a specific test for double vectors, which are commonly called numeric. <code>is.numeric()</code> is an S3 generic, and returns TRUE for integers.</p>

<div class="chunk" id="unnamed-chunk-23"><div class="rcode"><div class="source"><pre class="knitr r">typeof(integer)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "integer"
</pre></div>

<div class="source"><pre class="knitr r">is.integer(integer)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">is.double(integer)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">is.numeric(integer)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">
typeof(numeric)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "double"
</pre></div>

<div class="source"><pre class="knitr r">is.integer(numeric)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">is.double(numeric)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">is.numeric(numeric)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<h4>Coercion</h4>

<p>An atomic vector can only be of one type, so when you attempt to combine different types they will be <strong>coerced</strong> into one type, picking the first matching class from character, double, integer and logical.</p>

<div class="chunk" id="unnamed-chunk-24"><div class="rcode"><div class="source"><pre class="knitr r">c("a", 1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "1"
</pre></div>

<p></div></div></p>

<p>When a logical vector is coerced to double or integer, <code>TRUE</code> becomes 1 and <code>FALSE</code> becomes 0.  This is very useful in conjunction with <code>sum()</code> and <code>mean()</code></p>

<div class="chunk" id="unnamed-chunk-25"><div class="rcode"><div class="source"><pre class="knitr r">c("a", T)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"    "TRUE"
</pre></div>

<div class="source"><pre class="knitr r">c(1, T, F)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 1 0
</pre></div>

<div class="source"><pre class="knitr r"># Total number of TRUEs
sum(mtcars$cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 11
</pre></div>

<div class="source"><pre class="knitr r"># Proportion of TRUEs
mean(mtcars$cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.3438
</pre></div>

<p></div></div></p>

<p>You can manually force one type of vector to another using a coercion function: <code>as.character()</code>, <code>as.double()</code>, <code>as.integer()</code>, <code>as.logical()</code>. Coercion also happens automatically. Most mathematical functions (<code>+</code>, <code>log</code>, <code>abs</code>, etc.) will coerce to a double or integer, and most logical operations (<code>&amp;</code>, <code>|</code>, <code>any</code>, etc) will coerce to a logical. You will usually get a warning message if the coercion might lose information. If confusion is likely, it&#39;s better to explicitly coerce.</p>

<h3>Lists</h3>

<p>Lists are different from atomic vectors in that they can contain any other type of vector, including lists. You construct them using <code>list()</code> instead of <code>c()</code>.</p>

<div class="chunk" id="unnamed-chunk-26"><div class="rcode"><div class="source"><pre class="knitr r">x <- list(1:3, "a", c(T, F, T), c(2.3, 5.9))
str(x)
</pre></div>

<div class="output"><pre class="knitr r">## List of 4
##  $ : int [1:3] 1 2 3
##  $ : chr "a"
##  $ : logi [1:3] TRUE FALSE TRUE
##  $ : num [1:2] 2.3 5.9
</pre></div>

<p></div></div></p>

<p>Lists are sometimes called <strong>recursive</strong> vectors, because a list can contain other lists. This makes them fundamentally different from atomic vectors.</p>

<div class="chunk" id="unnamed-chunk-27"><div class="rcode"><div class="source"><pre class="knitr r">x <- list(list(list(list())))
str(x)
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ :List of 1
##   ..$ :List of 1
##   .. ..$ : list()
</pre></div>

<div class="source"><pre class="knitr r">is.recursive(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p><code>c()</code> will combine several lists into one. If given a combination of atomic vectors and lists, c() will coerce the vectors to list before combining them. Compare the results of <code>list()</code> versus <code>c()</code>:</p>

<div class="chunk" id="unnamed-chunk-28"><div class="rcode"><div class="source"><pre class="knitr r">x <- list(list(1,2), list("a","b"), 5:9)
y <- c(list(1,2), list("a","b"), 5:9)
str(x)
</pre></div>

<div class="output"><pre class="knitr r">## List of 3
##  $ :List of 2
##   ..$ : num 1
##   ..$ : num 2
##  $ :List of 2
##   ..$ : chr "a"
##   ..$ : chr "b"
##  $ : int [1:5] 5 6 7 8 9
</pre></div>

<div class="source"><pre class="knitr r">str(y)
</pre></div>

<div class="output"><pre class="knitr r">## List of 9
##  $ : num 1
##  $ : num 2
##  $ : chr "a"
##  $ : chr "b"
##  $ : int 5
##  $ : int 6
##  $ : int 7
##  $ : int 8
##  $ : int 9
</pre></div>

<p></div></div></p>

<p>The <code>typeof()</code> a list is <code>list</code>, and you can test and coerce with <code>is.list()</code> and <code>as.list()</code>.</p>

<p>Lists are used to build up most more complicated data structures in R: both data frames (described below), and linear models are lists:</p>

<div class="chunk" id="unnamed-chunk-29"><div class="rcode"><div class="source"><pre class="knitr r">is.list(mtcars)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">names(mtcars)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
## [11] "carb"
</pre></div>

<div class="source"><pre class="knitr r">str(mtcars$mpg)
</pre></div>

<div class="output"><pre class="knitr r">##  num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
</pre></div>

<div class="source"><pre class="knitr r">
mod <- lm(mpg ~ wt, data = mtcars)
is.list(mod)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">names(mod)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] "coefficients"  "residuals"     "effects"       "rank"         
##  [5] "fitted.values" "assign"        "qr"            "df.residual"  
##  [9] "xlevels"       "call"          "terms"         "model"
</pre></div>

<div class="source"><pre class="knitr r">str(mod$qr)
</pre></div>

<div class="output"><pre class="knitr r">## List of 5
##  $ qr   : num [1:32, 1:2] -5.657 0.177 0.177 0.177 0.177 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : chr [1:32] "Mazda RX4" "Mazda RX4 Wag" "Datsun 710" "Hornet 4 Drive" ...
##   .. ..$ : chr [1:2] "(Intercept)" "wt"
##   ..- attr(*, "assign")= int [1:2] 0 1
##  $ qraux: num [1:2] 1.18 1.05
##  $ pivot: int [1:2] 1 2
##  $ tol  : num 1e-07
##  $ rank : int 2
##  - attr(*, "class")= chr "qr"
</pre></div>

<p></div></div></p>

<p>You can turn a list back into a vector using <code>unlist()</code>: this uses the same implicit coercion rules as for <code>c()</code>.</p>

<h2>Attributes</h2>

<p>All objects can have additional arbitrary attributes. These can be thought of as a named list (provided that the names are unique). Attributes can be accessed individually with <code>attr()</code> or all at once (as a list) with <code>attributes()</code>.</p>

<div class="chunk" id="unnamed-chunk-30"><div class="rcode"><div class="source"><pre class="knitr r">y <- 1:10
attr(y, "comment") <- "This is a vector"
attr(y, "comment")
</pre></div>

<div class="output"><pre class="knitr r">## [1] "This is a vector"
</pre></div>

<div class="source"><pre class="knitr r">str(attributes(y))
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ comment: chr "This is a vector"
</pre></div>

<p></div></div></p>

<p>The <code>structure()</code> function returns a new object with modified attributes:</p>

<div class="chunk" id="unnamed-chunk-31"><div class="rcode"><div class="source"><pre class="knitr r">structure(1:10, comment = "This is a vector")
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  1  2  3  4  5  6  7  8  9 10
</pre></div>

<p></div></div></p>

<p>By default, most attributes are lost when modifying a vector:</p>

<div class="chunk" id="unnamed-chunk-32"><div class="rcode"><div class="source"><pre class="knitr r">y + 1
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  2  3  4  5  6  7  8  9 10 11
</pre></div>

<div class="source"><pre class="knitr r">y[1]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">sum(y)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 55
</pre></div>

<p></div></div></p>

<p>The exceptions are for the most common attributes:</p>

<ul>
<li><code>names()</code>, character vector of element names</li>
<li><code>class()</code>, used to implement the S3 object system, described in the next section.</li>
<li><code>dim()</code>, used to turn vectors into high-dimensional structures</li>
</ul>

<p>Set or get these attributes with their accessor functions: use <code>names(x)</code>, <code>class(x)</code> and <code>dim(x)</code>, not <code>attr(x, &quot;names&quot;)</code>, <code>attr(x, &quot;class&quot;)</code>, and <code>attr(x, &quot;dim&quot;)</code>.</p>

<h4>Names</h4>

<p>You can give a vector names in three ways:</p>

<ul>
<li>During creation: <code>x &lt;- c(a = 1, b = 2, c = 3)</code></li>
<li>By modifying a vector in place: <code>x &lt;- 1:3; names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></li>
<li>By creating a modifed vector: <code>x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></li>
</ul>

<p>A vector with no names will return <code>NULL</code> from <code>names(x)</code>; a partially named vector will have entries containing the empty string <code>&quot;&quot;</code>.  You can remove names from a vector with <code>unname()</code></p>

<p>Names should be unique, but this restriction is not enforced. However, if names are not unique, character subsetting (see <a href="Subsetting.html">subsetting</a>), will only return the first match.</p>

<h3>Factors</h3>

<p>The class attribute can be used to add new behaviour to atomic vectors. For example, the factor is a vector that can contain only predefined values, and is R&#39;s structure for dealing with qualitative data. Factors have two key attributes: their <code>class()</code>, &quot;factor&quot;, which controls their behaviour; and their <code>levels()</code>, the set of allowed values.</p>

<div class="chunk" id="unnamed-chunk-33"><div class="rcode"><div class="source"><pre class="knitr r">x <- factor(c("a", "b", "b", "a"))
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] a b b a
## Levels: a b
</pre></div>

<div class="source"><pre class="knitr r">class(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "factor"
</pre></div>

<div class="source"><pre class="knitr r">levels(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b"
</pre></div>

<div class="source"><pre class="knitr r">
# You can't use values not in levels
x[2] <- "c"
</pre></div>

<div class="warning"><pre class="knitr r">## Warning: invalid factor level, NA generated
</pre></div>

<div class="source"><pre class="knitr r">x
</pre></div>

<div class="output"><pre class="knitr r">## [1] a    <NA> b    a   
## Levels: a b
</pre></div>

<div class="source"><pre class="knitr r">
# NB: you can't combine factors
c(factor("a"), factor("b"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 1
</pre></div>

<p></div></div></p>

<p>While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings. Some string methods (like <code>gsub()</code> and <code>grepl()</code>) will coerce factors to strings, while others (like <code>nchar()</code>) will throw an error, and still others will use the underlying integer ids (like <code>[</code>). For this reason, it&#39;s usually best to explicitly convert factors to strings when modifying their levels.</p>

<p>Factors are useful when you know the possible values a variable may take, even if you don&#39;t see them in the dataset. Using a factor instead of a character vector makes it obvious when some groups contain no observations:</p>

<div class="chunk" id="unnamed-chunk-34"><div class="rcode"><div class="source"><pre class="knitr r">sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
</pre></div>

<div class="output"><pre class="knitr r">## sex_char
## m 
## 3
</pre></div>

<div class="source"><pre class="knitr r">table(sex_factor)
</pre></div>

<div class="output"><pre class="knitr r">## sex_factor
## m f 
## 3 0
</pre></div>

<p></div></div></p>

<p>Sometimes due to a data loading error, you&#39;ll get a factor whose levels are numbers. Be very careful when converting these back to numbers: you need to first coerce to a character vector, or you&#39;ll just get the indices of the underlying levels. However, instead of fixing after the fact, it&#39;s better to figure out why it was incorrectly turned into a factor in the first place: it&#39;s often caused by non-standard coding of missing values.</p>

<div class="chunk" id="unnamed-chunk-35"><div class="rcode"><div class="source"><pre class="knitr r">z <- factor(c(12, 1, 9))
as.numeric(z)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3 1 2
</pre></div>

<div class="source"><pre class="knitr r">as.numeric(as.character(z))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 12  1  9
</pre></div>

<p></div></div></p>

<p>Unfortunately, most data loading functions in R automatically convert character vectors to factors. This is suboptimal, because there&#39;s no way for those functions to know the set of all possible levels and their optimal order. Instead, use <code>stringsAsFactors = FALSE</code> to suppress this behaviour, and then manually convert character vectors to factors using your knowledge of the data. A global option (<code>options(stringsAsFactors = FALSE</code>) is available to control this behaviour, but it&#39;s not recommended - it may have unexpected consequences when combined with other code (either from packages, or that you&#39;re <code>source()</code>ing.) In early versions of R, there was a memory advantage to using factors; that is no longer the case.</p>

<p>Atomic vectors and lists are the building blocks for higher dimensional data structures. Atomic vectors extend to matrices and arrays, and lists are used to create data frames.</p>

<h2>Matrices and arrays</h2>

<p>A vector becomes a matrix (2d) or array (&gt;2d) with the addition of a <code>dim()</code> attribute. They can be created using the <code>matrix()</code> and <code>array()</code> functions, or by using the replacement form of <code>dim()</code>:</p>

<div class="chunk" id="unnamed-chunk-36"><div class="rcode"><div class="source"><pre class="knitr r">a <- matrix(1:6, ncol = 3)
b <- array(1:12, c(2, 3, 2))

c <- 1:6
dim(c) <- c(3, 2)
c
</pre></div>

<div class="output"><pre class="knitr r">##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
</pre></div>

<div class="source"><pre class="knitr r">dim(c) <- c(2, 3)
c
</pre></div>

<div class="output"><pre class="knitr r">##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
</pre></div>

<p></div></div></p>

<p><code>length()</code> generalises to <code>nrow()</code> and <code>ncol()</code> for matrices, and <code>dim()</code> for arrays. <code>names()</code> generalises to <code>rownames()</code> and <code>colnames()</code> for matrices, and <code>dimnames()</code> for arrays.</p>

<div class="chunk" id="unnamed-chunk-37"><div class="rcode"><div class="source"><pre class="knitr r">length(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 6
</pre></div>

<div class="source"><pre class="knitr r">nrow(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">ncol(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<div class="source"><pre class="knitr r">rownames(a) <- c("A", "B")
colnames(a) <- c("a", "b", "c")
a
</pre></div>

<div class="output"><pre class="knitr r">##   a b c
## A 1 3 5
## B 2 4 6
</pre></div>

<div class="source"><pre class="knitr r">
length(b)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 12
</pre></div>

<div class="source"><pre class="knitr r">dim(b)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 3 2
</pre></div>

<div class="source"><pre class="knitr r">dimnames(b) <- list(c("one", "two"), c("a", "b", "c"), c("A", "B"))
b
</pre></div>

<div class="output"><pre class="knitr r">## , , A
## 
##     a b c
## one 1 3 5
## two 2 4 6
## 
## , , B
## 
##     a  b  c
## one 7  9 11
## two 8 10 12
</pre></div>

<p></div></div></p>

<p><code>c()</code> generalises to <code>cbind()</code> and <code>rbind()</code> for matrices, and to <code>abind::abind()</code> for arrays.</p>

<p>You can test if an object is a matrix or array using <code>is.matrix()</code> and <code>is.array()</code>, or by looking at the length of the <code>dim()</code> (NB: <code>dim()</code> returns <code>NULL</code> when applied to a vector). <code>is.vector()</code> will return <code>FALSE</code> for matrices and arrays, even though they are implemented as vectors internally. <code>as.matrix()</code> and <code>as.array()</code> make it easy to turn an existing vector into a matrix or array.</p>

<p>Beware that there are a few different ways to create a 1d datastructure: you can have a vector, row vector, column vector, or a 1d array. They may print similarly, but will behave differently. As always, use <code>str()</code> to reveal the differences.</p>

<div class="chunk" id="unnamed-chunk-38"><div class="rcode"><div class="source"><pre class="knitr r">str(list(
  vector = 1:3,
  col_vector = matrix(1:3, ncol = 1),
  row_vector = matrix(1:3, nrow = 1),
  array = array(1:3, 3)
))
</pre></div>

<div class="output"><pre class="knitr r">## List of 4
##  $ vector    : int [1:3] 1 2 3
##  $ col_vector: int [1:3, 1] 1 2 3
##  $ row_vector: int [1, 1:3] 1 2 3
##  $ array     : int [1:3(1d)] 1 2 3
</pre></div>

<p></div></div></p>

<p>While atomic vectors are most commonly turned into matrices, the dimension attribute can also be set on lists to make list-matrices or list-arrays:</p>

<div class="chunk" id="unnamed-chunk-39"><div class="rcode"><div class="source"><pre class="knitr r">l <- list(1:3, "a", T, 1.0)
dim(l) <- c(2, 2)
l
</pre></div>

<div class="output"><pre class="knitr r">##      [,1]      [,2]
## [1,] Integer,3 TRUE
## [2,] "a"       1
</pre></div>

<p></div></div></p>

<p>These are relatively esoteric data structures, but can be useful if you want to arrange objects into a grid-like structure. For example, if you&#39;re running models on a spatio-temporal grid, it might be natural to preserve the grid structure by storing the models in a 3d array.</p>

<h2>Data frames</h2>

<p>A data frame is the most common way of storing data in R, and if <a href="http://vita.had.co.nz/papers/tidy-data.pdf">used systematically</a> make data analysis easier. Under the hood, a data frame is a list of equal-length vectors. This makes it a 2d dimensional structure, so it shares properties of both the matrix and the list.  This means that a data frame has <code>names()</code>, <code>colnames()</code> and <code>rownames()</code>, although <code>names()</code> and <code>colnames()</code> are the same thing. The <code>length()</code> of a data frame is the length of the underlying list and so is the same as <code>ncol()</code>, <code>nrow()</code> gives the number of rows.</p>

<p>As described in <a href="subsetting.html">subsetting</a>, you can subset a data frame like a 1d structure (where it behaves like a list), or a 2d structure (where it behaves like a matrix).</p>

<h3>Creation</h3>

<p>You create a data frame using <code>data.frame()</code>, which takes named vectors as input:</p>

<div class="chunk" id="unnamed-chunk-40"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:3, y = c("a", "b", "c"))
str(df)
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y: Factor w/ 3 levels "a","b","c": 1 2 3
</pre></div>

<p></div></div></p>

<p>Beware the default behaviour of <code>data.frame()</code> to convert strings into factors. Use <code>stringAsFactors = FALSE</code> to suppress this behaviour:</p>

<div class="chunk" id="unnamed-chunk-41"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c"), 
  stringsAsFactors = FALSE)
str(df)
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y: chr  "a" "b" "c"
</pre></div>

<p></div></div></p>

<h3>Testing and coercion</h3>

<p>Because a data frame is an S3 class, the type of a data frame reflects the underlying vector used to build it: <code>list</code>. Instead you can look at its <code>class()</code> or test for a data frame with <code>is.data.frame()</code>:</p>

<div class="chunk" id="unnamed-chunk-42"><div class="rcode"><div class="source"><pre class="knitr r">typeof(df)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "list"
</pre></div>

<div class="source"><pre class="knitr r">class(df)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "data.frame"
</pre></div>

<div class="source"><pre class="knitr r">is.data.frame(df)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>You can coerce an object to a data frame with <code>as.data.frame()</code>:</p>

<ul>
<li>a vector will yield a one-column data frame</li>
<li>a list will yield one column for each element; it&#39;s an error if they&#39;re not all the same length</li>
<li>a matrix will yield a data frame with the same number of columns</li>
</ul>

<h3>Combining data frames</h3>

<p>You can combine data frames using <code>cbind()</code> and <code>rbind()</code>:</p>

<div class="chunk" id="unnamed-chunk-43"><div class="rcode"><div class="source"><pre class="knitr r">cbind(df, data.frame(y = 4))
</pre></div>

<div class="output"><pre class="knitr r">##   x y y
## 1 1 a 4
## 2 2 b 4
## 3 3 c 4
</pre></div>

<div class="source"><pre class="knitr r">rbind(df, data.frame(x = 10))
</pre></div>

<div class="error"><pre class="knitr r">## Error: numbers of columns of arguments do not match
</pre></div>

<p></div></div></p>

<p>When combining column-wise, only the number of rows needs to match, and rownames are ignored. When combining row-wise, the column names must match. If you want to combine data frames that may not have all the same variables, use <code>plyr::rbind.fill()</code></p>

<p>It&#39;s a common mistake to try and create a data frame by <code>cbind()</code>ing vectors together. This doesn&#39;t work because <code>cbind()</code> will create a matrix unless one of the arguments is already a data frame. Instead use <code>data.frame()</code> directly:</p>

<div class="chunk" id="unnamed-chunk-44"><div class="rcode"><div class="source"><pre class="knitr r">bad <- data.frame(cbind(a = 1:2, b = c("a", "b")))
str(bad)
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   2 obs. of  2 variables:
##  $ a: Factor w/ 2 levels "1","2": 1 2
##  $ b: Factor w/ 2 levels "a","b": 1 2
</pre></div>

<div class="source"><pre class="knitr r">good <- data.frame(a = 1:2, b = c("a", "b"), 
  stringsAsFactors = FALSE)
str(good)
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   2 obs. of  2 variables:
##  $ a: int  1 2
##  $ b: chr  "a" "b"
</pre></div>

<p></div></div></p>

<p>The conversion rules for <code>cbind()</code> are complicated and best avoided by ensuring all inputs are of the same type. </p>

<h3>Special columns</h3>

<p>Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list:</p>

<div class="chunk" id="unnamed-chunk-45"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:3)
df$y <- list(1:2, 1:3, 1:4)
df
</pre></div>

<div class="output"><pre class="knitr r">##   x          y
## 1 1       1, 2
## 2 2    1, 2, 3
## 3 3 1, 2, 3, 4
</pre></div>

<p></div></div></p>

<p>However, when a list is given to <code>data.frame()</code>, it tries to put each item of the list into its own column, so this fails:</p>

<div class="chunk" id="unnamed-chunk-46"><div class="rcode"><div class="source"><pre class="knitr r">data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
</pre></div>

<div class="error"><pre class="knitr r">## Error: arguments imply differing number of rows: 2, 3, 4
</pre></div>

<p></div></div></p>

<p>A workaround is to use <code>I()</code> which causes <code>data.frame</code> to treat the list as one unit:</p>

<div class="chunk" id="unnamed-chunk-47"><div class="rcode"><div class="source"><pre class="knitr r">dfl <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(dfl)
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y:List of 3
##   ..$ : int  1 2
##   ..$ : int  1 2 3
##   ..$ : int  1 2 3 4
##   ..- attr(*, "class")= chr "AsIs"
</pre></div>

<div class="source"><pre class="knitr r">dfl[2, "y"]
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 1 2 3
</pre></div>

<p></div></div></p>

<p><code>I()</code> adds the <code>AsIs</code> class to its input, but this additional attribute can usually be safely ignored.</p>

<p>Similarly, it&#39;s also possible to have a column of a data frame that&#39;s a matrix or array, as long as the number of rows matches the data frame:</p>

<div class="chunk" id="unnamed-chunk-48"><div class="rcode"><div class="source"><pre class="knitr r">dfm <- data.frame(x = 1:3, y = I(matrix(1:9, nrow = 3)))
str(dfm)
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y: 'AsIs' int [1:3, 1:3] 1 2 3 4 5 6 7 8 9
</pre></div>

<div class="source"><pre class="knitr r">dfm[2, "y"]
</pre></div>

<div class="output"><pre class="knitr r">##      [,1] [,2] [,3]
## [1,]    2    5    8
</pre></div>

<p></div></div></p>

<p>Use list and array columns with caution: many functions that work with data frames assume that all columns are atomic vectors.</p>

<h1>Subsetting</h1>

<p>R&#39;s subsetting operators are powerful and fast, and mastering them allows you to succinctly express complex operations. Subsetting allows you to express common data manipulation operations very succinctly, in a way few other languages can match. Subsetting is a natural complement to <code>str()</code>: <code>str()</code> shows you the structure of any object, and subsetting allows you to pull out the pieces that you&#39;re interested in.</p>

<p>Subsetting is hard to learn because you need to master a number of interrelated concepts:</p>

<ul>
<li>the three subsetting operators,</li>
<li>the six types of subsetting, </li>
<li>important difference in subsetting behaviour for different objects (e.g. vectors, lists, factors, matrices and data frames)</li>
<li>using subsetting in conjunction with assignment</li>
</ul>

<p>This chapter starts by introducing you to subsetting atomic vectors with <code>[</code>, and then gradually extends your knowledge, first to more complicated data types (like arrays and lists), and then to the other subsetting operators. You&#39;ll then learn how subsetting and assignment can be combined, and finally, you&#39;ll see a large number of useful applications.</p>

<h2>Data types</h2>

<p>It&#39;s easiest to understand how subsetting works for atomic vectors, and then learn how it generalises to higher dimensions and other more complicated objects. We&#39;ll start by exploring the use of <code>[</code>, the most commonly used operator. The next section will discuss  <code>[[</code> and <code>$</code>, the two other main subsetting operators.</p>

<h3>Atomic vectors</h3>

<p>Let&#39;s explore the different types of subsetting with a simple vector, <code>x</code>. </p>

<div class="chunk" id="unnamed-chunk-49"><div class="rcode"><div class="source"><pre class="knitr r">x <- c(2.1, 4.2, 3.3, 5.4)
</pre></div>

<p></div></div></p>

<p><strong>NB:</strong> the number after the decimal point gives the original position in the vector.</p>

<p>There are five ways of subsetting <code>x</code>:</p>

<ul>
<li>with <strong>positive integers</strong>, which return elements at the specified positions.</li>
</ul>

<div class="chunk" id="unnamed-chunk-50"><div class="rcode"><div class="source"><pre class="knitr r">x[c(3, 1)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3.3 2.1
</pre></div>

<div class="source"><pre class="knitr r">x[order(x)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 3.3 4.2 5.4
</pre></div>

<div class="source"><pre class="knitr r">
# Duplicated indices yield duplicated values
x[c(1, 1)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 2.1
</pre></div>

<div class="source"><pre class="knitr r">
# Real numbers are silently truncated to integers
x[c(2.1, 2.9)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4.2 4.2
</pre></div>

<p></div></div></p>

<ul>
<li>with <strong>negative integers</strong>, which omit elements at the specified positions</li>
</ul>

<div class="chunk" id="unnamed-chunk-51"><div class="rcode"><div class="source"><pre class="knitr r">x[-c(3, 1)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4.2 5.4
</pre></div>

<p></div></div></p>

<pre><code>It&#39;s an error to mix positive and negative integers in a single subset:
</code></pre>

<div class="chunk" id="unnamed-chunk-52"><div class="rcode"><div class="source"><pre class="knitr r">x[c(-1, 2)]
</pre></div>

<div class="error"><pre class="knitr r">## Error: only 0's may be mixed with negative subscripts
</pre></div>

<p></div></div></p>

<ul>
<li>with a <strong>logical vector</strong>, which selects elements where the corresponding logical value is <code>TRUE</code>. This is probably the most useful type of subsetting, because you will usually generate the logical vector with another expression.</li>
</ul>

<div class="chunk" id="unnamed-chunk-53"><div class="rcode"><div class="source"><pre class="knitr r">x[c(TRUE, TRUE, FALSE, FALSE)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 4.2
</pre></div>

<div class="source"><pre class="knitr r">x[x > 3]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4.2 3.3 5.4
</pre></div>

<p></div></div></p>

<pre><code>If the logical vector is shorter than the vector being subsetted, it will be _recycled_ to be the same length.
</code></pre>

<div class="chunk" id="unnamed-chunk-54"><div class="rcode"><div class="source"><pre class="knitr r">x[c(TRUE, FALSE)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 3.3
</pre></div>

<div class="source"><pre class="knitr r"># Equivalent to
x[c(TRUE, FALSE, TRUE, FALSE)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 3.3
</pre></div>

<p></div></div></p>

<pre><code>A missing value in the index always yields a missing value in the output:
</code></pre>

<div class="chunk" id="unnamed-chunk-55"><div class="rcode"><div class="source"><pre class="knitr r">x[c(TRUE, TRUE, NA, FALSE)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 4.2  NA
</pre></div>

<p></div></div></p>

<ul>
<li>with <strong>nothing</strong>, which returns the original vector unchanged. This is not useful in 1d, but it&#39;s very useful in 2d, and is useful in conjunction with assignment.</li>
</ul>

<div class="chunk" id="unnamed-chunk-56"><div class="rcode"><div class="source"><pre class="knitr r">x[]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.1 4.2 3.3 5.4
</pre></div>

<p></div></div></p>

<ul>
<li>with <strong>zero</strong>, which returns a zero-length vector. This is not something you&#39;d usually do on purpose, but it can be helpful for generating test data.</li>
</ul>

<div class="chunk" id="unnamed-chunk-57"><div class="rcode"><div class="source"><pre class="knitr r">x[0]
</pre></div>

<div class="output"><pre class="knitr r">## numeric(0)
</pre></div>

<p></div></div></p>

<p>If the vector is named, you can also subset with:</p>

<ul>
<li>a <strong>character vector</strong>, which returns elements with matching names.</li>
</ul>

<div class="chunk" id="unnamed-chunk-58"><div class="rcode"><div class="source"><pre class="knitr r">(y <- setNames(x, letters[1:4]))
</pre></div>

<div class="output"><pre class="knitr r">##   a   b   c   d 
## 2.1 4.2 3.3 5.4
</pre></div>

<div class="source"><pre class="knitr r">y[c("d", "c", "a")]
</pre></div>

<div class="output"><pre class="knitr r">##   d   c   a 
## 5.4 3.3 2.1
</pre></div>

<div class="source"><pre class="knitr r">
# Like integer indices, you can repeat indices
y[c("a", "a", "a")]
</pre></div>

<div class="output"><pre class="knitr r">##   a   a   a 
## 2.1 2.1 2.1
</pre></div>

<div class="source"><pre class="knitr r">
# Names are always matched exactly, not partially
z <- c(abc = 1, def = 2)
z[c("a", "d")]
</pre></div>

<div class="output"><pre class="knitr r">## <NA> <NA> 
##   NA   NA
</pre></div>

<p></div></div></p>

<h3>Lists</h3>

<p>Subsetting a list works in exactly the same way as subsetting an atomic vector. Subsetting a list with <code>[</code> will always return a list: <code>[[</code> and <code>$</code>, as described below, let you pull out the components of the list.</p>

<h3>Matrices and arrays</h3>

<p>You can subset higher-dimension structures in three ways: with multiple vectors, with a single vector, or with a matrix.</p>

<p>The most common way of subsetting matrices (2d) and arrays (&gt;2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comma. Blank subsetting now becomes useful, because you use it when you want to return all the rows or all the columns.</p>

<div class="chunk" id="unnamed-chunk-59"><div class="rcode"><div class="source"><pre class="knitr r">a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a[1:2, ]
</pre></div>

<div class="output"><pre class="knitr r">##      A B C
## [1,] 1 4 7
## [2,] 2 5 8
</pre></div>

<div class="source"><pre class="knitr r">a[c(T, F, T), c("B", "A")]
</pre></div>

<div class="output"><pre class="knitr r">##      B A
## [1,] 4 1
## [2,] 6 3
</pre></div>

<div class="source"><pre class="knitr r">a[0, -2]
</pre></div>

<div class="output"><pre class="knitr r">##      A C
</pre></div>

<p></div></div></p>

<p>By default, <code>[</code> will simplify the results to the lowest possible dimensionality. See <a href="#simplify-preserve">simplifying vs. preserving</a> subsetting for how to avoid this.</p>

<p>Because matrices and arrays are implemented as vectors with special attributes, you can also subset them with a single vector, in which case they will behave like a vector. Arrays in R are stored in row major order:</p>

<div class="chunk" id="unnamed-chunk-60"><div class="rcode"><div class="source"><pre class="knitr r">(vals <- outer(1:5, 1:5, FUN = "paste", sep = ","))
</pre></div>

<div class="output"><pre class="knitr r">##      [,1]  [,2]  [,3]  [,4]  [,5] 
## [1,] "1,1" "1,2" "1,3" "1,4" "1,5"
## [2,] "2,1" "2,2" "2,3" "2,4" "2,5"
## [3,] "3,1" "3,2" "3,3" "3,4" "3,5"
## [4,] "4,1" "4,2" "4,3" "4,4" "4,5"
## [5,] "5,1" "5,2" "5,3" "5,4" "5,5"
</pre></div>

<div class="source"><pre class="knitr r">vals[c(4, 15)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] "4,1" "5,3"
</pre></div>

<p></div></div></p>

<p>You can also subset high-d data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of a value, with each column corresponding to a dimension in the array being subsetted. The result is a vector of values:</p>

<div class="chunk" id="unnamed-chunk-61"><div class="rcode"><div class="source"><pre class="knitr r">vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 1,
  3, 1,
  2, 4
))
vals[select]
</pre></div>

<div class="output"><pre class="knitr r">## [1] "1,1" "3,1" "2,4"
</pre></div>

<p></div></div></p>

<h3>Data frames</h3>

<p>Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.</p>

<div class="chunk" id="unnamed-chunk-62"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ]
</pre></div>

<div class="output"><pre class="knitr r">##   x y z
## 2 2 2 b
</pre></div>

<div class="source"><pre class="knitr r">df[c(1, 3), ]
</pre></div>

<div class="output"><pre class="knitr r">##   x y z
## 1 1 3 a
## 3 3 1 c
</pre></div>

<div class="source"><pre class="knitr r">
# There are two ways to select columns from a data frame
# Like a list:
df[c("x", "z")]
</pre></div>

<div class="output"><pre class="knitr r">##   x z
## 1 1 a
## 2 2 b
## 3 3 c
</pre></div>

<div class="source"><pre class="knitr r"># Like a matrix
df[, c("x", "z")]
</pre></div>

<div class="output"><pre class="knitr r">##   x z
## 1 1 a
## 2 2 b
## 3 3 c
</pre></div>

<div class="source"><pre class="knitr r">
# There's an important difference if you select a simple column:
# matrix subsetting simplifies by default, list subsetting does not.
df["x"]
</pre></div>

<div class="output"><pre class="knitr r">##   x
## 1 1
## 2 2
## 3 3
</pre></div>

<div class="source"><pre class="knitr r">df[, "x"]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 2 3
</pre></div>

<p></div></div></p>

<h3>S3 objects</h3>

<p>S3 objects are always made up of atomic vectors, arrays and lists, so you can always pull apart an S3 object using the techniques described above and the knowledge you gain from <code>str()</code>.</p>

<h3>S4 objects</h3>

<p>There are also two additional subsetting operators that are needed for S4 objects: <code>@</code> (equivalent to <code>$</code>), and <code>slot()</code> (equivalent to <code>[[</code>). <code>@</code> is also more restrictive than <code>$</code> in that it will return an error if the slot does not exist. These are described in more detail in the <a href="OO-essentials.html">OO field guide</a>.</p>

<h3>Exercises</h3>

<ul>
<li>Fix each of the following common data frame subsetting errors:</li>
</ul>

<div class="chunk" id="unnamed-chunk-63"><div class="rcode"><div class="source"><pre class="knitr r">mtcars[mtcars$cyl = 4, ]
mtcars[-1:4, ]
mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl == 4 | 6, ]
</pre></div>

<p></div></div></p>

<ul>
<li><p>Why does <code>x &lt;- 1:5; x[NA]</code> yield five missing values? Hint: why is it different to <code>x[NA_real_]</code>?</p></li>
<li><p>What does <code>upper.tri()</code> return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?  </p>

<pre><code class="R">x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;)
x[upper.tri(x)]
</code></pre></li>
<li><p>Why does <code>mtcars[1:20]</code> return a error? How does it differ from the similar <code>mtcars[1:20, ]</code>?</p></li>
<li><p>Implement a function that extracts the diagonal entries from a matrix (it should behave like <code>diag(x)</code> when <code>x</code> is a matrix).</p></li>
<li><p>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it work?</p></li>
</ul>

<h2>Subsetting operators</h2>

<p>Apart from <code>[</code>, there are two other subsetting operators: <code>[[</code> and <code>$</code>. <code>[[</code> is similar to <code>[</code>, except it only ever returns a single value, and it allows you to pull pieces out of a list. <code>$</code> is a useful shorthand for <code>[[</code> combined with character subsetting.</p>

<p>You need <code>[[</code> when working with lists. <code>[</code> will only ever give you a list back - it never gives you the contents of the list. <code>[[</code> allows you to extract the contents of a list:</p>

<blockquote>
<p>&quot;If list <code>x</code> is a train carrying objects, then <code>x[[5]]</code> is 
the object in car 5; <code>x[4:6]</code> is a train of cars 4-6.&quot; --- 
<a href="http://twitter.com/#!/RLangTip/status/118339256388304896">@RLangTip</a></p>
</blockquote>

<p>Because it can return only a single value, you must use <code>[[</code> with either a single positive integer or a string:</p>

<div class="chunk" id="unnamed-chunk-64"><div class="rcode"><div class="source"><pre class="knitr r">a <- list(a = 1, b = 2)
a[[1]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">a[["a"]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">
# If you do supply a vector it indexes recursively
b <- list(a = list(b = list(c = list(d = 1))))
b[[c("a", "b", "c", "d")]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r"># Same as
b[["a"]][["b"]][["c"]][["d"]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p>Because data frames are lists of their columns, you can use <code>[[</code> to extract a column from data frames: <code>mtcars[[1]]</code>, <code>mtcars[[&quot;cyl&quot;]]</code>.</p>

<p>S3 and S4 objects can override the standard behaviour of <code>[</code> and <code>[[</code> so they behave differently for different types of objects. The key difference is usually how you select between simplifying or preserving behaviours, and what the default is.</p>

<h3>Simplifying vs. preserving subsetting {#simplify-preserve}</h3>

<p>It&#39;s important to understand the distinction between simplifying and preserving subsetting. Simplifying subsets return the simplest possible data structure that can represent the output. They are useful interactively because they usually give you what you want. Preserving subsetting keeps the structure of the output the same as the input, and is generally better for programming, because the result will always be the same type. Omitting <code>drop = FALSE</code> when subsetting matrices and data frames is one of the most common sources of programming errors. (It&#39;ll work for your test cases, but then someone will pass in a single column data frame and it will fail in an unexpected and unclear way).</p>

<p>Unfortunately, how you switch between subsetting and preserving differs for different data types, as summarised in the table below.</p>

<table><thead>
<tr>
<th></th>
<th>Simplifying</th>
<th>Preserving</th>
</tr>
</thead><tbody>
<tr>
<td>Vector</td>
<td><code>x[[1]]</code></td>
<td><code>x[1]</code></td>
</tr>
<tr>
<td>List</td>
<td><code>x[[1]]</code></td>
<td><code>x[1]</code></td>
</tr>
<tr>
<td>Factor</td>
<td><code>x[1:4, drop = T]</code></td>
<td><code>x[1:4]</code></td>
</tr>
<tr>
<td>Array</td>
<td><code>x[1, ]</code>, <code>x[, 1]</code></td>
<td><code>x[1, , drop = F]</code>, <code>x[, 1, drop = F]</code></td>
</tr>
<tr>
<td>Data frame</td>
<td><code>x[, 1]</code>, <code>x[[1]]</code></td>
<td><code>x[, 1, drop = F]</code>, <code>x[1]</code></td>
</tr>
</tbody></table>

<p>Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies a little between different data types, as described below:</p>

<ul>
<li><strong>atomic vector</strong>: removes names</li>
</ul>

<div class="chunk" id="unnamed-chunk-65"><div class="rcode"><div class="source"><pre class="knitr r">x <- c(a = 1, b = 2)
x[1]
</pre></div>

<div class="output"><pre class="knitr r">## a 
## 1
</pre></div>

<div class="source"><pre class="knitr r">x[[1]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<ul>
<li><strong>list</strong>: return the object inside the list, not a single element list</li>
</ul>

<div class="chunk" id="unnamed-chunk-66"><div class="rcode"><div class="source"><pre class="knitr r">y <- list(a = 1, b = 2)
str(y[1])
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ a: num 1
</pre></div>

<div class="source"><pre class="knitr r">str(y[[1]])
</pre></div>

<div class="output"><pre class="knitr r">##  num 1
</pre></div>

<p></div></div></p>

<ul>
<li><strong>factor</strong>: drops any unnused levels</li>
</ul>

<div class="chunk" id="unnamed-chunk-67"><div class="rcode"><div class="source"><pre class="knitr r">z <- factor(c("a", "b"))
z[1]
</pre></div>

<div class="output"><pre class="knitr r">## [1] a
## Levels: a b
</pre></div>

<div class="source"><pre class="knitr r">z[1, drop = TRUE]
</pre></div>

<div class="output"><pre class="knitr r">## [1] a
## Levels: a
</pre></div>

<p></div></div></p>

<ul>
<li><strong>matrix</strong> or <strong>array</strong>: if any of the dimensions has length 1, drops that dimension.</li>
</ul>

<div class="chunk" id="unnamed-chunk-68"><div class="rcode"><div class="source"><pre class="knitr r">a <- matrix(1:4, nrow = 2)
a[1, , drop = FALSE]
</pre></div>

<div class="output"><pre class="knitr r">##      [,1] [,2]
## [1,]    1    3
</pre></div>

<div class="source"><pre class="knitr r">a[1, ]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 3
</pre></div>

<p></div></div></p>

<ul>
<li><strong>data frame</strong>: if output is a single column, returns a vector instead of a data frame</li>
</ul>

<div class="chunk" id="unnamed-chunk-69"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(a = 1:2, b = 1:2)
str(df[1])
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   2 obs. of  1 variable:
##  $ a: int  1 2
</pre></div>

<div class="source"><pre class="knitr r">str(df[[1]])
</pre></div>

<div class="output"><pre class="knitr r">##  int [1:2] 1 2
</pre></div>

<div class="source"><pre class="knitr r">str(df[, "a", drop = FALSE])
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   2 obs. of  1 variable:
##  $ a: int  1 2
</pre></div>

<div class="source"><pre class="knitr r">str(df[, "a"])
</pre></div>

<div class="output"><pre class="knitr r">##  int [1:2] 1 2
</pre></div>

<p></div></div></p>

<h3><code>$</code></h3>

<p><code>$</code> is a shorthand operator, where <code>x$y</code> is equivalent to <code>x[[&quot;y&quot;, exact = FALSE]]</code>.  It&#39;s commonly used to access columns of a dataframe, e.g. <code>mtcars$cyl</code>, <code>diamonds$carat</code>. </p>

<p>One common mistake with <code>$</code> is to try and use it when you have the name of a column stored in a variable:</p>

<div class="chunk" id="unnamed-chunk-70"><div class="rcode"><div class="source"><pre class="knitr r">var <- "cyl"
# Doesn't work - mtcars$var translated to mtcars[["var"]]
mtcars$var
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<div class="source"><pre class="knitr r">
# Instead use [[
mtcars[[var]]
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
</pre></div>

<p></div></div></p>

<p>There&#39;s one important different between <code>$</code> and <code>[[</code> - <code>$</code> does partial matching:</p>

<div class="chunk" id="unnamed-chunk-71"><div class="rcode"><div class="source"><pre class="knitr r">x <- list(abc = 1)
x$a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">x[["a"]]
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<p></div></div></p>

<p>If you want to avoid this behaviour you can set <code>options(warnPartialMatchDollar = TRUE)</code> - but beware that this is a global option and may affect behaviour in other code you have loaded (e.g. packages).</p>

<h3>Missing/out of bounds indices</h3>

<p><code>[</code> and <code>[[</code> differ slightly in their behaviour when the index is out of bounds (OOB), e.g. trying to extract the fifth element of a length four vector, missing, or <code>NULL</code>.  Generally, it&#39;s preferable to use a function that throws an error when the input is incorrect so that mistakes aren&#39;t silently ignored.</p>

<table><thead>
<tr>
<th>Operator</th>
<th>Index</th>
<th>Atomic</th>
<th>List</th>
</tr>
</thead><tbody>
<tr>
<td><code>[</code></td>
<td>OOB</td>
<td><code>NA</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>NA_real_</code></td>
<td><code>NA</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>NULL</code></td>
<td><code>x[0]</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr>
<td><code>[[</code></td>
<td>OOB</td>
<td>Error</td>
<td>Error</td>
</tr>
<tr>
<td><code>[[</code></td>
<td><code>NA_real</code></td>
<td>Error</td>
<td><code>NULL</code></td>
</tr>
<tr>
<td><code>[[</code></td>
<td><code>NULL</code></td>
<td>Error</td>
<td>Error</td>
</tr>
</tbody></table>

<p>If the input vector is named, then the names of OOB, missing, or <code>NULL</code> components will be <code>&quot;&lt;NA&gt;&quot;</code>.</p>

<h3>Exercises</h3>

<ul>
<li>Given a linear model, e.g. <code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract the residual degrees of freedom. Extract the R squared from the model summary (<code>summary(mod)</code>)</li>
</ul>

<h2>Subsetting and assignment</h2>

<p>All subsetting operators can be combined with assignment to modify selected values of the input vector. </p>

<div class="chunk" id="unnamed-chunk-73"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1:5
x[c(1, 2)] <- 2:3
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 3 3 4 5
</pre></div>

<div class="source"><pre class="knitr r">
# The length of the LHS needs to match the RHS
x[-1] <- 4:1
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 4 3 2 1
</pre></div>

<div class="source"><pre class="knitr r">
# Note that there's no checking for duplicate indices
x[c(1, 1)] <- 2:3
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3 4 3 2 1
</pre></div>

<div class="source"><pre class="knitr r">
# You can't combine integer indices with NA
x[c(1, NA)] <- c(1, 2)
</pre></div>

<div class="error"><pre class="knitr r">## Error: NAs are not allowed in subscripted assignments
</pre></div>

<div class="source"><pre class="knitr r"># But you can combine logical indices with NA
# (where they're treated as false). 
x[c(T, F, NA)] <- 1
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 4 3 1 1
</pre></div>

<div class="source"><pre class="knitr r">
# This is mostly useful when conditionally modifying vectors
df <- data.frame(a = c(1, 10, NA))
df$a[df$a < 5] <- 0
df$a
</pre></div>

<div class="output"><pre class="knitr r">## [1]  0 10 NA
</pre></div>

<p></div></div></p>

<p>Indexing with a blank can be useful in conjunction with assignment, because it will preserve the original object class and structure. Compare the following two expressions. In the first, <code>mtcars</code> will remain as a dataframe, in the second <code>mtcars</code> will become a list.</p>

<div class="chunk" id="unnamed-chunk-74"><div class="rcode"><div class="source"><pre class="knitr r">mtcars[] <- lapply(mtcars, as.integer)
mtcars <- lapply(mtcars, as.integer)
</pre></div>

<p></div></div></p>

<p>With lists, you can use subsetting + assignment + <code>NULL</code> to remove components from a list. To add a literal <code>NULL</code> to a list, use <code>[</code> and <code>list(NULL)</code>:</p>

<div class="chunk" id="unnamed-chunk-75"><div class="rcode"><div class="source"><pre class="knitr r">x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ a: num 1
</pre></div>

<div class="source"><pre class="knitr r">
y <- list(a = 1)
y["b"] <- list(NULL)
str(y)
</pre></div>

<div class="output"><pre class="knitr r">## List of 2
##  $ a: num 1
##  $ b: NULL
</pre></div>

<p></div></div></p>

<h2>Applications</h2>

<p>The basic principles described above give rise to a wide variety of useful applications. Some of the most important are described below. Many of these basic techniques are wrapped up into more concise functions (e.g. <code>subset()</code>, <code>merge()</code>, <code>plyr::arrange()</code>), but it is useful to understand how they are implemented with basic subsetting. This will allow you to adapt to new situations that are not dealt with by existing functions.</p>

<h3>Lookup tables (character subsetting)</h3>

<p>Character matching provides a powerful way to make lookup tables.  Say you want to convert abbreviations:</p>

<div class="chunk" id="unnamed-chunk-76"><div class="rcode"><div class="source"><pre class="knitr r">x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c("m" = "Male", "f" = "Female", u = NA)
lookup[x]
</pre></div>

<div class="output"><pre class="knitr r">##        m        f        u        f        f        m        m 
##   "Male" "Female"       NA "Female" "Female"   "Male"   "Male"
</pre></div>

<div class="source"><pre class="knitr r">unname(lookup[x])
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Male"   "Female" NA       "Female" "Female" "Male"   "Male"
</pre></div>

<div class="source"><pre class="knitr r">
# Or with fewer output values
c("m" = "Known", "f" = "Known", u = "Unknown")[x]
</pre></div>

<div class="output"><pre class="knitr r">##         m         f         u         f         f         m         m 
##   "Known"   "Known" "Unknown"   "Known"   "Known"   "Known"   "Known"
</pre></div>

<p></div></div></p>

<p>If you don&#39;t want names in the result, use <code>unname()</code> to remove them.</p>

<h3>Matching and merging by hand (integer subsetting)</h3>

<p>You may have a more complicated lookup table which has multiple columns of information. Suppose we have a vector of integer grades, and a table that describes their properties:</p>

<div class="chunk" id="unnamed-chunk-77"><div class="rcode"><div class="source"><pre class="knitr r">grades <- sample(3, 5, rep = T)

info <- data.frame(
  grade = 1:3,
  desc = c("Poor", "Good", "Excellent"),
  fail = c(T, F, F)
)
</pre></div>

<p></div></div></p>

<p>We want to duplicate the info table so that we have a row for each value in <code>grades</code>. We can do this in two ways, either using <code>match()</code> and integer subsetting, or <code>rownames()</code> and character subsetting:</p>

<div class="chunk" id="unnamed-chunk-78"><div class="rcode"><div class="source"><pre class="knitr r">grades
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 1 3 3 1
</pre></div>

<div class="source"><pre class="knitr r">
# Using match
id <- match(grades, info$grade)
info[id, ]
</pre></div>

<div class="output"><pre class="knitr r">##     grade      desc  fail
## 2       2      Good FALSE
## 1       1      Poor  TRUE
## 3       3 Excellent FALSE
## 3.1     3 Excellent FALSE
## 1.1     1      Poor  TRUE
</pre></div>

<div class="source"><pre class="knitr r">
# Using rownames
rownames(info) <- info$grade
info[as.character(grades), ]
</pre></div>

<div class="output"><pre class="knitr r">##     grade      desc  fail
## 2       2      Good FALSE
## 1       1      Poor  TRUE
## 3       3 Excellent FALSE
## 3.1     3 Excellent FALSE
## 1.1     1      Poor  TRUE
</pre></div>

<p></div></div></p>

<p>If you have multiple columns to match on, you&#39;ll need to first collapse them to a single column (with <code>interaction()</code>, <code>paste()</code>, or <code>plyr::id()</code>).  You can also use <code>merge()</code> or <code>plyr::join()</code>, which do the same thing for you - read the source code to see how.</p>

<h3>Random samples/bootstrap (integer subsetting)</h3>

<p>You can use integer indices to perform random sampling or bootstrapping of a vector or data frame. You use <code>sample()</code> to generate a vector of indices, and then use subsetting to access the values:</p>

<div class="chunk" id="unnamed-chunk-79"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])

# Randomly reorder
df[sample(nrow(df)), ]
</pre></div>

<div class="output"><pre class="knitr r">##   x y z
## 4 2 3 d
## 3 2 4 c
## 5 3 2 e
## 2 1 5 b
## 6 3 1 f
## 1 1 6 a
</pre></div>

<div class="source"><pre class="knitr r"># Select 3 random rows
df[sample(nrow(df), 3), ]
</pre></div>

<div class="output"><pre class="knitr r">##   x y z
## 4 2 3 d
## 3 2 4 c
## 2 1 5 b
</pre></div>

<div class="source"><pre class="knitr r"># Select 10 bootstrap samples
df[sample(nrow(df), 10, rep = T), ]
</pre></div>

<div class="output"><pre class="knitr r">##     x y z
## 5   3 2 e
## 4   2 3 d
## 5.1 3 2 e
## 4.1 2 3 d
## 3   2 4 c
## 4.2 2 3 d
## 4.3 2 3 d
## 5.2 3 2 e
## 2   1 5 b
## 1   1 6 a
</pre></div>

<p></div></div></p>

<p>The arguments to <code>sample()</code> control the number of samples to extract, and whether or not sampling with replacement is done. </p>

<h3>Ordering (integer subsetting)</h3>

<p><code>order()</code> takes a vector as input and returns an integer vector describing how the vector should be subsetted to put it in sorted order: </p>

<div class="chunk" id="unnamed-chunk-80"><div class="rcode"><div class="source"><pre class="knitr r">x <- c(2, 3, 1)
order(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3 1 2
</pre></div>

<div class="source"><pre class="knitr r">x[order(x)]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 2 3
</pre></div>

<p></div></div></p>

<p>To break ties, you can supply additional variables to <code>order()</code>, and you can change from ascending to descending order using <code>decreasing = TRUE</code>.  By default, any missing values will be put at the end of the vector: you can instead remove with <code>na.last = NA</code> or put at the front with <code>na.last = FALSE</code>.</p>

<p>For two and higher dimensions, <code>order()</code> and integer subsetting makes it easy to order either the rows or columns of an object:</p>

<div class="chunk" id="unnamed-chunk-81"><div class="rcode"><div class="source"><pre class="knitr r"># Randomly reorder df
df2 <- df[sample(nrow(df)), 3:1]
df2
</pre></div>

<div class="output"><pre class="knitr r">##   z y x
## 1 a 6 1
## 5 e 2 3
## 6 f 1 3
## 3 c 4 2
## 4 d 3 2
## 2 b 5 1
</pre></div>

<div class="source"><pre class="knitr r">
df2[order(df2$x), ]
</pre></div>

<div class="output"><pre class="knitr r">##   z y x
## 1 a 6 1
## 2 b 5 1
## 3 c 4 2
## 4 d 3 2
## 5 e 2 3
## 6 f 1 3
</pre></div>

<div class="source"><pre class="knitr r">df2[, order(names(df2))]
</pre></div>

<div class="output"><pre class="knitr r">##   x y z
## 1 1 6 a
## 5 3 2 e
## 6 3 1 f
## 3 2 4 c
## 4 2 3 d
## 2 1 5 b
</pre></div>

<p></div></div></p>

<p>More concise, but less flexible, functions are available for sorting vectors, <code>sort()</code>, and data frames, <code>plyr::arrange()</code>.</p>

<h3>Expanding aggregated counts (integer subsetting)</h3>

<p>Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. <code>rep()</code> and integer subsetting makes it easy to uncollapse the data by subsetting with a repeated row index:</p>

<div class="chunk" id="unnamed-chunk-82"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))
rep(1:nrow(df), df$n)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 1 1 2 2 2 2 2 3
</pre></div>

<div class="source"><pre class="knitr r">df[rep(1:nrow(df), df$n), ]
</pre></div>

<div class="output"><pre class="knitr r">##     x  y n
## 1   2  9 3
## 1.1 2  9 3
## 1.2 2  9 3
## 2   4 11 5
## 2.1 4 11 5
## 2.2 4 11 5
## 2.3 4 11 5
## 2.4 4 11 5
## 3   1  6 1
</pre></div>

<p></div></div></p>

<h3>Removing columns from data frame (character subsetting)</h3>

<p>There are two ways to remove columns from a data frame. You can set individual columns to NULL:</p>

<div class="chunk" id="unnamed-chunk-83"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df$z <- NULL
</pre></div>

<p></div></div></p>

<p>Or you can subset to return only the columns you want:</p>

<div class="chunk" id="unnamed-chunk-84"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[c("x", "y")]
</pre></div>

<div class="output"><pre class="knitr r">##   x y
## 1 1 3
## 2 2 2
## 3 3 1
</pre></div>

<p></div></div></p>

<p>If you know the columns you don&#39;t want, use set operations to work out which colums to keep:</p>

<div class="chunk" id="unnamed-chunk-85"><div class="rcode"><div class="source"><pre class="knitr r">df[setdiff(names(df), "z")]
</pre></div>

<div class="output"><pre class="knitr r">##   x y
## 1 1 3
## 2 2 2
## 3 3 1
</pre></div>

<p></div></div></p>

<h3>Selecting rows based on a condition (logical subsetting)</h3>

<p>Logical subsetting is probably the mostly commonly used technique for extracting rows out of a data frame because it allows you to easily combine conditions from multiple columns. </p>

<div class="chunk" id="unnamed-chunk-86"><div class="rcode"><div class="source"><pre class="knitr r">mtcars[mtcars$cyl == 4, ]
</pre></div>

<div class="output"><pre class="knitr r">##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
## Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
## Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
## Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
## Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
</pre></div>

<div class="source"><pre class="knitr r">mtcars[mtcars$cyl == 4 & mtcars$gear == 4, ]
</pre></div>

<div class="output"><pre class="knitr r">##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
## Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
</pre></div>

<p></div></div></p>

<p>Remember to use the vector boolean operators <code>&amp;</code> and <code>|</code>, not the short-circuiting scalar operators <code>&amp;&amp;</code> and <code>||</code> which are more useful inside if statements. Don&#39;t forget <a href="http://en.wikipedia.org/wiki/De_Morgan&#x27;s_laws">De Morgan&#39;s laws</a>, which can be useful to simplify negations:</p>

<ul>
<li><code>!(X &amp; Y)</code> is the same as <code>!X | !Y</code></li>
<li><code>!(X | Y)</code> is the same as <code>!X &amp; !Y</code></li>
</ul>

<p>For example, <code>!(X &amp; !(Y | Z))</code> simplifies to <code>!X | !!(Y|Z)</code>, and then to <code>!X | Y | Z</code>.</p>

<p><code>subset()</code> is a specialised shorthand function for subsetting data frames, and saves some typing because you don&#39;t need to repeat the name of the data frame. You&#39;ll learn how it works in [[Computing on the language]].</p>

<div class="chunk" id="unnamed-chunk-87"><div class="rcode"><div class="source"><pre class="knitr r">subset(mtcars, cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
## Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
## Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
## Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
## Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
</pre></div>

<div class="source"><pre class="knitr r">subset(mtcars, cyl == 4 & gear == 4)
</pre></div>

<div class="output"><pre class="knitr r">##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
## Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
</pre></div>

<p></div></div></p>

<h3>Boolean algebra vs sets (logical &amp; integer subsetting)</h3>

<p>It&#39;s useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:</p>

<ul>
<li><p>You want to find the first (or last) <code>TRUE</code></p></li>
<li><p>You have very few <code>TRUE</code>s and very many <code>FALSE</code>s; a set representation may be faster and require less storage</p></li>
</ul>

<p><code>which()</code> allows you to convert from a boolean representation to a integer representation. There&#39;s no reverse operation in base R, but we can easily add one:</p>

<div class="chunk" id="unnamed-chunk-88"><div class="rcode"><div class="source"><pre class="knitr r">x <- sample(10) < 4
which(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  2  4 10
</pre></div>

<div class="source"><pre class="knitr r">
unwhich <- function(x, n) {
  out <- rep_len(FALSE, n)
  out[x] <- TRUE
  out
}
unwhich(which(x), 10)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE
</pre></div>

<p></div></div></p>

<p>Let&#39;s create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.</p>

<div class="chunk" id="unnamed-chunk-89"><div class="rcode"><div class="source"><pre class="knitr r">(x1 <- 1:10 %% 2 == 0)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
</pre></div>

<div class="source"><pre class="knitr r">(x2 <- which(x1))
</pre></div>

<div class="output"><pre class="knitr r">## [1]  2  4  6  8 10
</pre></div>

<div class="source"><pre class="knitr r">(y1 <- 1:10 %% 5 == 0)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
</pre></div>

<div class="source"><pre class="knitr r">(y2 <- which(y1))
</pre></div>

<div class="output"><pre class="knitr r">## [1]  5 10
</pre></div>

<div class="source"><pre class="knitr r">
# & <-> intersect
x1 & y1
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
</pre></div>

<div class="source"><pre class="knitr r">intersect(x2, y2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<div class="source"><pre class="knitr r">
# | <-> union
x1 | y1
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE
</pre></div>

<div class="source"><pre class="knitr r">union(x2, y2)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  2  4  6  8 10  5
</pre></div>

<div class="source"><pre class="knitr r">
# X & !Y <-> setdiff(x, y)
x1 & !y1
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE
</pre></div>

<div class="source"><pre class="knitr r">setdiff(x2, y2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 4 6 8
</pre></div>

<div class="source"><pre class="knitr r">
# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))
xor(x1, y1)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE
</pre></div>

<div class="source"><pre class="knitr r">setdiff(union(x2, y2), intersect(x2, y2))    
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 4 6 8 5
</pre></div>

<p></div></div></p>

<p>When first learning subsetting, a common mistake is to use <code>x[which(y)]</code> instead of <code>x[y]</code>.  Here the <code>which()</code> achieves nothing: it switches from logical to integer subsetting, but the result will be exactly the same. Also beware that <code>x[-which(y)]</code> is <strong>not</strong> equivalent to <code>x[!y]</code>: if <code>y</code> is all FALSE, <code>which(y)</code> will be <code>integer(0)</code> and <code>-integer(0)</code> is still <code>integer(0)</code>, so you&#39;ll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want (e.g.) the first or last <code>TRUE</code> value.</p>

<h3>Examples</h3>

<ul>
<li><p>How would you take a random sample from the columns of a data frame? (This is an important technique in random forests). Can you simultaneously sample the rows and columns in one step?</p></li>
<li><p>How would you select a random contiguous sample of m rows from a data frame containing n rows?</p></li>
</ul>

<h1>Vocabulary</h1>

<p>An important part of being a competent R programmer is having a good working vocabulary. Below, I have listed the functions that I believe consistute such a vocabulary. I don&#39;t expect you to be intimately familiar with the details of every function, but you should at least be aware that they all exist. </p>

<p>I came up with this list by looking through all functions in <code>base</code>, <code>stats</code>, and <code>utils</code>, and extracting those that I think are most useful. The list also includes a few pointers to particularly important functions in other packages, and some of the more important options.</p>

<h2>The basics</h2>

<pre><code class="R"># The first functions to learn
?
str

# Important operators and assignment
%in%, match
=, &lt;-, &lt;&lt;-
$, [, [[, head, tail, subset
with
assign, get

# Comparison 
all.equal, identical
!=, ==, &gt;, &gt;=, &lt;, &lt;=
is.na, complete.cases
is.finite

# Basic math
*, +, -, /, ^, %%, %/%
abs, sign
acos, asin, atan, atan2
sin, cos, tan
ceiling, floor, round, trunc, signif
exp, log, log10, log2, sqrt

max, min, prod, sum
cummax, cummin, cumprod, cumsum, diff
pmax, pmin
range
mean, median, cor, sd, var
rle

# Functions
function
missing
on.exit
return, invisible

# Logical &amp; sets 
&amp;, |, !, xor
all, any
intersect, union, setdiff, setequal
which

# Vectors and matrices
c, matrix
# automatic coercion rules character &gt; numeric &gt; logical
length, dim, ncol, nrow
cbind, rbind
names, colnames, rownames
t
diag
sweep
as.matrix, data.matrix

# Making vectors 
c
rep, rep_len
seq, seq_len, seq_along
rev
sample
choose, factorial, combn
(is/as).(character/numeric/logical/...)

# Lists &amp; data.frames 
list, unlist
data.frame, as.data.frame
split
expand.grid

# Control flow 
if, &amp;&amp;, || (short circuiting)
for, while
next, break
switch
ifelse
</code></pre>

<h2>Common data structures</h2>

<pre><code class="R"># Date time
ISOdate, ISOdatetime, strftime, strptime, date
difftime
julian, months, quarters, weekdays
library(lubridate)

# Character manipulation 
grep, agrep
gsub
strsplit
chartr
nchar
tolower, toupper
substr
paste
library(stringr)

# Factors 
factor, levels, nlevels
reorder, relevel
cut, findInterval
interaction
options(stringsAsFactors = FALSE)

# Array manipulation
array
dim
dimnames
aperm
library(abind)
</code></pre>

<h2>Statistics</h2>

<pre><code class="R"># Ordering and tabulating 
duplicated, unique
merge
order, rank, quantile
sort
table, ftable

# Linear models 
fitted, predict, resid, rstandard
lm, glm
hat, influence.measures
logLik, df, deviance
formula, ~, I
anova, coef, confint, vcov
contrasts

# Miscellaneous tests
apropos(&quot;\\\.test$&quot;)

# Random variables 
(q, t, d, r) * (beta, binom, cauchy, chisq, exp, f, gamma, geom, 
  hyper, lnorm, logis, multinom, nbinom, norm, pois, signrank, t, 
  unif, weibull, wilcox, birthday, tukey)

# Matrix algebra 
crossprod, tcrossprod
eigen, qr, svd
%*%, %o%, outer
rcond
solve
</code></pre>

<h2>Working with R</h2>

<pre><code class="R"># Workspace 
ls, exists, rm
getwd, setwd
q
source
install.packages, library, require

# Help
help, ?
help.search
apropos
RSiteSearch
citation
demo
example
vignette

# Debugging
traceback
browser
recover
options(error = )
stop, warning, message
tryCatch, try
</code></pre>

<h2>I/O</h2>

<pre><code class="R"># Output
print, cat
message, warning
dput
format
sink, capture.output

# Reading and writing data
data
count.fields
read.csv, write.csv,
read.delim, write.delim
read.fwf
readLines, writeLines
readRDS, saveRDS
load, save
library(foreign)

# Files and directories 
dir
basename, dirname, tools::file_ext
file.path
path.expand, normalizePath
file.choose
file.copy, file.create, file.remove, file.rename, dir.create
file.exists, file.info
tempdir, tempfile
download.file, library(downloader)
</code></pre>

<h1>Functions</h1>

<p>Functions are a fundamental building block of R: to master many of the more advanced techniques in this book, you need a solid foundation in how functions work. You&#39;ve probably already created many R functions, and you&#39;re familiar with the basics of how they work. The focus of this chapter is to turn your existing, informal, knowledge of functions into a rigorous understanding of what functions are and how they work. You&#39;ll see some interesting tricks and techniques in this chapter, but most of what you&#39;ll learn will be more important as the building blocks for more advanced techniques.</p>

<p>The most important thing to understand about R is that functions are objects in their own right. You can work with them exactly the same way you work with any other type of object. </p>

<p>In this chapter you will learn:</p>

<ul>
<li><p>The three main components of a function.</p></li>
<li><p>How scoping works, the process that looks up values from names.</p></li>
<li><p>How everything that happens in R is a result of a function call,  even if it doesn&#39;t look like it</p></li>
<li><p>The three ways of supplying arguments to a function, how to call a function given a list of arguments, and the impact of lazy evaluation.</p></li>
<li><p>About two types of special functions: infix and replacement functions.</p></li>
<li><p>What a function can return, and how invisible return values work</p></li>
</ul>

<h2>Components of a function</h2>

<p>There are three properties that all R functions possess:</p>

<ul>
<li><p>the <code>body()</code>, the code inside the function.</p></li>
<li><p>the <code>formals()</code>, the &quot;formal&quot; argument list, which controls how you can call the function.</p></li>
<li><p>the <code>environment()</code> which determines how variables referred to inside the function are found.</p></li>
</ul>

<p>When you print a function in R, it shows you these three important components. If the environment isn&#39;t displayed, it means that the function was created in the global environment. </p>

<div class="chunk" id="unnamed-chunk-90"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) x
f
</pre></div>

<div class="output"><pre class="knitr r">## function(x) x
</pre></div>

<div class="source"><pre class="knitr r">
formals(f)
</pre></div>

<div class="output"><pre class="knitr r">## $x
</pre></div>

<div class="source"><pre class="knitr r">body(f)
</pre></div>

<div class="output"><pre class="knitr r">## x
</pre></div>

<div class="source"><pre class="knitr r">environment(f)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<p></div></div></p>

<p>The assignment forms of <code>body()</code>, <code>formals()</code>, and <code>environment()</code> can also be used to modify functions. This is a useful technique which we&#39;ll explore in more detail in [[computing on the language]].</p>

<p>Like all other objects in R, functions can also possess any number of additional <code>attributes()</code>. One attribute used by base R is &quot;srcref&quot;, short for source reference, which points to the source code used to create the function. Unlike the <code>body()</code>, this contains codes comments and other formatting. You can also add your attributes to a function, for example, you can can set the <code>class()</code> and add a custom <code>print()</code> method.</p>

<h3>Primitive functions</h3>

<p>There is one exception to the rule that functions have three components. Primitive functions, like <code>sum</code>, call C code directly with <code>.Primitive()</code> and contain no R code. Therefore their <code>formals()</code>, <code>body()</code> and <code>environment()</code> are all <code>NULL</code>:</p>

<div class="chunk" id="unnamed-chunk-91"><div class="rcode"><div class="source"><pre class="knitr r">sum
</pre></div>

<div class="output"><pre class="knitr r">## function (..., na.rm = FALSE)  .Primitive("sum")
</pre></div>

<div class="source"><pre class="knitr r">formals(sum)
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<div class="source"><pre class="knitr r">body(sum)
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<div class="source"><pre class="knitr r">environment(sum)
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<p></div></div></p>

<p>Primitive functions are only found in the <code>base</code> package, and since they operate at a low level, they can be more efficient (primitive replacement functions don&#39;t have to make copies), and can have different rules for argument matching (e.g. <code>switch</code> and <code>call</code>).  This, however, comes at a cost of behaving differently to all other function in R, and so R core generally avoids creating them unless there is no other option.</p>

<h3>Exercises</h3>

<ul>
<li><p>What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function or not?</p></li>
<li><p>Create a list of all primitive functions in R. (Hint: use <code>ls(&quot;package:base&quot;, all = TRUE)</code> to get a list of all objects in the base package, <code>get()</code> to retrieve an object given its name, and the answer to the question above.)</p></li>
<li><p>What are the three important components of a function?</p></li>
<li><p>When does printing a function not show what environment it was created in?</p></li>
</ul>

<h2>Lexical scoping</h2>

<p>Scoping is the set of rules that govern how R looks up the value of a symbol. In other words, scoping is the set of rules that R applies to go from the symbol <code>x</code>, to its value <code>10</code> in this example:</p>

<div class="chunk" id="unnamed-chunk-92"><div class="rcode"><div class="source"><pre class="knitr r">x <- 10
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<p></div></div></p>

<p>Understanding scoping allows you to:</p>

<ul>
<li>build tools by composing functions, as described in [[functional programming]]</li>
<li>overrule the usual evaluation rules and [[compute on the language|computing-on-the-language]]</li>
</ul>

<p>R has two types of scoping: <strong>lexical scoping</strong>, implemented automatically at the language level, and <strong>dynamic scoping</strong>, used in select functions to save typing during interactive analysis. We describe lexical scoping here because it is intimately tied to function creation. Dynamic scoping is described in the context of [[computing on the language]].</p>

<p>Lexical scoping looks up symbol values based on how functions were nested when they were created, not how they are nested when they are called. With lexical scoping, you can figure out where the value of each variable will be looked up only by looking at the definition of the function, you don&#39;t need to know anything about how the function is called.</p>

<p>The &quot;lexical&quot; in lexical scoping doesn&#39;t correspond to the usual English definition (&quot;of or relating to words or the vocabulary of a language as distinguished from its grammar and construction&quot;) but comes from the computer science term &quot;lexing&quot;, which is part of the process that converts code represented as text to meaningful pieces that the programming language understands. It&#39;s lexical scoping is lexical in this sense because you only need the definition of the functions, not how they are called.</p>

<p>There are four basic principles behind R&#39;s implementation of lexical scoping:</p>

<ul>
<li>name masking</li>
<li>functions vs. variables</li>
<li>a fresh start</li>
<li>dynamic lookup</li>
</ul>

<p>You probably know many of these principles already, although you might not have thought about them explicitly. Test your knowledge by mentally running the code in each block before looking at the answers.</p>

<h3>Name masking</h3>

<p>The following example illustrates the simplest principle, and you should have no problem predicting the output.</p>

<div class="chunk" id="unnamed-chunk-93"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() { 
  x <- 1
  y <- 2
  c(x, y)
}
f()
rm(f)
</pre></div>

<p></div></div></p>

<p>If a name isn&#39;t defined inside a function, R will look one level up.</p>

<div class="chunk" id="unnamed-chunk-94"><div class="rcode"><div class="source"><pre class="knitr r">x <- 2
g <- function() { 
  y <- 1
  c(x, y)
}
g()
rm(x, g)
</pre></div>

<p></div></div></p>

<p>The same rules apply if a function is defined inside another function.  First it looks inside the current function, then where that function was defined, and so on, all the way up to the global environment, and then on to other loaded packages. Run the following code in your head, then confirm the output by running the R code.</p>

<div class="chunk" id="unnamed-chunk-95"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1
h <- function() { 
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
h()
rm(x, h)
</pre></div>

<p></div></div></p>

<p>The same rules apply to closures, functions created by other functions. Closures will be described in more detail in [[functional programming]]; here we&#39;ll just look at how they interact with scoping. The following function, <code>j()</code>, returns a function.  What do you think this function will return when we call it?</p>

<div class="chunk" id="unnamed-chunk-96"><div class="rcode"><div class="source"><pre class="knitr r">j <- function(x) {
  y <- 2
  function() {
    c(x, y)
  }
}
k <- j(1)
k()
rm(j, k)
</pre></div>

<p></div></div></p>

<p>This seems a little magical (how does R know what the value of <code>y</code> is after the function has been called), but it works because <code>k</code> keeps around the environment in which it was defined, which includes the value of <code>y</code>. [[Environments]] gives some pointers on how you can dive in and figure out what values are stored in the environment associated with each function.</p>

<h3>Functions vs. variables</h3>

<p>The same principles apply regardless of type of the associated value - finding functions works exactly the same way as finding variables:</p>

<div class="chunk" id="unnamed-chunk-97"><div class="rcode"><div class="source"><pre class="knitr r">l <- function(x) x + 1
m <- function() {
  l <- function(x) x * 2
  l(10)
}
m()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 20
</pre></div>

<div class="source"><pre class="knitr r">rm(l, m)
</pre></div>

<p></div></div></p>

<p>There is one small tweak to the rule for functions. If you are using a name in a context where it&#39;s obvious that you want a function (e.g. <code>f(3)</code>), R will ignore objects that are not functions while it is searching. In the following example <code>n</code> takes on a different value depending on whether R is looking for a function or a variable.</p>

<div class="chunk" id="unnamed-chunk-98"><div class="rcode"><div class="source"><pre class="knitr r">n <- function(x) x / 2
o <- function() {
  n <- 10
  n(n)
}
o()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5
</pre></div>

<div class="source"><pre class="knitr r">rm(n, o)
</pre></div>

<p></div></div></p>

<p>However, using the same name for functions and other objects will make for confusing code, and is generally best avoided.</p>

<h3>A fresh start</h3>

<p>What happens to the values in between invocations of a function? What will happen the first time you run this function? What will happen the second time? (If you haven&#39;t seen <code>exists</code> before: it returns <code>TRUE</code> if there&#39;s a variable of that name, otherwise it returns <code>FALSE</code>)</p>

<div class="chunk" id="unnamed-chunk-99"><div class="rcode"><div class="source"><pre class="knitr r">j <- function() {
  if (!exists("a")) {  
    a <- 1
  } else {
    a <- a + 1
  }
  print(a)
}
j()
rm(j)
</pre></div>

<p></div></div></p>

<p>You might be surprised that it returns the same value, <code>1</code>, every time. This is because every time a function is called, a new environment is created to host execution. A function has no way to tell what happened the last time it was run; each invocation is completely independent. (We&#39;ll see some ways to get around this in [[functional programming]])</p>

<h3>Dynamic lookup</h3>

<p>Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it&#39;s created. This means that the output of a function can be different depending on objects outside its environment:</p>

<div class="chunk" id="unnamed-chunk-100"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() x
x <- 15
f()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 15
</pre></div>

<div class="source"><pre class="knitr r">
x <- 20
f()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 20
</pre></div>

<p></div></div></p>

<p>You generally want to avoid this behavour because it means the function is no longer self-contained. This is a common error - if you make a spelling mistake in your code, you won&#39;t get an error when you create the function, and you might not even get one when you run the function, depending on what variables are defined in the global environment. </p>

<p>One way to detect this problem is the <code>findGlobals()</code> function from <code>codetools</code>. This function lists all the external dependencies of a function:</p>

<div class="chunk" id="unnamed-chunk-101"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() x + 1
codetools::findGlobals(f)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "+" "x"
</pre></div>

<p></div></div></p>

<p>Another way to try and solve the problem would be to manually change the environment of the function to the <code>emptyenv()</code>, an environment which contains absolutely nothing:</p>

<div class="chunk" id="unnamed-chunk-102"><div class="rcode"><div class="source"><pre class="knitr r">environment(f) <- emptyenv()
f()
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "+"
</pre></div>

<p></div></div></p>

<p>This doesn&#39;t work because R relies on lexical scoping to find <em>everything</em>, even the <code>+</code> operator. It&#39;s never possible to make a function completely self-contained because you must always rely on functions defined in base R or other packages.</p>

<p>You can use this same idea to do other things that are extremely ill-advised. For example, since all of the standard operators in R are functions, you can override them with your own alternatives.  If you ever are feeling particularly evil, run the following code while your friend is away from their computer:</p>

<div class="chunk" id="unnamed-chunk-103"><div class="rcode"><div class="source"><pre class="knitr r">"(" <- function(e1) {
  if (is.numeric(e1) && runif(1) < 0.1) {
    e1 + 1
  } else {
    e1
  }
}
replicate(100, (1 + 2))
</pre></div>

<div class="output"><pre class="knitr r">##   [1] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3
##  [36] 3 3 3 3 3 3 4 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3
##  [71] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 4 3 3 3 3 3 3
</pre></div>

<div class="source"><pre class="knitr r">rm("(")
</pre></div>

<p></div></div></p>

<p>This will introduce a particularly pernicious bug: 10% of the time, 1 will be added to any numeric calculation inside parentheses. This is another good reason to regularly restart with a clean R session!</p>

<h3>Exercises</h3>

<ul>
<li>What does the following code return? Why? What does each of the three <code>c</code>&#39;s mean?</li>
</ul>

<div class="chunk" id="unnamed-chunk-104"><div class="rcode"><div class="source"><pre class="knitr r">c <- 10
c(c = c)
</pre></div>

<p></div></div></p>

<ul>
<li><p>What are the four principles that govern how R looks for values?</p></li>
<li><p>What does the following function return? Make a prediction before running the code yourself.</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-105"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  f <- function(x) {
    f <- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) * 2
}
f(10)
</pre></div>

<p></div></div></p>

<h2>Every operation is a function call</h2>

<blockquote>
<p>To understand computations in R, two slogans are helpful: </p>

<ul>
<li>Everything that exists is an object.</li>
<li>Everything that happens is a function call.</li>
</ul>

<p>--- John Chambers</p>
</blockquote>

<p>The previous example of redefining <code>(</code> works because every operation in R is a function call, whether or not it looks like it. This includes infix operators like <code>+</code>, control flow operators like <code>for</code>, <code>if</code>, and <code>while</code>, subsetting operators like <code>[]</code> and <code>$</code> and even the curly braces <code>{</code>. This means that each of pairs of statements in the following example are exactly equivalent.  Note that <code>`</code>, the backtick, lets you refer to functions or variables that have otherwise reserved or illegal names:</p>

<div class="chunk" id="unnamed-chunk-106"><div class="rcode"><div class="source"><pre class="knitr r">x <- 10; y <- 5
x + y
</pre></div>

<div class="output"><pre class="knitr r">## [1] 15
</pre></div>

<div class="source"><pre class="knitr r">`+`(x, y)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 15
</pre></div>

<div class="source"><pre class="knitr r">
for (i in 1:2) print(i)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">`for`(i, 1:2, print(i))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">
if (i == 1) print("yes!") else print("no.")
</pre></div>

<div class="output"><pre class="knitr r">## [1] "no."
</pre></div>

<div class="source"><pre class="knitr r">`if`(i == 1, print("yes"), print("no."))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "no."
</pre></div>

<div class="source"><pre class="knitr r">
x[3]
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<div class="source"><pre class="knitr r">`[`(x, 3)
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<div class="source"><pre class="knitr r">
{ print(1); print(2); print(3) }
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
## [1] 2
## [1] 3
</pre></div>

<div class="source"><pre class="knitr r">`{`(print(1), print(2), print(3))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
## [1] 2
## [1] 3
</pre></div>

<p></div></div></p>

<p>It is possible to override the definitions of these special functions, but this is almost certainly a bad idea. However, it can occasionally allow you to do something that would have otherwise been impossible. For example, this feature makes it possible for the <code>dplyr</code> package to translate R expressions into SQL expressions. The [[dsl]] chapter discusses using this idea to create domain specific languages that allow you to concisely express new concepts using existing R constructs.</p>

<p>It&#39;s more often useful to treat special functions as ordinary functions. For example, we could use <code>sapply</code> to add 3 to every element of a list by first defining a function <code>add</code>, like this:</p>

<div class="chunk" id="unnamed-chunk-107"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(x, y) x + y
sapply(1:10, add, 3)
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  4  5  6  7  8  9 10 11 12 13
</pre></div>

<p></div></div></p>

<p>But we can get the same effect using the built-in <code>+</code> function.</p>

<div class="chunk" id="unnamed-chunk-108"><div class="rcode"><div class="source"><pre class="knitr r">sapply(1:5, `+`, 3)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4 5 6 7 8
</pre></div>

<div class="source"><pre class="knitr r">sapply(1:5, "+", 3)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4 5 6 7 8
</pre></div>

<p></div></div></p>

<p>Note the difference between <code>`+`</code> and <code>&quot;+&quot;</code>.  The first one is the value of the object called <code>+</code>, and the second is a string containing the character <code>+</code>.  The second version works because <code>lapply</code> can be given the name of a function instead of the function itself: if you read the source of <code>lapply()</code>, you&#39;ll see the first line uses <code>match.fun()</code> to find functions given their names.</p>

<p>A more useful application is combining <code>lapply()</code> or <code>sapply()</code> with subsetting:</p>

<div class="chunk" id="unnamed-chunk-109"><div class="rcode"><div class="source"><pre class="knitr r">x <- list(1:3, 4:9, 10:12)
sapply(x, "[", 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  2  5 11
</pre></div>

<div class="source"><pre class="knitr r">
# equivalent to
sapply(x, function(x) x[2])
</pre></div>

<div class="output"><pre class="knitr r">## [1]  2  5 11
</pre></div>

<p></div></div></p>

<p>That everything in R is represented as a function call is important to know for [[computing on the language]].</p>

<h2>Function arguments</h2>

<p>It&#39;s useful to distinguish between the formal arguments and the actual arguments to a function. The formal arguments are a property of the function, whereas the actual or calling arguments vary each time you call the function. This section discusses how calling arguments are mapped to formal arguments, how you can call a function given a list of arguments, how default arguments work and the impact of lazy evaluation.</p>

<h3>Calling functions</h3>

<p>When calling a function you can specify arguments by position, by complete name, or by partial name. Arguments are matched first by exact name (perfect matching), then by prefix matching and finally by position.</p>

<div class="chunk" id="unnamed-chunk-110"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(abcdef, bcde1, bcde2) {
  list(a = abcdef, b1 = bcde1, b2 = bcde2)
}
str(f(1, 2, 3))
</pre></div>

<div class="output"><pre class="knitr r">## List of 3
##  $ a : num 1
##  $ b1: num 2
##  $ b2: num 3
</pre></div>

<div class="source"><pre class="knitr r">str(f(2, 3, abcdef = 1))
</pre></div>

<div class="output"><pre class="knitr r">## List of 3
##  $ a : num 1
##  $ b1: num 2
##  $ b2: num 3
</pre></div>

<div class="source"><pre class="knitr r">
# Can abbreviate long argument names:
str(f(2, 3, a = 1))
</pre></div>

<div class="output"><pre class="knitr r">## List of 3
##  $ a : num 1
##  $ b1: num 2
##  $ b2: num 3
</pre></div>

<div class="source"><pre class="knitr r">
# But this doesn't work because abbreviation is ambiguous
str(f(1, 3, b = 1))
</pre></div>

<div class="error"><pre class="knitr r">## Error: argument 3 matches multiple formal arguments
</pre></div>

<p></div></div></p>

<p>Generally, you only want to use positional matching for the first one or two arguments: they will be the mostly commonly used, and most readers will know what they are. Avoid using positional matching for less commonly used arguments, and only use readable abbreviations with partial matching. (If you are writing code for a package that you want to publish on CRAN you can not use partial matching, and must use complete names.) Named arguments should always come after unnamed arguments. If a function uses <code>...</code> (discussed in more detail below), you can only specify arguments listed after <code>...</code> with their full name.</p>

<p>These are good calls:</p>

<div class="chunk" id="unnamed-chunk-111"><div class="rcode"><div class="source"><pre class="knitr r">mean(1:10)
mean(1:10, trim = 0.05)
</pre></div>

<p></div></div></p>

<p>This is probably overkill:</p>

<div class="chunk" id="unnamed-chunk-112"><div class="rcode"><div class="source"><pre class="knitr r">mean(x = 1:10)
</pre></div>

<p></div></div></p>

<p>And these are just confusing:</p>

<div class="chunk" id="unnamed-chunk-113"><div class="rcode"><div class="source"><pre class="knitr r">mean(1:10, n = T)
mean(1:10, , FALSE)
mean(1:10, 0.05)
mean(, TRUE, x = c(1:10, NA))
</pre></div>

<p></div></div></p>

<h3>Calling a function given a list of arguments</h3>

<p>Suppose you had a list of function arguments:</p>

<div class="chunk" id="unnamed-chunk-114"><div class="rcode"><div class="source"><pre class="knitr r">args <- list(1:10, na.rm = TRUE)
</pre></div>

<p></div></div></p>

<p>How could you then send that list to <code>mean()</code>?  You need <code>do.call()</code>:</p>

<div class="chunk" id="unnamed-chunk-115"><div class="rcode"><div class="source"><pre class="knitr r">do.call(mean, list(1:10, na.rm = TRUE))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5.5
</pre></div>

<div class="source"><pre class="knitr r"># Equivalent to 
mean(1:10, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5.5
</pre></div>

<p></div></div></p>

<h3>Default and missing arguments</h3>

<p>Function arguments in R can have default values. </p>

<div class="chunk" id="unnamed-chunk-116"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(a = 1, b = 2) {
  c(a, b)
}
f()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 2
</pre></div>

<p></div></div></p>

<p>Since arguments in R are evaluated lazily (more on that below), the default value can be defined in terms of other arguments:</p>

<div class="chunk" id="unnamed-chunk-117"><div class="rcode"><div class="source"><pre class="knitr r">g <- function(a = 1, b = a * 2) {
  c(a, b)
}
g()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 2
</pre></div>

<div class="source"><pre class="knitr r">g(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10 20
</pre></div>

<p></div></div></p>

<p>Default arguments can even be defined in terms of variables created within the function. This is used frequently in base R functions, but I think it is bad practice, because you can&#39;t understand what the default values will be without reading the complete source code.</p>

<div class="chunk" id="unnamed-chunk-118"><div class="rcode"><div class="source"><pre class="knitr r">h <- function(a = 1, b = d) {
  d <- (a + 1) ^ 2
  c(a, b)
}
h()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1 4
</pre></div>

<div class="source"><pre class="knitr r">h(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  10 121
</pre></div>

<p></div></div></p>

<p>You can detect if an argument was supplied or not with the <code>missing()</code> function.</p>

<div class="chunk" id="unnamed-chunk-119"><div class="rcode"><div class="source"><pre class="knitr r">i <- function(a, b) {
  c(missing(a), missing(b))
}
i()
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE TRUE
</pre></div>

<div class="source"><pre class="knitr r">i(a = 1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE  TRUE
</pre></div>

<div class="source"><pre class="knitr r">i(b = 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  TRUE FALSE
</pre></div>

<div class="source"><pre class="knitr r">i(1, 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE FALSE
</pre></div>

<p></div></div></p>

<p>However, I generally recommend against using <code>missing</code> because it makes it difficult to call programmatically from other functions. Generally, it&#39;s better to set a default value of <code>NULL</code> and then check with <code>is.null()</code>.</p>

<div class="chunk" id="unnamed-chunk-120"><div class="rcode"><div class="source"><pre class="knitr r">j <- function(a = NULL, b = NULL) {
  c(is.null(a), is.null(b))
}
j()
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE TRUE
</pre></div>

<div class="source"><pre class="knitr r">j(a = 1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE  TRUE
</pre></div>

<div class="source"><pre class="knitr r">j(b = 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  TRUE FALSE
</pre></div>

<div class="source"><pre class="knitr r">j(1, 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE FALSE
</pre></div>

<p></div></div></p>

<h3>Lazy evaluation</h3>

<p>By default, R function arguments are lazy - they&#39;re only evaluated if they&#39;re actually used:</p>

<div class="chunk" id="unnamed-chunk-121"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  10
}
system.time(f(Sys.sleep(10)))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0       0
</pre></div>

<p></div></div></p>

<p>If you want to ensure that an argument is evaluated you can use <code>force</code>: </p>

<div class="chunk" id="unnamed-chunk-122"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  force(x)
  10
}
system.time(f(Sys.sleep(10)))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0      10
</pre></div>

<p></div></div></p>

<p>This is important when creating closures with <code>lapply</code> or a loop:</p>

<div class="chunk" id="unnamed-chunk-123"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(x) {
  function(y) x + y
}
adders <- lapply(1:10, add)
adders[[1]](10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 20
</pre></div>

<div class="source"><pre class="knitr r">adders[[10]](10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 20
</pre></div>

<p></div></div></p>

<p><code>x</code> is lazily evaluated the first time that you call one of the adder functions. At this point, the loop is complete and the final value of <code>x</code> is 10.  Therefore all of the adder functions will add 10 on to their input, probably not what you wanted!  Manually forcing evaluation fixes the problem:</p>

<div class="chunk" id="unnamed-chunk-124"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(x) {
  force(x)
  function(y) x + y
}
adders2 <- lapply(1:10, add)
adders2[[1]](10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 11
</pre></div>

<div class="source"><pre class="knitr r">adders2[[10]](10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 20
</pre></div>

<p></div></div></p>

<p>This code is exactly equivalent to</p>

<div class="chunk" id="unnamed-chunk-125"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(x) {
  x
  function(y) x + y
}
</pre></div>

<p></div></div></p>

<p>because the force function is just defined as <code>force &lt;- function(x) x</code>. However, using this function indicates clearly that you&#39;re forcing evaluation, not that you&#39;ve accidentally typed <code>x</code>.</p>

<p>Default arguments are evaluated inside the function. This means that if the expression depends on the current environment the results will be different depending on whether you use the default value or explicitly provide it.</p>

<div class="chunk" id="unnamed-chunk-126"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x = ls()) {
  a <- 1
  x
}

# ls() evaluated inside f:
f()
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "x"
</pre></div>

<div class="source"><pre class="knitr r">
# ls() evaluated in global environment:
f(ls())
</pre></div>

<div class="output"><pre class="knitr r">##  [1] "a"          "add"        "adders"     "adders2"    "args"      
##  [6] "b"          "bad"        "c"          "character"  "df"        
## [11] "df2"        "dfl"        "dfm"        "f"          "g"         
## [16] "good"       "grades"     "h"          "i"          "id"        
## [21] "info"       "integer"    "j"          "logical"    "lookup"    
## [26] "mod"        "numeric"    "select"     "sex_char"   "sex_factor"
## [31] "unwhich"    "vals"       "var"        "x"          "x1"        
## [36] "x2"         "y"          "y1"         "y2"         "z"
</pre></div>

<p></div></div></p>

<p>More technically, an unevaluated argument is called a <strong>promise</strong>, or (less commonly) a thunk. A promise is made up of two parts:</p>

<ul>
<li><p>an expression giving the delayed computation, which can be accessed with <code>substitute</code> (see [[controlling evaluation|evaluation]] for more details)</p></li>
<li><p>the environment where the expression was created and where it should be evaluated</p></li>
</ul>

<p>The first time a promise is accessed the expression is evaluated in the environment where it was created. This value is cached, so that subsequently access to the evaluted promise does not recompute the value (but the original expression is still associated with the value, so that <code>substitute</code> can continue to access it). You can find more information about a promise using <code>pryr::promise_info</code>. This uses some C++ code to extract information about the promise without evaluating it, which is impossible to do in pure R code.</p>

<p>Laziness is useful in if statements - the second statement below will be evaluated only if the first is true. If it wasn&#39;t, the statement would return an error because <code>NULL &gt; 0</code> is a logical vector of length 0 and not a valid input to <code>if</code>.</p>

<div class="chunk" id="unnamed-chunk-127"><div class="rcode"><div class="source"><pre class="knitr r">x <- NULL
if (!is.null(x) && x > 0) {

}
</pre></div>

<p></div></div></p>

<p>We could implement &quot;&amp;&amp;&quot; ourselves:</p>

<div class="chunk" id="unnamed-chunk-128"><div class="rcode"><div class="source"><pre class="knitr r">"&&" <- function(x, y) {
  if (!x) return(FALSE)
  if (!y) return(FALSE)

  TRUE
}
a <- NULL
!is.null(a) && a > 0
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<p>This function would not work without lazy evaluation because both <code>x</code> and <code>y</code> would always be evaluated, testing if <code>a &gt; 0</code> even if <code>a</code> was NULL.</p>

<p>Sometimes you can also use laziness to elimate an if statement altogether. For example, instead of:</p>

<div class="chunk" id="unnamed-chunk-129"><div class="rcode"><div class="source"><pre class="knitr r">if (is.null(a)) stop("a is null")
</pre></div>

<div class="error"><pre class="knitr r">## Error: a is null
</pre></div>

<p></div></div></p>

<p>You could write:</p>

<div class="chunk" id="unnamed-chunk-130"><div class="rcode"><div class="source"><pre class="knitr r">!is.null(a) || stop("a is null")
</pre></div>

<div class="error"><pre class="knitr r">## Error: a is null
</pre></div>

<p></div></div></p>

<h3><code>...</code></h3>

<p>There is a special argument called <code>...</code>.  This argument will match any arguments not otherwise matched, and can be easily passed on to other functions.  This is useful if you want to collect arguments to call another function, but you don&#39;t want to prespecify their possible names. <code>...</code> is often used in conjunction with S3 generic functions to allow individual methods to be more flexible.</p>

<p>One relatively sophisticated user of <code>...</code> is the base <code>plot()</code> function. <code>plot()</code> is a generic method with arguments <code>x</code>, <code>y</code> and <code>....</code>. To understand what <code>...</code> does for a given function we need to read the help: &quot;Arguments to be passed to methods, such as graphical parameters&quot;. Most simple invocation of <code>plot()</code> ends up calling <code>plot.default()</code> which has many more arguments, but also has <code>...</code>.  Again, reading the documentation reveals that <code>...</code> accepts &quot;other graphical parameters&quot;, which are listed the help for <code>par()</code>.  This allows us to write code like:</p>

<div class="chunk" id="unnamed-chunk-131"><div class="rcode"><div class="source"><pre class="knitr r">plot(1:5, col = "red")
plot(1:5, cex = 5, pch = 20)
</pre></div>

<p></div></div></p>

<p>This illustrates both the advantages and disadvantages of <code>...</code>: it makes <code>plot()</code> very flexible, but to understand how to use it, we have to carefully read the documentation. Additionally, if we read the source code for <code>plot.default</code>, we can discover undocumented features. It&#39;s possible to pass along other arguments to <code>Axis()</code> and <code>box()</code>:</p>

<div class="chunk" id="unnamed-chunk-132"><div class="rcode"><div class="source"><pre class="knitr r">plot(1:5, bty = "u")
plot(1:5, labels = FALSE)
</pre></div>

<p></div></div></p>

<p>To capture <code>...</code> in a form that is easier to work with, you can use <code>list(...)</code>. (See [[Computing on the language]] for other ways to capture <code>...</code> without evaluating the arguments).</p>

<div class="chunk" id="unnamed-chunk-133"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(...) {
  names(list(...))
}
f(a = 1, b = 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b"
</pre></div>

<p></div></div></p>

<p>Using <code>...</code> comes with a cost - any misspelled arguments will not raise an error, and any arguments after <code>...</code> must be fully named.  This makes it easy for typos to go unnoticed:</p>

<div class="chunk" id="unnamed-chunk-134"><div class="rcode"><div class="source"><pre class="knitr r">sum(1, 2, na.mr = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<p></div></div></p>

<p>It&#39;s often better to be explicit rather than implicit, so you might instead ask users to supply a list of additional arguments.  That&#39;s certainly easier if you&#39;re trying to use <code>...</code> with multiple additional functions.</p>

<h3>Exercises</h3>

<ul>
<li>Clarify the following list of odd function calls:</li>
</ul>

<div class="chunk" id="unnamed-chunk-135"><div class="rcode"><div class="source"><pre class="knitr r">x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
</pre></div>

<p></div></div></p>

<h2>Special calls</h2>

<p>R supports two additional syntaxes for calling special types of functions: infix and replacement functions.</p>

<h3>Infix functions</h3>

<p>Most functions in R are &quot;prefix&quot; operators: the name of the function comes before the arguments. You can also create infix functions where the function name comes in between its arguments, like <code>+</code> or <code>-</code>.  All user created infix functions names must start and end with <code>%</code> and R comes with the following infix functions predefined: <code>%%</code>, <code>%*%</code>, <code>%/%</code>, <code>%in%</code>, <code>%o%</code>,  <code>%x%</code>. (The complete list of built-in infix operators that don&#39;t need <code>%</code> is: <code>::, $, @, ^, *, /, +, -, &gt;, &gt;=, &lt;, &lt;=, ==, !=, !, &amp;, &amp;&amp;, |, ||, ~, &lt;-, &lt;&lt;-</code>)</p>

<p>For example, we could create a new operator that pastes together strings:</p>

<div class="chunk" id="unnamed-chunk-136"><div class="rcode"><div class="source"><pre class="knitr r">"%+%" <- function(a, b) paste(a, b, sep = "")
"new" %+% " string"
</pre></div>

<div class="output"><pre class="knitr r">## [1] "new string"
</pre></div>

<p></div></div></p>

<p>Note that when creating the function, you have to put the name in quotes because it&#39;s a special name. This is just a syntactic sugar for an ordinary function call; as far as R is concerned there is no difference between these two expressions:</p>

<div class="chunk" id="unnamed-chunk-137"><div class="rcode"><div class="source"><pre class="knitr r">"new" %+% " string"
</pre></div>

<div class="output"><pre class="knitr r">## [1] "new string"
</pre></div>

<div class="source"><pre class="knitr r">`%+%`("new", " string")
</pre></div>

<div class="output"><pre class="knitr r">## [1] "new string"
</pre></div>

<p></div></div></p>

<p>Or indeed between</p>

<div class="chunk" id="unnamed-chunk-138"><div class="rcode"><div class="source"><pre class="knitr r">1 + 5
</pre></div>

<div class="output"><pre class="knitr r">## [1] 6
</pre></div>

<div class="source"><pre class="knitr r">`+`(1, 5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 6
</pre></div>

<p></div></div></p>

<p>The names of infix functions are more flexible than regular R functions: they can contain any sequence of characters (except &quot;%&quot;, of course). You will need to escape any special characters in the string used to define the function, but not when you call it:</p>

<div class="chunk" id="unnamed-chunk-139"><div class="rcode"><div class="source"><pre class="knitr r">"% %" <- function(a, b) paste(a, b)
"%'%" <- function(a, b) paste(a, b)
"%/\\%" <- function(a, b) paste(a, b)

"a" % % "b"
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a b"
</pre></div>

<div class="source"><pre class="knitr r">"a" %'% "b"
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a b"
</pre></div>

<div class="source"><pre class="knitr r">"a" %/\% "b"
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a b"
</pre></div>

<p></div></div></p>

<p>R&#39;s default precedence rules mean that infix operators are composed from left to right:</p>

<div class="chunk" id="unnamed-chunk-140"><div class="rcode"><div class="source"><pre class="knitr r">"%-%" <- function(a, b) paste0("(", a, " %-% ", b, ")")
"a" %-% "b" %-% "c"
</pre></div>

<div class="output"><pre class="knitr r">## [1] "((a %-% b) %-% c)"
</pre></div>

<p></div></div></p>

<p>There&#39;s one infix function that I use very often. It&#39;s inspired by Ruby&#39;s <code>||</code> logical or operator, although it works a little differently in R because Ruby has a more flexible definition of what evaluates to <code>TRUE</code> in an if statement. It&#39;s useful as a way of providing a default value in case the output of another function is <code>NULL</code>:</p>

<div class="chunk" id="unnamed-chunk-141"><div class="rcode"><div class="source"><pre class="knitr r">"%||%" <- function(a, b) if (!is.null(a)) a else b
function_that_might_return_null() %||% default value
</pre></div>

<p></div></div></p>

<h3>Replacement functions</h3>

<p>Replacement functions act like they modify their arguments in place, and have the special name <code>xxx&lt;-</code>. They typically have two arguments (<code>x</code> and <code>value</code>), although they can have more, and they must return the modified object. For example, the following function allows you to modify the second element of a vector:</p>

<div class="chunk" id="unnamed-chunk-142"><div class="rcode"><div class="source"><pre class="knitr r">"second<-" <- function(x, value) {
  x[2] <- value
  x
}
x <- 1:10
second(x) <- 5L
x
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  1  5  3  4  5  6  7  8  9 10
</pre></div>

<p></div></div></p>

<p>When R evaluates the assignment <code>second(x) &lt;- 5</code>, it notices that the left hand side of the <code>&lt;-</code> is not a simple name, so it looks for a function named <code>second&lt;-</code> to do the replacement.</p>

<p>I say they &quot;act&quot; like they modify their arguments in place, because they actually create a modified copy. We can see that by using <code>pryr::address()</code> to find the memory address of the underlying object.</p>

<div class="chunk" id="unnamed-chunk-143"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
</pre></div>

<div class="message"><pre class="knitr r">## Loading required package: Rcpp
## 
## Attaching package: 'pryr'
## 
## The following object is masked _by_ '.GlobalEnv':
## 
## f
</pre></div>

<div class="source"><pre class="knitr r">x <- 1:10
address(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "0x1d7fe488"
</pre></div>

<div class="source"><pre class="knitr r">second(x) <- 6L
address(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "0x1e06a9d0"
</pre></div>

<p></div></div></p>

<p>Built in functions that are implemented using <code>.Primitive</code> will modify in place</p>

<div class="chunk" id="unnamed-chunk-144"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1:10
address(x)
# [1] "0x103945110"

x[2] <- 7L
address(x)
# [1] "0x103945110"
</pre></div>

<p></div></div></p>

<p>It&#39;s important to be aware of this behaviour since it has important performance implications.</p>

<p>If you want to supply additional arguments, they go in between <code>x</code> and <code>value</code>:</p>

<div class="chunk" id="unnamed-chunk-145"><div class="rcode"><div class="source"><pre class="knitr r">"modify<-" <- function(x, position, value) {
  x[position] <- value
  x
}
modify(x, 1) <- 10
x
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 10  6  3  4  5  6  7  8  9 10
</pre></div>

<p></div></div></p>

<p>When you call <code>modify(x, 1) &lt;- 10</code>, behind the scenes R turns it into:</p>

<div class="chunk" id="unnamed-chunk-146"><div class="rcode"><div class="source"><pre class="knitr r">x <- `modify<-`(x, 1, 10)
</pre></div>

<p></div></div></p>

<p>This means you can&#39;t do things like:</p>

<div class="chunk" id="unnamed-chunk-147"><div class="rcode"><div class="source"><pre class="knitr r">modify(get("x"), 1) <- 10
</pre></div>

<p></div></div></p>

<p>because that gets turned into the invalid code:</p>

<div class="chunk" id="unnamed-chunk-148"><div class="rcode"><div class="source"><pre class="knitr r">get("x") <- `modify<-`(get("x"), 1, 10)
</pre></div>

<div class="error"><pre class="knitr r">## Error: target of assignment expands to non-language object
</pre></div>

<p></div></div></p>

<p>It&#39;s often useful to combine replacement and subsetting, and this works out of the box:</p>

<div class="chunk" id="unnamed-chunk-149"><div class="rcode"><div class="source"><pre class="knitr r">x <- c(a = 1, b = 2, c = 3)
names(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b" "c"
</pre></div>

<div class="source"><pre class="knitr r">names(x)[2] <- "two"
names(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"   "two" "c"
</pre></div>

<p></div></div></p>

<p>This works because the expression <code>names(x)[2] &lt;- &quot;two&quot;</code> is evaluated as if you had written:</p>

<div class="chunk" id="unnamed-chunk-150"><div class="rcode"><div class="source"><pre class="knitr r">`*tmp*` <- names(x)
`*tmp*`[2] <- "two"
names(x) <- `*tmp*`
</pre></div>

<p></div></div></p>

<p>(Yes, it really does create a local variable named <code>*tmp*</code>, which is removed afterwards.)</p>

<h3>Exercises</h3>

<ul>
<li><p>Create a list of all the replacement functions found in the base package. Which ones are primitive functions?</p></li>
<li><p>What are valid names for user created infix functions?</p></li>
<li><p>Create an infix <code>xor()</code> operator.</p></li>
<li><p>Create infix versions of set functions: <code>intersect()</code>, <code>union()</code>, <code>setdiff()</code></p></li>
<li><p>Create a replacement function that modifies a random location in vector.</p></li>
</ul>

<h2>Return values</h2>

<p>The last expression evaluated in a function becomes the return value, the result of invoking the function. </p>

<div class="chunk" id="unnamed-chunk-151"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  if (x < 10) {
    0
  } else {
    10
  }
}
f(5)
f(15)
</pre></div>

<p></div></div></p>

<p>Generally, I think it&#39;s good style to reserve the use of an explicit <code>return()</code> for when you are returning early, such as for an error, or a simple case of the function. This style of programming can also reduce the level of indentation, and generally make functions easier to understand because you can reason about them locally.</p>

<div class="chunk" id="unnamed-chunk-152"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x, y) {
  if (!x) return(y)

  # complicated processing here
}
</pre></div>

<p></div></div></p>

<p>Functions can return only a single value, but this is not a limitation in practice because you can always return a list containing any number of objects.</p>

<p>The functions that are the most easy to understand and reason about are pure functions, functions that always map the same input to the same output and have no other impact on the workspace. In other words, pure functions have no <strong>side-effects</strong>: they don&#39;t affect the state of the world in any way apart from the value they return. </p>

<p>R protects you from one type of side-effect: most R objects have copy-on-modify semantics, so modifying a function argument does not change the original value:</p>

<div class="chunk" id="unnamed-chunk-153"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  x$a <- 2
  x
}
x <- list(a = 1)
f(x)
</pre></div>

<div class="output"><pre class="knitr r">## $a
## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">x$a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p>(There are two important exceptions to the copy-on-modify rule: environments and reference classes. These can be modified in place, so extra care is needed when working with them.)</p>

<p>This is notably different to languages like Java where you can modify the inputs to a function. This copy-on-modify behaviour has important performance consequences which are discussed in depth in [[profiling]]. (Note that the performance consequences are a result of R&#39;s implementation of copy-on-modify semantics, they are not true in general. Clojure is a new language that makes extensive use of copy-on-modify semantics with limited performance consequences.)</p>

<p>Most base R functions are pure, with a few notable exceptions:</p>

<ul>
<li><p><code>library</code> which loads a package, and hence modifies the search path</p></li>
<li><p><code>setwd</code>, <code>Sys.setenv</code>, <code>Sys.setlocale</code> which change the working directory, environment variables and the locale respectively</p></li>
<li><p><code>plot</code> and friends which produce graphical output</p></li>
<li><p><code>write</code>, <code>write.csv</code>, <code>saveRDS</code> etc which save output to disk</p></li>
<li><p><code>options</code> and <code>par</code> which modify global settings</p></li>
<li><p>S4 related functions which modify global tables of classes and methods.</p></li>
<li><p>random number generators which produce different numbers each time you run them</p></li>
</ul>

<p>It&#39;s generally a good idea to minimise the use of side effects, and where possible separate functions into pure and impure, isolating side effects to the smallest possible location. Pure functions are easier to test (because all you need to worry about are the input values and the output), and are less likely to work differently on different versions of R or on different platforms.  For example, this is one of the motivating principles of ggplot2: most operations work on an object that represents a plot, and only the final <code>print</code> or <code>plot</code> call has the side effect of actually drawing the plot.</p>

<p>Functions can return <code>invisible</code> values, which are not printed out by default when you call the function.</p>

<div class="chunk" id="unnamed-chunk-154"><div class="rcode"><div class="source"><pre class="knitr r">f1 <- function() 1
f2 <- function() invisible(1)

f1()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">f2()
f1() == 1
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">f2() == 1
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>You can always force an invisible value to be displayed by wrapping it in parentheses:</p>

<div class="chunk" id="unnamed-chunk-155"><div class="rcode"><div class="source"><pre class="knitr r">(f2())
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p>The most common function that returns invisibly is <code>&lt;-</code>:</p>

<div class="chunk" id="unnamed-chunk-156"><div class="rcode"><div class="source"><pre class="knitr r">a <- 2
(a <- 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<p></div></div></p>

<p>And this is what makes it possible to assign one value to multiple variables:</p>

<div class="chunk" id="unnamed-chunk-157"><div class="rcode"><div class="source"><pre class="knitr r">a <- b <- c <- d <- 2
</pre></div>

<p></div></div></p>

<p>because that is parsed as:</p>

<div class="chunk" id="unnamed-chunk-158"><div class="rcode"><div class="source"><pre class="knitr r">(a <- (b <- (c <- (d <- 2))))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<h1>OO field guide</h1>

<h2>Introduction</h2>

<p>This chapter is a field guide for recognising and working with R&#39;s objects in the wild. R has three object oriented systems (plus the base types), so it can be a bit intimidating. The goal of this guide is not to make you an expert in all four systems, but to help you identify what system you&#39;re working with, and ensure you know how to use it effectively.</p>

<p>Central to any object-oriented system are the concepts of class and method. A <strong>class</strong> defines the behaviour <strong>objects</strong>, describing the attributes that they possess and how they relate to other classes. The class is also used when selecting <strong>methods</strong>, functions that behave differently depending on the class of their input. Classes are usually organised in a hierarchy: if a method does not exist for a child, then the parent&#39;s method is used instead. This means the child <strong>inherits</strong> behaviour from the parent.</p>

<p>R&#39;s three OO systems differ in how classes and methods are defined:</p>

<ul>
<li><p><strong>S3</strong> implements a style of OO programming called generic-function OO. This is different to most programming languages, like Java, C++ and C#, which implement message-passing OO. In message-passing style, messages (methods) are sent to objects and the object determines which function to call. Typically this object has a special appearance in the method call, usually appearing before the name of the method/message: e.g. <code>canvas.drawRect(&quot;blue&quot;)</code>. S3 is different. While computations are still carried out via methods, a  special type of function called a <strong>generic function</strong> decides which method to call, and calls look like <code>drawRect(canvas, &quot;blue&quot;)</code>. S3 is a very casual system, and has no formal definition of classes.</p></li>
<li><p><strong>S4</strong> works similarly to S3, but is more formal. There are two major differences to S3. S4 has formal class definitions, which describe the representation and inheritance for each class, and has special helper functions for defining generics and methods. S4 also has multiple dispatch, which means that generic functions can pick method based on the class of any number of arguments, not just one.</p></li>
<li><p><strong>Reference classes</strong>, called RC for short, is quite different to S3 and S4. RC implements message passing OO, so methods belong to classes, not functions. <code>$</code> is used to separate objects and methods, so method calls look like <code>canvas$drawRect(&quot;blue&quot;)</code>. RC objects are also mutable: they don&#39;t use R&#39;s usual copy-on-modify semantics, but are modified in place. This makes them harder to reason about, but allows them to solve problems that are difficult to solve with S3 or S4.</p></li>
</ul>

<p>There&#39;s also one other system that&#39;s not quite OO, but it&#39;s important to mention here, and that&#39;s </p>

<ul>
<li><strong>base types</strong>, the internal C-level types that underlie the other OO systems. Base types are mostly manipulated using C code, but they&#39;re important to know about because they provide the building blocks for the other OO systems.</li>
</ul>

<p>The following sections describes each system in turn, starting with base types. You&#39;ll learn how to recognise the OO system that an object belongs to, how method dispatch works, and how to create new objects, classes, generics and methods for that system. The chapter concludes with a few remarks on when to use each system.</p>

<h2>Base types</h2>

<p>Underlying every R object is a C structure (or struct) that describes how the object is stored in memory. The struct includes the contents of the object, information needed for memory management, and most importantly for this section, a <strong>type</strong>.  This is the <strong>base type</strong> of an R object. Base types are not really an object system, because only R core can create new types and every new type makes base R a little more complicated. New base types are added very rarely: the most recent change in 2011 was to add two exotic types that you never see in R, but are useful for diagnosing memory problems (<code>NEWSXP</code> and <code>FREESXP</code>), and the last change before that was in 2005, where a special base type for S4 objects (<code>S4SXP</code>) was added. </p>

<p><a href="data-structures.html">Data structures</a> explained the most common base types (atomic vectors and lists), but base types also encompass functions, environments and other more exotic objects likes names, calls and promises that you&#39;ll learn about later in the book, . You can find out the the base type of an object with <code>typeof()</code>, or see a complete list of types in <code>?typeof()</code>. Be aware that the names of base types are are not used consistently throughout R: the type and the corresponding &quot;is&quot; function may have different names:</p>

<div class="chunk" id="unnamed-chunk-159"><div class="rcode"><div class="source"><pre class="knitr r"># The type of a function is "closure", and the
# type of a primitive function is "builtin"
f <- function() {}
typeof(f)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "closure"
</pre></div>

<div class="source"><pre class="knitr r">is.function(f)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">
typeof(sum)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "builtin"
</pre></div>

<div class="source"><pre class="knitr r">is.primitive(sum)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>You may have heard of <code>mode()</code> and <code>storage.mode()</code>. I recommend ignoring these functions because they just alias some of the names returned by <code>typeof()</code> for S compatibility. Their source code is simple, and I recommend reading it if you want to know exactly what they do.</p>

<p>Functions that behave differently for different base types are almost always written in C, where dispatch occurs using switch statements (e.g. <code>switch(TYPEOF(x))</code>). Even if you never write C code, it&#39;s important to understand base types because everything else is built on top of them: S3 objects can be built on top of any base type, S4 objects use a special base type, and RC objects are a combination of S4 and environments (another base type). To figure out if an object is a pure base type, i.e. it doesn&#39;t also have S3, S4 or RC behaviour, check that <code>is.object(x)</code> returns <code>FALSE</code>.</p>

<h2>S3</h2>

<p>S3 is R&#39;s first and simplest OO system. It is the only OO system used in the base and stats packages, and it&#39;s the most commonly used system in packages. S3 is informal and ad hoc, but it has a certain elegance in its minimalism: you couldn&#39;t take any part of it away and still have a useful OO system.</p>

<h3>Recognising objects, generic functions and methods</h3>

<p>Most objects that you encounter are S3 objects. You can check by testing that it&#39;s an object (<code>is.object(x)</code>), but it&#39;s not an S4 object (<code>!isS4(x)</code>). This check is automated by <code>pryr::otype()</code>, which provides an easy way to determine the OO system of an object:</p>

<div class="chunk" id="unnamed-chunk-160"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)

df <- data.frame(x = 1:10, y = letters[1:10])
otype(df)    # A data frame is an S3 class
</pre></div>

<div class="output"><pre class="knitr r">## [1] "S3"
</pre></div>

<div class="source"><pre class="knitr r">otype(df$x)  # A numeric vector isn't
</pre></div>

<div class="output"><pre class="knitr r">## [1] "primitive"
</pre></div>

<div class="source"><pre class="knitr r">otype(df$y)  # A factor is
</pre></div>

<div class="output"><pre class="knitr r">## [1] "S3"
</pre></div>

<p></div></div></p>

<p>In S3, methods are associated with functions, called <strong>generic functions</strong>, or generics for short, not objects or classes. This is different from most other programming languages, but is a legitimate OO style. </p>

<p>To determine if a function is an S3 generic, you can look at its source code for a call to <code>UseMethod()</code>: that&#39;s the function that figures out the correct method to call, the process of <strong>method dispatch</strong>. Similar to <code>otype()</code>, pryr also provides <code>ftype()</code> which describes the object system (if any associated) with a function:</p>

<div class="chunk" id="unnamed-chunk-161"><div class="rcode"><div class="source"><pre class="knitr r">mean
</pre></div>

<div class="output"><pre class="knitr r">## function (x, ...) 
## UseMethod("mean")
## <bytecode: 0x1e271db8>
## <environment: namespace:base>
</pre></div>

<div class="source"><pre class="knitr r">ftype(mean)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s3"      "generic"
</pre></div>

<p></div></div></p>

<p>Some S3 generics, like <code>[</code>, <code>sum</code> and <code>cbind</code>, don&#39;t call <code>UseMethod()</code> because they are implemented in C. Instead, they call the C functions <code>DispatchGroup()</code> or <code>DispatchOrEval()</code>. Functions that do method dispatch in C code are called <strong>internal generics</strong> and are documented in <code>?&quot;internal generic&quot;</code>. <code>ftype()</code> knows about these special cases too.</p>

<p>The job of an S3 generic is to call an S3 method specialised for the given class. You can recognise S3 methods by their names, which look like <code>generic.class()</code>. For example, the Date method for the <code>mean()</code> generic is called <code>mean.Date()</code>, and the factor method for <code>print()</code> is called <code>print.factor()</code>. Most modern style guides discourage the use of <code>.</code> in function names because it makes them look like S3 methods. For example, is <code>t.test()</code> the <code>test</code> method for <code>t</code> objects? Similarly, the use of <code>.</code> in class names can also be confusing: is <code>print.data.frame()</code> the <code>print()</code> method for <code>data.frames</code>, or the <code>print.data()</code> method for <code>frames</code>? <code>pryr::ftype()</code> knows about these exceptions, so you can use it to figure out if a function is an S3 method or generic:</p>

<div class="chunk" id="unnamed-chunk-162"><div class="rcode"><div class="source"><pre class="knitr r">ftype(t.data.frame) # data frame method for t()
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s3"     "method"
</pre></div>

<div class="source"><pre class="knitr r">ftype(t.test)       # generic function for t tests
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s3"      "generic"
</pre></div>

<div class="source"><pre class="knitr r">
ftype(is.numeric)   # naming convention for testing and coercion
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "getGroupMembers"
</pre></div>

<div class="source"><pre class="knitr r">ftype(as.numeric)   # there are no S3 generics for is and as
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "getGroupMembers"
</pre></div>

<p></div></div></p>

<p>You can see all the methods of a generic using the <code>methods()</code> function:</p>

<div class="chunk" id="unnamed-chunk-163"><div class="rcode"><div class="source"><pre class="knitr r">methods("mean")
</pre></div>

<div class="output"><pre class="knitr r">## [1] mean.Date     mean.default  mean.difftime mean.POSIXct  mean.POSIXlt
</pre></div>

<div class="source"><pre class="knitr r">methods("t.test")
</pre></div>

<div class="output"><pre class="knitr r">## [1] t.test.default* t.test.formula*
## 
##    Non-visible functions are asterisked
</pre></div>

<p></div></div></p>

<p>(Apart from methods defined in the base package, most S3 methods will not be visible: use <code>getS3method()</code> to read their source code.)</p>

<p>You can also list all generics that have a method for a given class:</p>

<div class="chunk" id="unnamed-chunk-164"><div class="rcode"><div class="source"><pre class="knitr r">methods(class = "ts")
</pre></div>

<div class="output"><pre class="knitr r">##  [1] aggregate.ts     as.data.frame.ts cbind.ts*        cycle.ts*       
##  [5] diffinv.ts*      diff.ts          kernapply.ts*    lines.ts        
##  [9] monthplot.ts*    na.omit.ts*      plot.ts          print.ts        
## [13] time.ts*         [<-.ts*          [.ts*            t.ts*           
## [17] window<-.ts*     window.ts*      
## 
##    Non-visible functions are asterisked
</pre></div>

<p></div></div></p>

<p>There&#39;s no way to list of all S3 classes, because there&#39;s no central repository of them, as you&#39;ll learn in the following section.</p>

<h3>Defining classes and creating objects</h3>

<p>S3 is a simple and ad hoc system; it has no formal definition of a class. To make an object an instance of a class, you just take an existing base object and set the class attribute. You can do that during creation with <code>structure()</code>, or after the fact with <code>attr&lt;-()</code>.  However, if you&#39;re modifying an existing object, using <code>class&lt;-()</code> will more clearly communicate your intent: </p>

<div class="chunk" id="unnamed-chunk-165"><div class="rcode"><div class="source"><pre class="knitr r"># Create and assign class in one step
foo <- structure(list(), class = "foo")

# Create, then set class
foo <- list()
class(foo) <- "foo"
</pre></div>

<p></div></div></p>

<p>S3 objects are usually built on top of lists, or atomic vectors with <a href="data-structures.html#attributes">attributes</a>. You can also turn functions into S3 objects. Other base types are either rarely seen in R, or have unusual semantics that don&#39;t work well with attributes.</p>

<p>You can determine the class of any object using <code>class(x)</code>, and see if an object inherits from a specific class using <code>inherits(x, &quot;classname&quot;)</code>.</p>

<div class="chunk" id="unnamed-chunk-166"><div class="rcode"><div class="source"><pre class="knitr r">class(foo)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "foo"
</pre></div>

<div class="source"><pre class="knitr r">inherits(foo, "foo")
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>The class of an S3 object can be a vector, which describes behaviour from most to least specific. For example, the class of the <code>glm()</code> object is <code>c(&quot;glm&quot;, &quot;lm&quot;)</code> indicating that generalised linear models inherit behaviour from linear models. Class names are usually lower case, and you should avoid <code>.</code>. Otherwise, opinion is mixed whether to use underscores (<code>my_class</code>) or upper camel case (<code>MyClass</code>) for multi-word class names.</p>

<p>Most S3 classes provide a constructor function:</p>

<div class="chunk" id="unnamed-chunk-167"><div class="rcode"><div class="source"><pre class="knitr r">foo <- function(x) {
  if (!is.numeric(x)) stop("X must be numeric")
  structure(list(x), class = "foo")
}
</pre></div>

<p></div></div></p>

<p>and you should use it if it&#39;s available (like for <code>factor()</code> and <code>data.frame()</code>). This ensures that you&#39;re creating the class with the correct components. Constructor functions usually have the same name as the class.</p>

<p>Apart from developer supplied constructor functions, S3 has no checks for correctness. This means you can change the class of existing objects:</p>

<div class="chunk" id="unnamed-chunk-168"><div class="rcode"><div class="source"><pre class="knitr r"># Create a linear model
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "lm"
</pre></div>

<div class="source"><pre class="knitr r">
# Turn it into a table (?!)
class(mod) <- "table"
# But unsurprisingly this doesn't work very well
print(mod)
</pre></div>

<div class="error"><pre class="knitr r">## Error: argument not a list
</pre></div>

<p></div></div></p>

<p>If you&#39;ve used other OO languages, this might make you feel queasy. But surprisingly, this flexibility causes few problems: while you <em>can</em> change the type of an object, you never should. R doesn&#39;t protect you from yourself: you can easily shoot yourself in the foot, but if you don&#39;t aim the gun at your foot and pull the trigger, you won&#39;t have a problem.</p>

<h3>Creating new methods and generics</h3>

<p>To add a new generic, create a function that calls <code>UseMethod()</code>. <code>UseMethod()</code> takes two arguments: the name of the generic function, and the argument to use for method dispatch. If you omit the second argument it will dispatch on the first argument to the function.</p>

<div class="chunk" id="unnamed-chunk-169"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) UseMethod("f")
</pre></div>

<p></div></div></p>

<p>A generic isn&#39;t useful without some methods. To add a method, you just create a regular function with the correct (<code>generic.class</code>) name:</p>

<div class="chunk" id="unnamed-chunk-170"><div class="rcode"><div class="source"><pre class="knitr r">f.a <- function(x) "Class a"

a <- structure(list(), class = "a")
class(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">f(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Class a"
</pre></div>

<p></div></div></p>

<p>Adding a method to an existing generic works in the same way:</p>

<div class="chunk" id="unnamed-chunk-171"><div class="rcode"><div class="source"><pre class="knitr r">mean.a <- function(x) "a"
mean(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<p></div></div></p>

<p>As you can see, there&#39;s no check to make sure that the method returns a class compatible with the generic. It&#39;s up to you to make sure that your method doesn&#39;t violate the expectations of existing code.</p>

<h3>Method dispatch</h3>

<p>S3 method dispatch is relatively simple. <code>UseMethod()</code> creates a vector of function names, like <code>paste0(generic, &quot;.&quot;, c(class(x), &quot;default&quot;)</code> and looks for each in turn. The &quot;default&quot; class makes it possible to set up a fall back methods for otherwise unknown classes.</p>

<div class="chunk" id="unnamed-chunk-172"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) UseMethod("f")
f.a <- function(x) "Class a"
f.default <- function(x) "Unknown class"

f(structure(list(), class = "a"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Class a"
</pre></div>

<div class="source"><pre class="knitr r"># No method for b class, so uses method for a class
f(structure(list(), class = c("b", "a")))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Class a"
</pre></div>

<div class="source"><pre class="knitr r"># No method for c class, so falls back to default
f(structure(list(), class = "c"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Unknown class"
</pre></div>

<p></div></div></p>

<p>Group generics represent methods add a little more complexity. Group generics make it possible to implement methods for multiple generics with one function. The four group generics and the functions they include are:</p>

<ul>
<li>Math: <code>abs</code>, <code>sign</code>, <code>sqrt</code>, <code>floor</code>, <code>cos</code>, <code>sign</code>, <code>log</code>, <code>exp</code>, ...</li>
<li>Ops: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code></li>
<li>Summary: <code>all</code>, <code>any</code>, <code>sum</code>, <code>prod</code>, <code>min</code>, <code>max</code>, <code>range</code></li>
<li>Complex: <code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code></li>
</ul>

<p>Group generics are a relatively advanced technique and are beyond the scope of this chapter but you can find out more about them in <code>?groupGeneric</code>. The most important take-away is to recognise that <code>Math</code>, <code>Ops</code>, <code>Summary</code> and <code>Complex</code> aren&#39;t real functions, but represent groups of functions. Note that inside a group generic function a special variable <code>.Generic</code> provides the actual generic function called.</p>

<p>If you have complex class hierarchies it&#39;s sometimes useful to call the &quot;parent&quot; method. It&#39;s a little bit tricky to define exactly what that means, but it&#39;s basically the method that would have been called if the current method did not exist. Again, this is an advanced technique: you can read about it in <code>nextMethod()</code>.</p>

<p>Because methods are normal R functions, you can call them directly. However, this is just as dangerous as changing the class of an object, so you shouldn&#39;t do it: please don&#39;t point the loaded gun at your foot! (The only reason to call the method directly is that sometimes when you&#39;re writing OO code, not using someone else&#39;s, you can get considerable speed-ups by skipping regular method dispatch).</p>

<div class="chunk" id="unnamed-chunk-173"><div class="rcode"><div class="source"><pre class="knitr r">c <- structure(list(), class = "c")
# Call the correct method:
f.default(c)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Unknown class"
</pre></div>

<div class="source"><pre class="knitr r"># Or force R to call the wrong method:
f.a(c)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Class a"
</pre></div>

<p></div></div></p>

<p>You can also call an S3 generic with a non-S3 object. Non-internal S3 generics will dispatch on the <strong>implicit class</strong> of base types. (Internal generics don&#39;t do that for performance reasons.) The rules to determine the implicit class of a primitive type are somewhat complex, but are shown in the function below:</p>

<div class="chunk" id="unnamed-chunk-174"><div class="rcode"><div class="source"><pre class="knitr r">iclass <- function(x) {
  if (is.object(x)) stop("x is not a primitive type", call. = FALSE)

  c(
    if (is.matrix(x)) "matrix",
    if (is.array(x) && !is.matrix(x)) "array",
    if (is.double(x)) "double",
    if (is.integer(x)) "integer",
    mode(x)
  )
}
iclass(matrix(1:5))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "matrix"  "integer" "numeric"
</pre></div>

<div class="source"><pre class="knitr r">iclass(array(1.5))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "array"   "double"  "numeric"
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>Read the source code for <code>t()</code> and <code>t.test()</code> and confirm for yourself that <code>t.test()</code> is an S3 generic, and not an S3 method. What happens if you create an object with class <code>test</code> and call <code>t()</code> with it?</p></li>
<li><p>What classes have a method for the <code>Math</code> group generic in base R? Read the source code. How do the methods work?</p></li>
<li><p>R has two classes for representing date time data, <code>POSIXct</code> and <code>POSIXlt</code> which both inherit from <code>POSIXt</code>. Which generics have different behaviour for the two classes? Which generics share the same behaviour?</p></li>
<li><p>Which base generic has the most methods defined for it?</p></li>
<li><p><code>UseMethod()</code> calls methods in a special way. Predict what the following code will return, then run it and read the help for <code>UseMethod()</code> to figure out what&#39;s going on. Write down the rules in the simplest form possible.</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-175"><div class="rcode"><div class="source"><pre class="knitr r">y <- 1
g <- function(x) { 
  y <- 2
  UseMethod("g")
}
g.numeric <- function(x) y
g(10)

h <- function(x) {
  x <- 10
  UseMethod("h")
}
h.character <- function(x) paste("char", x)
h.numeric <- function(x) paste("num", x)

h("a")
</pre></div>

<p></div></div></p>

<ul>
<li>Internal generics don&#39;t dispatch on the implicit class of base types. Carefully read <code>?&quot;internal generic&quot;</code> to determine why the length of <code>f</code> and <code>g</code> is different in the example below. What function helps distinguish between the behaviour of <code>f</code> and <code>g</code>?</li>
</ul>

<div class="chunk" id="unnamed-chunk-176"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() 1
g <- function() 2
class(g) <- "function"
class(f)
class(g)

length.function <- function(x) "function"

length(f)
length(g)
</pre></div>

<p></div></div></p>

<h2>S4</h2>

<p>S4 works in a similar way to S3, but it adds formality and rigour. Methods still belong to functions, not classes, but:</p>

<ul>
<li><p>Classes have a formal definition, describing their fields and inheritance structure (parent classes).</p></li>
<li><p>Method dispatch can be based on multiple arguments to a generic function, not just one.</p></li>
<li><p>There is a special operator, <code>@</code>, for extracting fields (aka slots) out of an S4 object.</p></li>
</ul>

<p>All S4 related code is stored in the methods package. This package is always available when you&#39;re running R interactively, but is not always loaded automatically when running R from the command line. For this reason, it&#39;s a good idea to include an explicit <code>library(methods)</code> whenever you&#39;re using S4.</p>

<p>S4 is a rich and complex system, and there&#39;s no way to explain it fully in a few pages. Here I&#39;ll focus on the key ideas underlying S4 so that you can use existing S4 objects effectively. To learn more, some good references are:</p>

<ul>
<li><p><a href="http://www.bioconductor.org/help/course-materials/2010/AdvancedR/S4InBioconductor.pdf">S4 system development in Bioconductor</a></p></li>
<li><p>John Chamber&#39;s <a href="http://amzn.com/0387759352?tag=devtools-20">Software for data analysis</a></p></li>
<li><p><a href="http://stackoverflow.com/search?tab=votes&amp;q=user%3a547331%20%5bs4%5d%20is%3aanswe">Martin Morgan&#39;s answers to S4 questions on stackoverflow</a></p></li>
</ul>

<h3>Recognising objects, generic functions and methods</h3>

<p>Recognising S4 objects, generics and methods is easy. You can identify an S4 object because <code>str()</code> describes it as a &quot;formal&quot; class, <code>isS4()</code> is true, and <code>pryr::otype()</code> returns &quot;S4&quot;. S4 generics and methods are also easy to identify because they are S4 objects with well defined classes.</p>

<p>There aren&#39;t any S4 classes in the commonly used base packages (stats, graphics, utils, datasets, and base), so we&#39;ll start by creating an S4 object from the built-in stats4 package, which provides some S4 classes and methods associated with maximum likelihood estimation:</p>

<div class="chunk" id="unnamed-chunk-177"><div class="rcode"><div class="source"><pre class="knitr r">library(stats4)
</pre></div>

<div class="message"><pre class="knitr r">## Loading required package: methods
</pre></div>

<div class="source"><pre class="knitr r">
# From example(mle)
y <- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
nLL <- function(lambda) -sum(dpois(y, lambda, log = TRUE))
fit <- mle(nLL, start = list(lambda = 5), nobs = length(y))

# An S4 object
isS4(fit)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">otype(fit)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "S4"
</pre></div>

<div class="source"><pre class="knitr r">
# An S4 generic
isS4(nobs)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">ftype(nobs)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s4"      "generic"
</pre></div>

<div class="source"><pre class="knitr r">
# Retrieve an S4 method, described later
mle_nobs <- method_from_call(nobs(fit))
isS4(mle_nobs)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">ftype(mle_nobs)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s4"     "method"
</pre></div>

<p></div></div></p>

<p>You can determine the class of an S4 object with <code>class()</code> and test if an object inherits from a specific class with <code>is()</code>:</p>

<div class="chunk" id="unnamed-chunk-178"><div class="rcode"><div class="source"><pre class="knitr r">class(fit)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "mle"
## attr(,"package")
## [1] "stats4"
</pre></div>

<div class="source"><pre class="knitr r">is(fit, "mle")
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>You can get a list of all S4 generics with <code>getGenerics()</code>, and a list of all S4 classes with <code>getClasses()</code>, but note that this list includes shim classes for S3 classes and base types. You can list all S4 methods with <code>showMethods()</code>, optionally restricting either by <code>generic</code> or by <code>class</code> (or both). It&#39;s also a good idea to supply <code>where = search()</code> to restrict to methods available from the global environment.</p>

<h3>Defining classes and creating objects</h3>

<p>In S3, you can turn any object into an object of a particular class just by setting the class attribute. S4 is much stricter: you must define the representation of the class using <code>setClass()</code>, and create an new object with <code>new()</code>. You can find the documentation for a class with a special syntax: <code>class?className</code>, e.g. <code>class?mle</code>. </p>

<p>An S4 class has three key properties:</p>

<ul>
<li><p>a <strong>name</strong>: an alpha-numeric class identifier. S4 classes names should
use UpperCamelCase.</p></li>
<li><p>a named list of <strong>slots</strong> (fields), providing slot names and
permitted classes. For example, a person class might be represented by a
character name and a numeric age: <code>list(name = &quot;character&quot;, age = &quot;numeric&quot;)</code></p></li>
<li><p>a string giving the class it inherits from, or in S4 terminology, 
that it <strong>contains</strong>. You can provide multiple classes for multiple 
inheritance, but this is an advanced technique and as it adds much 
complexity.</p>

<p>In <code>slots</code> and <code>contains</code> you can use S4 classes, S3 classes registered 
with <code>setOldClass()</code>, or the the implicit class of a base type. In <code>slots</code>
you can also use the special class &quot;ANY&quot; which does not restrict the input.</p></li>
</ul>

<p>S4 classes have other optional properties like a <code>validity</code> method that tests if an object is valid, and a <code>prototype</code> that defines slot default values. See <code>?setClass</code> for more details.</p>

<p>The following example creates a Person class with fields name and age, and an Employee class that inherits from Person. The Employee class inherits the slots and methods from the Person, and adds an additional slot, boss. To create objects we call <code>new()</code> with the name of the class, and name-value pairs of slot values.</p>

<div class="chunk" id="unnamed-chunk-179"><div class="rcode"><div class="source"><pre class="knitr r">setClass("Person", 
  slots = list(name = "character", age = "numeric"))
setClass("Employee", 
  slots = list(boss = "Person"), 
  contains = "Person")

alice <- new("Person", name = "Alice", age = 40)
john <- new("Employee", name = "John", age = 20, boss = alice)
</pre></div>

<p></div></div></p>

<p>Most S4 classes also come with a constructor function with the same name as the class: if that exists, use it instead of calling <code>new()</code> directly.</p>

<p>To access slots of an S4 object you use <code>@</code> or <code>slot()</code>:</p>

<div class="chunk" id="unnamed-chunk-180"><div class="rcode"><div class="source"><pre class="knitr r">alice@age
</pre></div>

<div class="output"><pre class="knitr r">## [1] 40
</pre></div>

<div class="source"><pre class="knitr r">slot(john, "boss")
</pre></div>

<div class="output"><pre class="knitr r">## An object of class "Person"
## Slot "name":
## [1] "Alice"
## 
## Slot "age":
## [1] 40
</pre></div>

<p></div></div></p>

<p>(<code>@</code> is equivalent to <code>$</code>, and <code>slot()</code> to <code>[[</code>.)</p>

<p>If an S4 object contains (inherits) from an S3 class or a base type, it will have a special <code>.Data</code> slot which contains the underlying base type or S3 object:</p>

<div class="chunk" id="unnamed-chunk-181"><div class="rcode"><div class="source"><pre class="knitr r">setClass("RangedNumeric", 
  contains = "numeric", 
  slots = list(min = "numeric", max = "numeric"))
rn <- new("RangedNumeric", 1:10, min = 1, max = 10)
rn@min
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">rn@.Data
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  1  2  3  4  5  6  7  8  9 10
</pre></div>

<p></div></div></p>

<p>Since R is an interactive programming language, it&#39;s possible to create new classes or redefine existing classes at any time. This can be a problem when you&#39;re interactively experimenting with S4. If you modify a class, make sure you also recreate any objects of that class you&#39;ll end up with invalid objects. </p>

<h3>Creating new methods and generics</h3>

<p>S4 provides special functions for creating new generics and methods. <code>setGeneric()</code> will create a new generic or convert an existing function into a generic. <code>setMethod()</code> takes the name of the generic, the classes the method should be associated with and a function that implements the method. For example, we could take <code>union()</code>, which usually just works on vectors, and make it work with data frames:</p>

<div class="chunk" id="unnamed-chunk-182"><div class="rcode"><div class="source"><pre class="knitr r">setGeneric("union")
</pre></div>

<div class="output"><pre class="knitr r">## [1] "union"
</pre></div>

<div class="source"><pre class="knitr r">setMethod("union", 
  c(x = "data.frame", y = "data.frame"), 
  function(x, y) {
    unique(rbind(x, y))
  }
)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "union"
</pre></div>

<p></div></div></p>

<p>If you create a new generic from scratch, you also need to supply a that calls <code>standardGeneric()</code>:</p>

<div class="chunk" id="unnamed-chunk-183"><div class="rcode"><div class="source"><pre class="knitr r">setGeneric("myGeneric", function(x) {
  standardGeneric("myGeneric")
})
</pre></div>

<div class="output"><pre class="knitr r">## [1] "myGeneric"
</pre></div>

<p></div></div></p>

<h3>Method dispatch</h3>

<p>S4 method dispatch is the same as S3 dispatch if your classes only inherit from a single parent, and you only dispatch on one class. The main difference is how you set up default values: S4 uses the special class &quot;ANY&quot; to match any class and &quot;missing&quot; to match a missing argument. Like S3, S4 also has group generics, documented in <code>?S4groupGeneric</code>, and a way to call the &quot;parent&quot; method, <code>callNextMethod()</code>.</p>

<p>Method dispatch becomes considerably more complicated if you dispatch on multiple arguments, or your classes use multiple inheritance. The rules are described in <code>?Methods</code>, but they are complicated and it&#39;s difficult to predict which method will be called. For this reason, I strongly recommend avoiding multiple inheritance and multiple dispatch unless absolutely necessary.</p>

<p>Finally, there are two methods that given the specification of a generic call will find which method gets called:</p>

<div class="chunk" id="unnamed-chunk-184"><div class="rcode"><div class="source"><pre class="knitr r"># From methods: takes generic name and class names
selectMethod("nobs", list("mle"))

# From pryr: takes an unevaluated function call 
method_from_call(nobs(fit))
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>Which S4 generic has the most methods defined for it? Which S4 class has the most methods associated with it?</p></li>
<li><p>What happens if you define a new S4 class that doesn&#39;t &quot;contain&quot; an existing class?  (Hint: read about virtual classes in <code>?Classes</code>)</p></li>
<li><p>What happens if you pass an S4 object to an S3 generic? What happens if you pass an S3 object to an S4 generic? (Hint: read <code>?setOldClass</code> for the second case)</p></li>
</ul>

<h2>RC</h2>

<p>Reference classes (or RC for short) are the newest OO system in R, introduced in 2.12. They are fundamentally different to S3 and S4 because:</p>

<ul>
<li><p>RC methods belong to objects, not functions.</p></li>
<li><p>RC objects are mutable: the usual R copy on modify semantics do not apply.</p></li>
</ul>

<p>These properties make RC objects behave more like objects found in most other programming languages like python, ruby, Java and C#. Surprisingly, reference classes are implemented in R, not C: they are a special S4 class that wraps around an environment.</p>

<h3>Defining classes and creating objects</h3>

<p>Since there aren&#39;t any reference classes provided by the base R packages, we&#39;ll start by creating one. RC classes are best used for describing stateful objects, objects that change over time, so we&#39;ll create a simple class to model a bank account. </p>

<p>Creating a new RC class is similar to creating a new S4 class, but you use <code>setRefClass()</code> instead of <code>setClass()</code>. The first, and only required argument, is an alpha-numeric <strong>name</strong>. While you can use <code>new()</code> to create new RC objects, it&#39;s good style to use the object returned by <code>setRefClass()</code> to generate new objects. (You can also do that with S4 classes, but it&#39;s less common).</p>

<div class="chunk" id="unnamed-chunk-185"><div class="rcode"><div class="source"><pre class="knitr r">Account <- setRefClass("Account")
Account$new()
</pre></div>

<div class="output"><pre class="knitr r">## Reference class object of class "Account"
</pre></div>

<p></div></div></p>

<p><code>setRefClass()</code> also accepts a list of name-class pairs that define class <strong>fields</strong> (equivalent to S4 slots). Additional named arguments passed to <code>new()</code> will set initial values of the fields, and you can get and set field values with <code>$</code>:</p>

<div class="chunk" id="unnamed-chunk-186"><div class="rcode"><div class="source"><pre class="knitr r">Account <- setRefClass("Account", 
  fields = list(balance = "numeric"))

a <- Account$new(balance = 100)
a$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 100
</pre></div>

<div class="source"><pre class="knitr r">a$balance <- 200
a$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 200
</pre></div>

<p></div></div></p>

<p>Instead of supplying a class name for the field, you can provide a single argument function which will act as an accessor method, allowing you to add custom behaviour when getting or setting a field. See <code>?setRefClass</code> for more details.</p>

<p>Note that RC objects are <strong>mutable</strong>, i.e. they have reference semantics, and are not copied-on-modify:</p>

<div class="chunk" id="unnamed-chunk-187"><div class="rcode"><div class="source"><pre class="knitr r">b <- a
b$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 200
</pre></div>

<div class="source"><pre class="knitr r">a$balance <- 0
b$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<p></div></div></p>

<p>For this reason, RC objects come with a <code>copy()</code> method that will make a copy of the object:</p>

<div class="chunk" id="unnamed-chunk-188"><div class="rcode"><div class="source"><pre class="knitr r">c <- a$copy()
c$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<div class="source"><pre class="knitr r">a$balance <- 100
c$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<p></div></div></p>

<p>An object is not very useful without some behaviour defined by <strong>methods</strong>. RC methods are associated with a class and can modify its fields in-place. In the following example, note that you access the value of fields with their name, and you modify them using <code>&lt;&lt;-</code>. (You&#39;ll learn more about <code>&lt;&lt;-</code> in <a href="environments.html">Environments</a>)</p>

<div class="chunk" id="unnamed-chunk-189"><div class="rcode"><div class="source"><pre class="knitr r">Account <- setRefClass("Account", 
  fields = list(balance = "numeric"),
  methods = list(
    withdraw = function(x) {
      balance <<- balance - x
    },
    deposit = function(x) {
      balance <<- balance + x
    }
  )
)
</pre></div>

<p></div></div></p>

<p>You call an RC method in the same way as you access a field:</p>

<div class="chunk" id="unnamed-chunk-190"><div class="rcode"><div class="source"><pre class="knitr r">a <- Account$new(balance = 100)
a$deposit(100)
a$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 200
</pre></div>

<p></div></div></p>

<p>The final important argument to <code>setRefClass()</code> is <code>contains</code>, the name of a parent RC class to inherit behaviour from. The following example creates a new type of bank account that throws an error preventing the balance from going below 0.</p>

<div class="chunk" id="unnamed-chunk-191"><div class="rcode"><div class="source"><pre class="knitr r">NoOverdraft <- setRefClass("NoOverdraft", 
  contains = "Account",
  methods = list(
    withdraw = function(x) {
      if (balance < x) stop("Not enough money")
      balance <<- balance - x
    }
  )
)
accountJohn <- NoOverdraft$new(balance = 100)
accountJohn$deposit(50)
accountJohn$balance
</pre></div>

<div class="output"><pre class="knitr r">## [1] 150
</pre></div>

<div class="source"><pre class="knitr r">accountJohn$withdraw(200)
</pre></div>

<div class="error"><pre class="knitr r">## Error: Not enough money
</pre></div>

<p></div></div></p>

<p>All reference classes eventually inherit from <code>envRefClass</code>, which provides methods useful methods like <code>copy()</code> (shown above), <code>callSuper()</code> (to call the parent field), <code>field()</code> (to the value of a field given its name), <code>export()</code> (equivalent to <code>as</code>) and <code>show()</code> (overridden to control printing). See the inheritance section in <code>setRefClass()</code> for more details.</p>

<h3>Recognising objects and methods</h3>

<p>You can recognise RC objects because they are S4 objects (<code>isS4(x)</code>) that inherit from &quot;refClass&quot; (<code>is(x, &quot;refClass&quot;)</code>). <code>pryr::otype()</code> will return &quot;RC&quot;.  RC methods are also S4 objects, with class <code>refMethodDef</code>.</p>

<h3>Method dispatch</h3>

<p>Method dispatch is very simple in RC because methods are associated with classes, not functions. When you call <code>x$f()</code>, R will look for a method f in the class of x, then in its parent, then its parent&#39;s parent, and so on. From within a method, you can call the parent method directly with <code>callSuper(...)</code>.</p>

<h3>Exercises</h3>

<ul>
<li><p>Use a field function to prevent the account balance from being manipulated directly. (Hint: create a &quot;hidden&quot; <code>.balance</code> field, and read the help for the fields argument in <code>setRefClass()</code>)</p></li>
<li><p>I claimed that there aren&#39;t any RC classes in base R, but that was a bit of a simplification. Use <code>getClasses()</code> and find which classes <code>extend()</code> from <code>envRefClass</code>. What are the classes used for? (Hint: recall how to look up the documentation for a class)</p></li>
</ul>

<h2>Picking a system</h2>

<p>Three OO systems is a lot for one language, but for most R programming, S3 suffices. In R you usually create fairly simple objects, and a methods for pre-existing generic functions like <code>print()</code>, <code>summary()</code> and <code>plot()</code>. S3 is well suited to this task, and the majority of OO code that I have written in R is S3. S3 is a little quirky, but it gets the job done with a minimum of code.</p>

<p>If you are creating more complicated systems of interrelated objects, S4 may be more appropriate. A good example is the <code>Matrix</code> package by Douglas Bates and Martin Maechler. It is designed to efficiently store and compute with many different types of sparse matrix. As at version 1.0.12 it defines 110 classes and 18 generic functions. The package is well written and well commented, and the accompanying vignette (<code>vignette(&quot;Intro2Matrix&quot;, package = &quot;Matrix&quot;)</code>) gives a good overview of the structure of the package. S4 is also used extensively by Bioconductor packages, which need to model complicated interrelationships of biological objects. Bioconductor provides many <a href="https://www.google.com/search?q=bioconductor+s4">good resources</a> for learning S4. If you&#39;ve mastered S3, S4 is relatively easy to pick up: the ideas are all the same, it is just more formal, more strict and more verbose. </p>

<p>If you&#39;ve programmed in mainstream OO language, RC will seem very natural. But because they can introduce side-effects through mutable state, they are harder to understand. For example, when you usually call <code>f(a, b)</code> in R you can assume that <code>a</code> and <code>b</code> will not be modified; but if <code>a</code> and <code>b</code> are RC objects, they might be modified in the place. Generally, when using RC objects you want to minimise side effects as much as possible, and use them only where mutable state is absolutely required. The majority of functions should still be &quot;<a href="functional-programming.html">functional</a>&quot;, and side effect free. This makes code easier to reason about and easier for other R programmers to understand.</p>

<h1>Environments</h1>

<!-- Comment from reviewer: There's lots of signposting but I cannot say that I sense an underlying logical progression. Maybe there isn't one for this material. But I think it would benefit from an afternoon of contemplation - - can we interest the reader in the details of introducing capabilities of basic environment construction for a) very basic workspace management at the heart of interactive R, b) for the sake of reference semantics for large data objects (this was done in Bioconductor exprSet long
ago) and then c) towards more complicated things like active bindings, with various other things along the way perhaps. -->

<h2>Introduction</h2>

<p>Understanding environment objects is an important next step of understanding scoping. This chapter will teach you:</p>

<ul>
<li>what an environment is and how to inspect and manipulate environments</li>
<li>the four types of environment associated with a function</li>
<li>how to work in an fresh environment outside of a function with <code>local()</code></li>
<li>four ways of binding names to values in an environment</li>
</ul>

<p>The [[functions]] chapter focusses on the essence of how scoping works, where this chapter will focus more on the details and show you how you can implement the behaviour yourself. It also introduces some ideas that will be useful for [[computing on the language]].</p>

<p>This chapter uses many functions found in the <code>pryr</code> package to pry open the covers of R and look inside the messy details.  Install <code>pryr</code> by running <code>devtools::install_github(&quot;pryr&quot;)</code></p>

<h2>Environment basics</h2>

<h3>What is an environment?</h3>

<p>The job of an environment is to associate, or <strong>bind</strong>, a set of names to values. Environments are the data structures that power scoping. An <strong>environment</strong> is very similar to a list, with three important exceptions:</p>

<ul>
<li><p>Environments have reference semantics: R&#39;s usual copy on modify rules do not apply. Whenever you modify an environment, you modify every copy.  </p>

<p>In the following code chunk, we create a new environment, create a &quot;copy&quot; and then modify the original environment. The copy also changes. If you change <code>e</code> to a list (or any other R datastructure) <code>e</code> and <code>f</code> are independent.</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-193"><div class="rcode"><div class="source"><pre class="knitr r">e <- new.env()
f <- e

e$a <- 10
f$a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<p></div></div></p>

<ul>
<li><p>Environments have parents: if an object is not found in an environment, then R can look in its parent (and so on). There is only one exception: the <strong>empty</strong> environment does not have a parent.</p>

<p>We use the family metaphor to refer to other environments: the grandparent of a environment would be the parent&#39;s parent, and the ancestors include all parent environments all the way up to the empty environment. It&#39;s rare to talk about the children of an environment because there are no back links: given an environment we have no way to find its children.</p></li>
<li><p>Every object in an environment must have a name, and the names must be unique.</p></li>
</ul>

<p>Technically, an environment is made up of a <strong>frame</strong>, a collection of named objects (like a list), and a reference to a parent environment.  </p>

<p>As well as powering scoping, environments can be also useful data structures because unlike almost every other type of object in R, modification takes place without a copy. This is not something that you should use without thought: it will violate users&#39; expectations about how R code works, but it can sometimes be critical for high performance code.  However, since the addition of [[R5]], you&#39;re generally better off using reference classes instead of raw environments. Environments can also be used to simulate hashmaps common in other packages, because name lookup is implemented with a hash, which means that lookup is O(1). See the CRAN package hash for an example. </p>

<h3>Manipulating and inspecting environments</h3>

<p>You can create environments with <code>new.env()</code>, see their contents with <code>ls()</code>, and inspect their parent with <code>parent.env()</code>.  </p>

<div class="chunk" id="unnamed-chunk-194"><div class="rcode"><div class="source"><pre class="knitr r">e <- new.env()
# the default parent provided by new.env() is environment from which it is called
parent.env(e) 
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">identical(e, globalenv())
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">ls(e)
</pre></div>

<div class="output"><pre class="knitr r">## character(0)
</pre></div>

<p></div></div></p>

<p>You can modify environments in the same way you modify lists:</p>

<div class="chunk" id="unnamed-chunk-195"><div class="rcode"><div class="source"><pre class="knitr r">ls(e)
</pre></div>

<div class="output"><pre class="knitr r">## character(0)
</pre></div>

<div class="source"><pre class="knitr r">e$a <- 1
ls(e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">e$a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p>By default <code>ls</code> only shows names that don&#39;t begin with <code>.</code>.  Use <code>all.names = TRUE</code> (or <code>all</code> for short) to show all bindings in an environment:</p>

<div class="chunk" id="unnamed-chunk-196"><div class="rcode"><div class="source"><pre class="knitr r">e$.a <- 2
ls(e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">ls(e, all = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"  ".a"
</pre></div>

<p></div></div></p>

<p>Another useful technique to view an environment is to coerce it to a list:</p>

<div class="chunk" id="unnamed-chunk-197"><div class="rcode"><div class="source"><pre class="knitr r">as.list(e)
</pre></div>

<div class="output"><pre class="knitr r">## $a
## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">str(as.list(e))
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ a: num 1
</pre></div>

<div class="source"><pre class="knitr r">str(as.list(e, all.names = TRUE))
</pre></div>

<div class="output"><pre class="knitr r">## List of 2
##  $ a : num 1
##  $ .a: num 2
</pre></div>

<p></div></div></p>

<p>You can extract elements of an environment using <code>$</code> or <code>[[</code>, or <code>get</code>. <code>$</code> and <code>[[</code> will only look in that environment, but <code>get</code> uses the regular scoping rules and will also look in the parent, if needed. <code>$</code> and <code>[[</code> will return <code>NULL</code> if the name is not found, while <code>get</code> returns an error.</p>

<div class="chunk" id="unnamed-chunk-198"><div class="rcode"><div class="source"><pre class="knitr r">e$b <- 2
e$b
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">e[["b"]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">get("b", e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<p></div></div></p>

<p>Deleting objects from environments works a little different to lists.  In a list you can remove an entry by setting it to <code>NULL</code>.  That doesn&#39;t work in environments, and instead you need to use <code>rm()</code>.</p>

<div class="chunk" id="unnamed-chunk-199"><div class="rcode"><div class="source"><pre class="knitr r">e <- new.env()

e$a <- 1
e$a <- NULL
ls(e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">
rm("a", envir = e)
ls(e)
</pre></div>

<div class="output"><pre class="knitr r">## character(0)
</pre></div>

<p></div></div></p>

<p>Generally, when you create your own environment, you want to manually set the parent environment to the empty environment. This ensures you don&#39;t accidentally inherit objects from somewhere else:</p>

<div class="chunk" id="unnamed-chunk-200"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1
e1 <- new.env()
get("x", e1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">
e2 <- new.env(parent = emptyenv())
get("x", e2)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'x' not found
</pre></div>

<p></div></div></p>

<p>You can determine if a binding exists in a environment with the <code>exists()</code> function, but note that the default is to follow the regular scoping rules and will also look in the parent environments.  If you don&#39;t want this behavior, use <code>inherits = FALSE</code>:</p>

<div class="chunk" id="unnamed-chunk-201"><div class="rcode"><div class="source"><pre class="knitr r">exists("b", e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">exists("b", e, inherits = FALSE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">exists("a", e, inherits = FALSE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<h3>Special environments</h3>

<p>There are a few special environments that you can access directly:</p>

<ul>
<li><p><code>globalenv()</code>: the user&#39;s workspace</p></li>
<li><p><code>baseenv()</code>: the environment of the base package</p></li>
<li><p><code>emptyenv()</code>: the ultimate ancestor of all environments, the only environment without a parent.</p></li>
</ul>

<p>The most common environment is the global environment (<code>globalenv()</code>) which corresponds to the top-level workspace. The parent of the global environment is one of the packages you have loaded (the exact order will depend on which packages you have loaded in which order). The eventual parent will be the base environment, which is the environment of &quot;base R&quot; functionality, which has the empty environment as a parent.</p>

<p><code>search()</code> lists all environments in between the global and base environments. This is called the search path, because any object in these environments can be found from the top-level interactive workspace. It contains an environment for each loaded package and for each object (environment, list or Rdata file) that you&#39;ve <code>attach()</code>ed. It also contains a special environment called <code>Autoloads</code> which is used to save memory by only loading package objects (like big datasets) when needed. You can access the environments of any environment on the search list using <code>as.environment()</code>.  </p>

<div class="chunk" id="unnamed-chunk-202"><div class="rcode"><div class="source"><pre class="knitr r">search()
</pre></div>

<div class="output"><pre class="knitr r">##  [1] ".GlobalEnv"             "package:stats4"        
##  [3] "package:methods"        "package:pryr"          
##  [5] "package:Rcpp"           "package:knitrBootstrap"
##  [7] "package:markdown"       "package:knitr"         
##  [9] "package:stats"          "package:graphics"      
## [11] "package:grDevices"      "package:utils"         
## [13] "package:datasets"       "Autoloads"             
## [15] "package:base"
</pre></div>

<div class="source"><pre class="knitr r">as.environment("package:stats")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: package:stats>
## attr(,"name")
## [1] "package:stats"
## attr(,"path")
## [1] "/usr/lib64/R/library/stats"
</pre></div>

<div class="source"><pre class="knitr r">as.environment("package:pryr")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: package:pryr>
## attr(,"name")
## [1] "package:pryr"
## attr(,"path")
## [1] "/SerreDLab/hesterj/R/library/pryr"
</pre></div>

<p></div></div></p>

<h3>Where</h3>

<p>We can apply our new knowledge of environments to create a helpful function called <code>where</code> that tells us the environment where a variable lives:</p>

<div class="chunk" id="unnamed-chunk-203"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
where("where")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: package:pryr>
## attr(,"name")
## [1] "package:pryr"
## attr(,"path")
## [1] "/SerreDLab/hesterj/R/library/pryr"
</pre></div>

<div class="source"><pre class="knitr r">where("mean")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: base>
</pre></div>

<div class="source"><pre class="knitr r">where("t.test")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: package:stats>
## attr(,"name")
## [1] "package:stats"
## attr(,"path")
## [1] "/usr/lib64/R/library/stats"
</pre></div>

<div class="source"><pre class="knitr r">x <- 5
where("x")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<p></div></div></p>

<p><code>where()</code> obeys the regular rules of variable scoping, but instead of returning the value associated with a name, it returns the environment in which it was defined. </p>

<p>The definition of <code>where()</code> is fairly straightforward. It has two arguments; the name to look for (as a string), and the environment in which to start the search. (We&#39;ll learn later why <code>parent.frame()</code> is a good default.)</p>

<div class="chunk" id="unnamed-chunk-204"><div class="rcode"><div class="source"><pre class="knitr r">where
</pre></div>

<div class="output"><pre class="knitr r">## function(name, env = parent.frame()) {
##   stopifnot(is.character(name), length(name) == 1)
##   env <- to_env(env)
## 
##   if (identical(env, emptyenv())) {
##     stop("Can't find ", name, call. = FALSE)
##   }
## 
##   if (exists(name, env, inherits = FALSE)) {
##     env
##   } else {
##     where(name, parent.env(env))
##   }
## }
## <environment: namespace:pryr>
</pre></div>

<p></div></div></p>

<p>It&#39;s natural to work with environments recursively, so we&#39;ll see this style of function structure frequently. There are three main components: </p>

<ul>
<li><p>the base case (what happens when we&#39;ve recursed down to the empty environment)</p></li>
<li><p>a boolean that determines if we&#39;ve found what we wanted, and </p></li>
<li><p>the recursive statement that re-calls the function using the parent of the current environment. </p></li>
</ul>

<p>If we remove all the details of where, and just keep the structure, we get a function that looks like this:</p>

<div class="chunk" id="unnamed-chunk-205"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(..., env = parent.frame()) {
  if (identical(env, emptyenv())) {
    # base case
  }

  if (success) {
    # return value
  } else {
    # inspect parent
    f(..., env = parent.env(env))
  }
}
</pre></div>

<p></div></div></p>

<p>Note that to check if the environment is the same as the empty environment, we need to use <code>identical()</code>: this performs a whole object comparison, unlike the element-wise <code>==</code>.</p>

<p>It is also possible to write this function with a loop instead of with recursion. This might run slightly faster (because we eliminate some function calls), but I find it harder to understand what&#39;s going on. I include it because you might find it easier to see what&#39;s happening if you&#39;re less familiar with recursive functions.</p>

<div class="chunk" id="unnamed-chunk-206"><div class="rcode"><div class="source"><pre class="knitr r">is.emptyenv <- function(x) identical(x, emptyenv())

f2 <- function(..., env = parent.frame()) {
  while(!is.emptyenv(env)) {
    if (success) {
      # return value
      return()
    }
    # inspect parent
    env <- parent.env(env)
  }

  # base case
}
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>Using <code>parent.env()</code> and a loop (or a recursive function), verify that the ancestors of <code>globalenv()</code> include <code>baseenv()</code> and <code>emptyenv()</code>.  Use the same basic idea to implement your own version of <code>search()</code>.</p></li>
<li><p>Write your own version of <code>get()</code> using a function written in the style of <code>where()</code>.  </p></li>
<li><p>Write a function called <code>fget()</code> that finds only function objects. It should have two arguments, <code>name</code> and <code>env</code>, and should obey the regular scoping rules for functions: if there&#39;s an object with a matching name that&#39;s not a function, look in the parent. (This function should be a equivalent to <code>match.fun()</code> extended to take a second argument). For an added challenge, also add an <code>inherits</code> argument which controls whether the function recurses down the parents or only looks in one environment.</p></li>
<li><p>Write your own version of <code>exists(inherits = FALSE)</code> (Hint: use <code>ls()</code>).  Write a recursive version that behaves like <code>inherits = TRUE</code>.</p></li>
</ul>

<h2>Function environments</h2>

<p>Most of the time when you are working with environments, you will not create them directly, but they will be created as a consequence of working with functions. This section discuss the four types of environment associated with a function.</p>

<p>There are multiple environments associated with each function, and it&#39;s easy to get confused between them. </p>

<ul>
<li>the environment where the function was created</li>
<li>the environment where the function lives</li>
<li>the environment that&#39;s created every time a function is run</li>
<li>the environment where a function is called from</li>
</ul>

<p>The following sections will explain why each of these environments are important, how to access them, and how you might use them.</p>

<h3>The environment where the function was created</h3>

<p>When a function is created, it gains a reference to the environment where it was made. This is the parent, or enclosing, environment of the function used by lexical scoping. You can access this environment with the <code>environment()</code> function:</p>

<div class="chunk" id="unnamed-chunk-207"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1
f <- function(y) x + y
environment(f)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">
environment(plot)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: 0x1fa52280>
</pre></div>

<div class="source"><pre class="knitr r">environment(t.test)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: namespace:stats>
</pre></div>

<p></div></div></p>

<p>To make a function an equivalent function that is safer (it throws an error if the input isn&#39;t a function), more consistent (can take a function name as an argument not just a function), and more informative (better name), we&#39;ll create <code>funenv()</code>:</p>

<div class="chunk" id="unnamed-chunk-208"><div class="rcode"><div class="source"><pre class="knitr r">funenv <- function(f) {
  f <- match.fun(f)
  environment(f)
}
funenv("plot")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: 0x1fa52280>
</pre></div>

<div class="source"><pre class="knitr r">funenv("t.test")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: namespace:stats>
</pre></div>

<p></div></div></p>

<p>Unsurprisingly, the enclosing environment is particularly important for closures:</p>

<div class="chunk" id="unnamed-chunk-209"><div class="rcode"><div class="source"><pre class="knitr r">plus <- function(x) {
  function(y) x + y 
}
plus_one <- plus(1)
plus_one(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 11
</pre></div>

<div class="source"><pre class="knitr r">plus_two <- plus(2)
plus_one(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 11
</pre></div>

<div class="source"><pre class="knitr r">environment(plus_one)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: 0x20158600>
</pre></div>

<div class="source"><pre class="knitr r">parent.env(environment(plus_one))
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">environment(plus_two)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: 0x1febb6c8>
</pre></div>

<div class="source"><pre class="knitr r">parent.env(environment(plus_two))
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">environment(plus)
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">str(as.list(environment(plus_one)))
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ x: num 1
</pre></div>

<div class="source"><pre class="knitr r">str(as.list(environment(plus_two)))
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ x: num 2
</pre></div>

<p></div></div></p>

<p>It&#39;s also possible to modify the environment of a function, using the assignment form of <code>environment</code>. This is rarely useful, but we can use it to illustrate how fundamental scoping is to R. One complaint that people sometimes make about R is that the function <code>f</code> defined above really should generate an error, because there is no variable <code>y</code> defined inside of R.  Well, we could fix that by manually modifying the environment of <code>f</code> so it can&#39;t find y inside the global environment:</p>

<div class="chunk" id="unnamed-chunk-210"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) x + y
environment(f) <- emptyenv()
f(1)
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "+"
</pre></div>

<p></div></div></p>

<p>But when we run it, we don&#39;t get the error we expect. Because R uses its scoping rules consistently for everything (including looking up functions), we get an error that <code>f</code> can&#39;t find the <code>+</code> function. (See the discussion in [[scoping]] for alternatives that actually work).</p>

<h3>The environment where the function lives</h3>

<p>The environment of a function, and the environment where it lives might be different. In the example above, we changed the environment of <code>f</code> to be the <code>emptyenv()</code>, but it still lived in the <code>globalenv()</code>:</p>

<div class="chunk" id="unnamed-chunk-211"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) x + y
funenv("f")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">where("f")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">environment(f) <- emptyenv()
funenv("f")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_EmptyEnv>
</pre></div>

<div class="source"><pre class="knitr r">where("f")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<p></div></div></p>

<p>The environment where the function lives determines how we find the function, the environment of the function determins how it finds values inside the function. This important distinction is what enables package [[namespaces]] to work.</p>

<p>For example, take <code>t.test()</code>:</p>

<div class="chunk" id="unnamed-chunk-212"><div class="rcode"><div class="source"><pre class="knitr r">funenv("t.test")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: namespace:stats>
</pre></div>

<div class="source"><pre class="knitr r">where("t.test")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: package:stats>
## attr(,"name")
## [1] "package:stats"
## attr(,"path")
## [1] "/usr/lib64/R/library/stats"
</pre></div>

<p></div></div></p>

<p>We find <code>t.test()</code> in the <code>package::stats</code> environment, but its parent (where it looks up values) is the <code>namespace::stats</code> environment. The <em>package</em> environment contains only functions and objects that should be visible to the user, but the <em>namespace</em> environment contains both internal and external functions. There are over 400 objects that a defined in the <code>stats</code> package 
but not available to the user:</p>

<div class="chunk" id="unnamed-chunk-213"><div class="rcode"><div class="source"><pre class="knitr r">length(ls(funenv("t.test")))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1088
</pre></div>

<div class="source"><pre class="knitr r">length(ls(where("t.test")))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 493
</pre></div>

<p></div></div></p>

<p>This mechanism makes it possible for packages to have internal objects that can be accessed by its functions, but not by external functions.</p>

<h3>The environment created every time a function is run</h3>

<p>Recall how function scoping works. What will the following function will return the first time we run it?  What about the second?</p>

<div class="chunk" id="unnamed-chunk-214"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  if (!exists("a", inherits = FALSE)) {
    message("Defining a")
    a <- 1
  } else {
    a <- a + 1 
  }
  a
}
f()
</pre></div>

<div class="message"><pre class="knitr r">## Defining a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p>You should recall that it returns the same value every time. This is because every time a function is called, a new environment is created to host execution. We can see this more easily by returning the environment inside the function: using <code>environment()</code> with no arguments returns the current environment (try running it at the top level). Each time you run the function a new function is created. But they all have the same parent environment, the environment where the function was created.</p>

<div class="chunk" id="unnamed-chunk-215"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  list(
    e = environment(),
    p = parent.env(environment())
  )
}
str(f())
</pre></div>

<div class="output"><pre class="knitr r">## List of 2
##  $ e:<environment: 0x1fa3aef0> 
##  $ p:<environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">str(f())
</pre></div>

<div class="output"><pre class="knitr r">## List of 2
##  $ e:<environment: 0x1f9070a8> 
##  $ p:<environment: R_GlobalEnv>
</pre></div>

<div class="source"><pre class="knitr r">funenv("f")
</pre></div>

<div class="output"><pre class="knitr r">## <environment: R_GlobalEnv>
</pre></div>

<p></div></div></p>

<h3>The environment where the function was called</h3>

<p>Look at the following code. What do you expect <code>g()</code> to return when the code is run?</p>

<div class="chunk" id="unnamed-chunk-216"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() {
  x <- 10
  function() {
    x
  }
}
g <- f()
x <- 20
g()
</pre></div>

<p></div></div></p>

<p>The top-level <code>x</code> is a red herring: using the regular scoping rules, <code>g()</code> looks first where it is defined and finds the value of <code>x</code> is 10.  However, it is still meaningful to ask what value <code>x</code> is associated in the environment where <code>g()</code> is called. <code>x</code> is 10 in the environment where <code>g()</code> is defined, but it is 20 in the environment from which <code>g()</code> is <strong>called</strong>.  </p>

<p>We can access this environment using the confusingly named <code>parent.frame()</code>. This function returns the <strong>environment</strong> from which the function was called. We can use that to look up the value of names in the environment from which the funtion was called.</p>

<div class="chunk" id="unnamed-chunk-217"><div class="rcode"><div class="source"><pre class="knitr r">f2 <- function() {
  x <- 10
  function() {
    def <- get("x", environment())
    cll <- get("x", parent.frame())
    list(defined = def, called = cll)
  }
}
g2 <- f2()
x <- 20
str(g2())
</pre></div>

<div class="output"><pre class="knitr r">## List of 2
##  $ defined: num 10
##  $ called : num 20
</pre></div>

<p></div></div></p>

<p>In more complicated scenarios, there&#39;s not just one parent call, but a sequence of calls all the way back to the initiating function, called from the top-level. We can get a list of all calling environments using <code>sys.frames()</code></p>

<div class="chunk" id="unnamed-chunk-218"><div class="rcode"><div class="source"><pre class="knitr r">y <- 10
f <- function(x) {
  x <- 1
  g(x)
}
g <- function(x) {
  x <- 2
  h(x)
}
h <- function(x) {
  x <- 3
  i(x)
}
i <- function(x) {
  x <- 4
  sys.frames()
}

es <- f()
sapply(es, function(e) get("x", e))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 20
## 
## [[2]]
## [1] 20
## 
## [[3]]
## [1] 20
## 
## [[4]]
## [1] 20
## 
## [[5]]
## $params
## $params$child
## [1] "no_pandoc/Environments.rmd"
## 
## $params$label
## [1] "unnamed-chunk-7"
## 
## 
## $params.src
## [1] "child='no_pandoc/Environments.rmd'"
## 
## attr(,"class")
## [1] "block"
## 
## [[6]]
## $params
## $params$child
## [1] "no_pandoc/Environments.rmd"
## 
## $params$label
## [1] "unnamed-chunk-7"
## 
## 
## $params.src
## [1] "child='no_pandoc/Environments.rmd'"
## 
## attr(,"class")
## [1] "block"
## 
## [[7]]
## [1] 20
## 
## [[8]]
## [1] 20
## 
## [[9]]
## [1] 20
## 
## [[10]]
## [1] 20
## 
## [[11]]
## [1] 20
## 
## [[12]]
## [1] 20
## 
## [[13]]
## $params
## $params$label
## [1] "unnamed-chunk-218"
## 
## 
## $params.src
## [1] ""
## 
## attr(,"class")
## [1] "block"
## 
## [[14]]
## $params
## $params$label
## [1] "unnamed-chunk-218"
## 
## 
## $params.src
## [1] ""
## 
## attr(,"class")
## [1] "block"
## 
## [[15]]
## [1] 20
## 
## [[16]]
## [1] 20
## 
## [[17]]
## [1] 20
## 
## [[18]]
## [1] 20
## 
## [[19]]
## [1] 20
## 
## [[20]]
## [1] 20
## 
## [[21]]
## [1] 20
## 
## [[22]]
## [1] 20
## 
## [[23]]
## [1] 20
## 
## [[24]]
## [1] 20
## 
## [[25]]
## [1] 20
## 
## [[26]]
## [1] 20
## 
## [[27]]
## [[27]][[1]]
## <environment: 0x1d953f60>
## 
## [[27]][[2]]
## <environment: 0x1db44678>
## 
## [[27]][[3]]
## <environment: 0x1dc57d20>
## 
## [[27]][[4]]
## <environment: 0x1f8304c8>
## 
## [[27]][[5]]
## <environment: 0x1f82fb48>
## 
## [[27]][[6]]
## <environment: 0x1f82ef60>
## 
## [[27]][[7]]
## <environment: 0x1f82f200>
## 
## [[27]][[8]]
## <environment: 0x1f3c14a8>
## 
## [[27]][[9]]
## <environment: 0x1f380cd0>
## 
## [[27]][[10]]
## <environment: 0x1f37c6d8>
## 
## [[27]][[11]]
## <environment: 0x1ea8a3e8>
## 
## [[27]][[12]]
## <environment: 0x20d72570>
## 
## [[27]][[13]]
## <environment: 0x20d45be8>
## 
## [[27]][[14]]
## <environment: 0x20d45f30>
## 
## [[27]][[15]]
## <environment: 0x20d451f8>
## 
## [[27]][[16]]
## <environment: 0x212af8e0>
## 
## [[27]][[17]]
## <environment: 0x209a74a0>
## 
## [[27]][[18]]
## <environment: 0x209a6670>
## 
## [[27]][[19]]
## <environment: 0x202217f8>
## 
## [[27]][[20]]
## <environment: 0x1ff164c0>
## 
## [[27]][[21]]
## <environment: 0x1ff16680>
## 
## [[27]][[22]]
## <environment: 0x1ff16878>
## 
## [[27]][[23]]
## <environment: 0x1ff15fd8>
## 
## [[27]][[24]]
## <environment: 0x1ff153b8>
## 
## [[27]][[25]]
## <environment: 0x1ff15700>
## 
## [[27]][[26]]
## <environment: 0x1ff14630>
## 
## [[27]][[27]]
## <environment: 0x1ff13d58>
## 
## [[27]][[28]]
## <environment: 0x1ff13fc0>
## 
## [[27]][[29]]
## <environment: R_GlobalEnv>
## 
## [[27]][[30]]
## <environment: 0x1ff14110>
## 
## [[27]][[31]]
## <environment: 0x1ff14228>
## 
## [[27]][[32]]
## <environment: 0x1ff133d8>
## 
## [[27]][[33]]
## <environment: 0x1ff134f0>
## 
## 
## [[28]]
## [1] 20
## 
## [[29]]
## [1] 20
## 
## [[30]]
## [1] 1
## 
## [[31]]
## [1] 2
## 
## [[32]]
## [1] 3
## 
## [[33]]
## [1] 4
</pre></div>

<div class="source"><pre class="knitr r"># [1] 1 2 3 4
sapply(es, function(e) get("y", e))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
## [24] 10 10 10 10 10 10 10 10 10 10
</pre></div>

<div class="source"><pre class="knitr r"># [1] 10 10 10 10
</pre></div>

<p></div></div></p>

<p>There are two separate strands of parents when a function is called: the calling environments, and the enclosing environments. Each calling environment will also have a stack of enclosing environments. Note that while called function has both a stack of called environemnts and a stack of enclosing environments, an environment (or a function object) has only a stack of enclosing environments.</p>

<p>Looking up variables in the calling environment rather than in the defining argument is called <strong>dynamic scoping</strong>.  Few languages implement dynamic scoping (emac&#39;s lisp is a <a href="http://www.gnu.org/software/emacs/emacs-paper.html#SEC15">notable exception</a>) because dynamic scoping makes it much harder to reason about how a function operates: not only do you need to know how it was defined, you also need to know in what context it was called.  Dynamic scoping is primarily useful for developing functions that aid interactive data analysis, and is one of the topics discussed in [[controlling evaluation]]</p>

<h3>Exercises</h3>

<ul>
<li><p>Write an enhanced version of <code>str()</code> that provides more information about functions: show where the function was found and what environment it was defined in. Can you list objects that the function will be able to access but the user of the function cannot?</p></li>
<li></li>
</ul>

<h2>Explicit scoping with <code>local</code></h2>

<p>Sometimes it&#39;s useful to be able to create a new scope without embedding inside a function.  The <code>local</code> function allows you to do exactly that - it can be useful if you need some temporary variables to make an operation easier to understand, but want to throw them away afterwards:</p>

<div class="chunk" id="unnamed-chunk-219"><div class="rcode"><div class="source"><pre class="knitr r">df <- local({
  x <- 1:10
  y <- runif(10)
  data.frame(x = x, y = y)
})
</pre></div>

<p></div></div></p>

<p>This is equivalent to:</p>

<div class="chunk" id="unnamed-chunk-220"><div class="rcode"><div class="source"><pre class="knitr r">df <- (function() {
  x <- 1:10
  y <- runif(10)
  data.frame(x = x, y = y)
})()
</pre></div>

<p></div></div></p>

<p>(If you&#39;re familiar with javascript you&#39;ve probably seen this pattern before: it&#39;s the immediately invoked function expression (IIFE) used extensively by most javascript libraries to avoid polluting the global namespace.)</p>

<p><code>local</code> has relatively limited uses (typically because most of the time scoping is best accomplished using R&#39;s regular function based rules) but it can be particularly useful in conjunction with <code>&lt;&lt;-</code>. You can use this if you want to make a private variable that&#39;s shared between two functions:</p>

<div class="chunk" id="unnamed-chunk-221"><div class="rcode"><div class="source"><pre class="knitr r">a <- 10
my_get <- NULL
my_set <- NULL
local({
  a <- 1
  my_get <<- function() a
  my_set <<- function(value) a <<- value
})
my_get()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">my_set(10)
a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<div class="source"><pre class="knitr r">my_get()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<p></div></div></p>

<p>However, it can be easier to see what&#39;s going on if you avoid the implicit environment and create and access it explicitly:</p>

<div class="chunk" id="unnamed-chunk-222"><div class="rcode"><div class="source"><pre class="knitr r">my_env <- new.env(parent = emptyenv())
my_env$a <- 1
my_get <- function() my_env$a
my_set <- function(value) my_env$a <- value
</pre></div>

<p></div></div></p>

<p>These techniques are useful if you want to store state in your package.</p>

<h2>Assignment: binding names to values</h2>

<p>Assignment is the act of binding (or rebinding) a name to a value in an environment. It is the counterpart to scoping, the set of rules that determines how to find the value associated with a name. Compared to most languages, R has extremely flexible tools for binding names to values. In fact, you can not only bind values to names, but you can also bind expressions (promises) or even functions, so that every time you access the value associated with a name, you get something different!</p>

<p>The remainder of this section will discuss the four main ways of binding names to values in R:</p>

<ul>
<li><p>With the regular behaviour, <code>name &lt;- value</code>, the name is immediately associated with the value in the current environment. <code>assign(&quot;name&quot;, value)</code> works similarly, but allows assignment in any environment.</p></li>
<li><p>The double arrow, <code>name &lt;&lt;- value</code>, assigns in a similar way to variable lookup, so that <code>i &lt;&lt;- i + 1</code> modifies the binding of the original <code>i</code>, which is not necessarily in the current environment.</p></li>
<li><p>Lazy assignment, <code>delayedAssign(&quot;name&quot;, expression)</code>, binds an expression isn&#39;t evaluated until you look up the name.</p></li>
<li><p>Active assignment, <code>makeActiveBinding(&quot;name&quot;, function)</code> binds the name to a function, so it is &quot;active&quot; and can return different a value each time the name is found.</p></li>
</ul>

<h3>Regular binding</h3>

<p>You have probably used regular assignment in R thousands of times. Regular assignment immediately creates a binding between a name and a value in the current environment. </p>

<p>There are two types of names: syntactic and non-syntactic. Generally, syntactic names consist of letters, digits, <code>.</code> and <code>_</code>, and must start with a letter or <code>.</code> not followed by a number (so <code>.a</code> and <code>._</code> are syntactic but <code>.1</code> is not).  There are also a number of reserved words (e.g. <code>TRUE</code>, <code>NULL</code>, <code>if</code>, <code>function</code>, see <code>make.names()</code>).  A syntactic name can be used on the left hand side of <code>&lt;-</code>:</p>

<div class="chunk" id="unnamed-chunk-223"><div class="rcode"><div class="source"><pre class="knitr r">a <- 1
._ <- 2
a_b <- 3
</pre></div>

<p></div></div></p>

<p>However, a name can actually be any sequence of characters; if it&#39;s non-syntactic you just need to do a little more work:</p>

<div class="chunk" id="unnamed-chunk-224"><div class="rcode"><div class="source"><pre class="knitr r">`a + b` <- 3
`:)` <- "smile" 
`    ` <- "spaces"
ls()
#  [1] "    "   ":)"     "a + b" 
</pre></div>

<p></div></div></p>

<p><code>&lt;-</code> creates a binding in the current environment. There are three techniques to create a binding in another environmnent:</p>

<ul>
<li>treating an environment like a list</li>
</ul>

<div class="chunk" id="unnamed-chunk-225"><div class="rcode"><div class="source"><pre class="knitr r">e <- new.env()
e$a <- 1
</pre></div>

<p></div></div></p>

<ul>
<li>use <code>assign()</code>, which has three important arguments: the name, the value, and the environment in which to create the binding</li>
</ul>

<div class="chunk" id="unnamed-chunk-226"><div class="rcode"><div class="source"><pre class="knitr r">e <- new.env()
assign("a", 1, envir = e)
</pre></div>

<p></div></div></p>

<ul>
<li>evaluate <code>&lt;-</code> inside the environment. (More on this in [[evaluation]])</li>
</ul>

<div class="chunk" id="unnamed-chunk-227"><div class="rcode"><div class="source"><pre class="knitr r">e <- new.env()

eval(quote(a <- 1), e)
# alternatively, you can use the helper function evalq
# evalq(x, e) is exactly equivalent to eval(quote(x), e)
evalq(a <- 1, e)
</pre></div>

<p></div></div></p>

<p>I generally prefer to use the first form because it is so compact. However, you&#39;ll see all three forms in R code in the wild.</p>

<h4>Constants</h4>

<p>There&#39;s one extension to regular binding: constants. What are constants? They&#39;re variable whose values can not be changed; they can only be bound once, and never re-bound. We can simulate constants in R using <code>lockBinding</code>, or the infix <code>%&lt;c-%</code> found in pryr:</p>

<div class="chunk" id="unnamed-chunk-228"><div class="rcode"><div class="source"><pre class="knitr r">x <- 10
lockBinding(as.name("x"), globalenv())
x <- 15
</pre></div>

<div class="error"><pre class="knitr r">## Error: cannot change value of locked binding for 'x'
</pre></div>

<div class="source"><pre class="knitr r">rm(x)

x %<c-% 20 #>
x <- 30
</pre></div>

<div class="error"><pre class="knitr r">## Error: cannot change value of locked binding for 'x'
</pre></div>

<div class="source"><pre class="knitr r">rm(x)
</pre></div>

<p></div></div></p>

<p><code>lockBinding()</code> is used to prevent you from modifying objects inside packages:</p>

<div class="chunk" id="unnamed-chunk-229"><div class="rcode"><div class="source"><pre class="knitr r">assign("mean", function(x) sum(x) / length(x), env = baseenv())
</pre></div>

<div class="error"><pre class="knitr r">## Error: cannot change value of locked binding for 'mean'
</pre></div>

<p></div></div></p>

<h3><code>&lt;&lt;-</code></h3>

<p>Another way to modify the binding between name and value is <code>&lt;&lt;-</code>. The regular assignment arrow, <code>&lt;-</code>, always creates a variable in the current environmnt. The special assignment arrow, <code>&lt;&lt;-</code>, never creates a variable in the current environment, but instead modifies an existing variable found by walking up the parent environments. </p>

<div class="chunk" id="unnamed-chunk-230"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() {
  g <- function() {
    x <<- 2
  }
  x <- 1
  g()
  x
}
f()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">
h <- function() {
  x <- 1
  x <<- 2
  x
}
h()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<p></div></div></p>

<p>If <code>&lt;&lt;-</code> doesn&#39;t find an existing variable, it will create one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions.</p>

<p><code>name &lt;&lt;- value</code> is equivalent to <code>assign(&quot;name&quot;, value, inherits = TRUE)</code>.</p>

<p>To give you more idea how this works, we could implement <code>&lt;&lt;-</code> ourselves. I&#39;m going to call it <code>rebind</code>, and emphasise that it&#39;s normally used to modify an existing binding. We&#39;ll implement it with our recursive recipe for working with environments. For the base case, we&#39;ll throw an error (where <code>&lt;&lt;-</code> would assign in the global environment), which emphasises the rebinding nature of this function. Otherwise we check to see if the name is found in the current environment: if it is, we do the assignment there; if not, we recurse.</p>

<div class="chunk" id="unnamed-chunk-231"><div class="rcode"><div class="source"><pre class="knitr r">rebind <- function(name, value, env = parent.frame()) {
  if (identical(env, emptyenv())) {
    stop("Can't find ", name, call. = FALSE)
  }

  if (exists(name, env, inherits = FALSE)) {
    assign(name, value, env)
  } else {
    rebind(value, parent.env(env))
  }
}
rebind("a", 10)
a <- 5
rebind("a", 10)
a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<div class="source"><pre class="knitr r">
f <- function() {
  g <- function() {
    rebind("x", 2)
  }
  x <- 1
  g()
  x
}
f()
</pre></div>

<div class="error"><pre class="knitr r">## Error: invalid first argument
</pre></div>

<p></div></div></p>

<p>We&#39;ll come back to this idea in depth, and see where it is useful in [[functional programming]].</p>

<h3>Delayed bindings</h3>

<p>Another special type of assignment is a delayed binding: rather than assigning the result of an expression immediately, it creates and stores a promise to evaluate the expression when needed (much like the default lazy evaluation of arguments in R functions). We can create delayed bindings with the special assignment operator <code>%&lt;d-%</code>, provided by the pryr package.</p>

<div class="chunk" id="unnamed-chunk-232"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
</pre></div>

<div class="error"><pre class="knitr r">## Error: there is no package called 'pryr'
</pre></div>

<div class="source"><pre class="knitr r">a %<d-% 1
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "%<d-%"
</pre></div>

<div class="source"><pre class="knitr r">system.time(a)
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0       0
</pre></div>

<div class="source"><pre class="knitr r">b %<d-% {Sys.sleep(1); 1}
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "%<d-%"
</pre></div>

<div class="source"><pre class="knitr r">system.time(b)
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0       0
</pre></div>

<p></div></div></p>

<p>Note that we need to be careful with more complicated expressions because user created infix functions have the lowest possible precendence: <code>x %&lt;d-% a + b</code> is interpreted as <code>(x %&lt;d-% a) + b</code>, so we need to use parentheses ourselves:</p>

<div class="chunk" id="unnamed-chunk-233"><div class="rcode"><div class="source"><pre class="knitr r">x %<d-% (a + b)
a <- 5
b <- 5
a + b
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<p></div></div></p>

<p><code>%&lt;d-%</code> is a wrapper around the base <code>delayedAssign()</code> function, which you may need to use directly if you need more control. <code>delayedAssign()</code> has four parameters:</p>

<ul>
<li><code>x</code>: a variable name given as a quoted string</li>
<li><code>value</code>: an unquoted expression to be assigned to x</li>
<li><code>eval.env</code>: the environment in which to evaluate the expression</li>
<li><code>assign.env</code>: the environment in which to create the binding</li>
</ul>

<p>Writing <code>%&lt;d-%</code> is straightforward, bearing in mind that <code>makeActiveBinding</code> uses non-standard evaluation to capture the representation of the second argument, so we need to use substitute to construct the call manually. Once you&#39;ve read [[computing on the language]], you might want to read the source code and think about how it works.</p>

<p>One application of <code>delayedAssign</code> is <code>autoload</code>, a function that powers <code>library()</code>. <code>autoload</code> makes R behave as if the code and data in a package is loaded in memory, but it doesn&#39;t actually do any work until you call one of the functions or access a dataset. This is the way that data sets in most packages work - you can call (e.g.) <code>diamonds</code> after <code>library(ggplot2)</code> and it just works, but it isn&#39;t loaded into memory unless you actually use it.</p>

<h3>Active bindings</h3>

<p>You can create <strong>active</strong> bindings where the value is recomputed every time you access the name:</p>

<div class="chunk" id="unnamed-chunk-234"><div class="rcode"><div class="source"><pre class="knitr r">x %<a-% runif(1)
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.7072
</pre></div>

<div class="source"><pre class="knitr r">x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.2778
</pre></div>

<p></div></div></p>

<p><code>%&lt;a-%</code> is a wrapper for the base function <code>makeActiveBinding()</code>. You may want to use this function directly if you want more control. It has three arguments:</p>

<ul>
<li><code>sym</code>: a variable name, represented as a name object or a string</li>
<li><code>fun</code>: a single argument function. Getting the value of <code>sym</code> calls <code>fun</code> with zero arguments, and setting the value of <code>sym</code> calls <code>fun</code> with one argument, the value.</li>
<li><code>env</code>: the environment in which to create the binding.</li>
</ul>

<h3>Exercises</h3>

<ul>
<li><p>In <code>rebind()</code> it&#39;s unlikely that we want to assign in an ancestor of the global environment (i.e. a loaded package), so modify the function to avoid recursing past the global environment.</p></li>
<li><p>Create a version of <code>assign()</code> that will only bind new names, never re-bind old names.  Some programming languages only do this, and are known as <a href="http://en.wikipedia.org/wiki/Assignment_(computer_science">single assignment</a>#Single_assignment) languages.</p></li>
<li><p>Write an alternative to <code>&lt;-</code> that never overrides an existing binding.  This would be useful if you running a test script multiple times and only want to generate the test data once.</p></li>
<li><p>Implement <code>str</code> for environments, listing all bindings in the environment, and briefly describing their contents (you might want to use <code>str</code> recursively). Use <code>bindingIsActive()</code> to determine if a binding is active. Indicate if bindings are locked (see <code>bindingIsLocked()</code>). Show the expressions (not the results) for delayed bindings (see the help for <code>delayedAssign</code> for hints).  Show the amount of memory the environment occupies using <code>object.size()</code></p></li>
<li><p>Write an assignment function that can do active, delayed and locked bindings. What might you call it? What arguments should it take? Can you guess which sort of assignment it should do based on the expression?</p></li>
</ul>

<h1>Exceptions and debugging</h1>

<!-- http://www.noamross.net/blog/2013/4/18/r-debug-tools.html -->

<p>This chapter describes techniques to use when things go wrong:</p>

<ul>
<li><p>Debugging: figuring out what went wrong.</p></li>
<li><p>Exceptions: the set of objects that underlies error handling in R.</p></li>
<li><p>Defensive programming: writing </p></li>
</ul>

<p>As with many other parts of R, the approach to dealing with errors and exceptions comes from a LISP-heritage, and is quite different (although some of the terminology is the same) from that of languages like Java.</p>

<h2>Debugging</h2>

<p>This section discusses how to debug from the command-line.  Modern R guis, like Rstudio, also provide built in debugging tools. These are built on top of the tools I&#39;ll describe below but may be exposed in a more user friendly way that requires less typing.</p>

<h3>Traceback</h3>

<p>The key function for performing a post-mortem on an error is <code>traceback</code>, which shows all the calls leading up to the error.  Here&#39;s an example:</p>

<div class="chunk" id="unnamed-chunk-235"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() g()
g <- function() h()
h <- function() i()
i <- function() "a" + 1
f()
</pre></div>

<div class="error"><pre class="knitr r">## Error: non-numeric argument to binary operator
</pre></div>

<div class="source"><pre class="knitr r"># Error in "a" + 1 : non-numeric argument to binary operator
traceback()
</pre></div>

<div class="output"><pre class="knitr r">## No traceback available
</pre></div>

<div class="source"><pre class="knitr r"># 4: i() at #1
# 3: h() at #1
# 2: g() at #1
# 1: f()
</pre></div>

<p></div></div></p>

<p>This is very helpful to determine exactly where in a stack of calls an error occured.  However, it&#39;s not so helpful if you have a recursive function, or other situations where the same function is called in multiple places:</p>

<div class="chunk" id="unnamed-chunk-236"><div class="rcode"><div class="source"><pre class="knitr r">j <- function(i = 5) {
  if (i == 1) "a" + 1
  j(i - 1)
}
j()
# Error in "a" + 1 : non-numeric argument to binary operator
traceback()
# 5: j(i - 1) at #3
# 4: j(i - 1) at #3
# 3: j(i - 1) at #3
# 2: j(i - 1) at #3
# 1: j()
</pre></div>

<p></div></div></p>

<h3>Browser</h3>

<p>Trackback can help you figure out where the error occurred, but to understand why the error occured and to fix it, it&#39;s often easier to explore interactively.  <code>browser()</code> allows you to do this by pausing execution and returning you to an interactive state. Here you can run any regular R command, as well as some extra single letter commands:</p>

<ul>
<li><p><code>c</code>: leave interactive debugging and continue execution</p></li>
<li><p><code>n</code>: execute the next step. Be careful if you have a variable named <code>n</code>: to
print it you&#39;ll need to be explicit <code>print(n)</code>.</p></li>
<li><p><code>\n</code>: the default behaviour is the same as <code>c</code>, but this is somewhat
dangerous as it makes it very easy to accidentally continue during
debugging. I recommend <code>options(browserNLdisabled = TRUE)</code> so that a new
line is simply ignored.</p></li>
<li><p><code>Q</code>: stops debugging, terminate the function and return to the global
workspace</p></li>
<li><p><code>where</code>: prints stack trace of active calls (the interactive equivalent of
<code>traceback</code>)</p></li>
</ul>

<p>Don&#39;t forget that you can combine <code>if</code> statements with <code>browser()</code> to only debug when a certain situation occurs.</p>

<h3>Browsing arbitrary R code</h3>

<p>As well as adding <code>browser()</code> yourself, there are two functions that will added it to code:</p>

<ul>
<li><p><code>debug()</code> inserts a browser statement in the first line of the specified
function. <code>undebug</code> will remove it, or you can use <code>debugonce</code> to insert a
browser call for the next run, and have it automatically removed afterwards.</p></li>
<li><p><code>utils::setBreakpoint()</code> does the same thing, but instead inserts <code>browser()</code>
in the function corresponding to the specified file name and line number.</p></li>
</ul>

<p>These two functions are both special cases of <code>trace()</code>, which allows you to insert arbitrary code in any position in an existing function. The complement of <code>trace()</code> is <code>untrace()</code>. You can only perform one trace per function - subsequent traces will replace prior.</p>

<p>Locating warnings is a little trickier. The easiest way to turn it in an error with <code>options(warn = 2)</code> and then use the standard functions described above. Turn back to default behaviour with <code>options(warn = 0)</code>.</p>

<h3>Browsing on error</h3>

<p>It&#39;s also possible to  start <code>browser</code> automatically when an error occurs, by setting <code>options(error = browser)</code>. This will start the interactive debugger in the environment in which the error occurred. Other functions that you can supply to <code>error</code> are:</p>

<ul>
<li><p><code>recover</code>: a step up from <code>browser</code>, as it allows you to drill down into any
of the calls in the call stack. This is useful because often the cause of
the error is a number of calls back - you&#39;re just seeing the consequences.
This is the result of &quot;fail-slow&quot; code</p></li>
<li><p><code>dump.frames</code>: an equivalent to <code>recover</code> for non-interactive code. Will
save an <code>rdata</code> file containing the nested environments where the error
occurred. This allows you to later use <code>debugger</code> to re-create the error as
if you had called <code>recover</code> from where the error occurred</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-237"><div class="rcode"><div class="source"><pre class="knitr r"># Saves debugging info to file last.dump.rda
options(error = quote({dump.frames(to.file = TRUE); q()}))

# Then in an interactive R session:
print(load("last.dump.rda"))
debugger("last.dump")
</pre></div>

<p></div></div></p>

<ul>
<li><code>NULL</code>: the default. Prints an error message and stops function execution.
Use this to reset back to the regular behaviour.</li>
</ul>

<p>Warnings are harder to track down because they don&#39;t provide any information about where they occured. Currently, the best way to debug them into turn them into errors using <code>options(warn = 2)</code>: then you can apply any of the techniques described above. </p>

<h2>Exceptions</h2>

<p>The fine details of exceptions are not particularly well documented in R. If you want to learn more about the internals, I recommend the following two primary sources:</p>

<ul>
<li><p><a href="http://homepage.stat.uiowa.edu/%7Eluke/R/exceptions/simpcond.html">A prototype of a condition system for R</a> by Robert Gentleman and Luke Tierney. This is describes an early version of R&#39;s condition system. The implementation changed somewhat since this was written, but it provides a good overview of how the pieces fit together, and some motivation for the design.</p></li>
<li><p><a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">Beyond Exception Handling: Conditions and Restarts</a> by Peter Seibel. This describes exception handling in LISP, but the ideas are basically
the same in R, and it provides some more complicated use cases.</p></li>
</ul>

<h3>Creation</h3>

<p>You create errors in R with <code>stop()</code>.</p>

<h3>Basic error handling</h3>

<p>Error handling is performed with the <code>try()</code> (simple) and <code>tryCatch()</code> (complex) functions. <code>try()</code> allows execution to continue even after an exception has occured. For example, normally if you run a function that throws an error, it terminates immediately and doesn&#39;t return a value:</p>

<div class="chunk" id="unnamed-chunk-238"><div class="rcode"><div class="source"><pre class="knitr r">f1 <- function(x) {
  log(x)
  10
}
f1("x")
</pre></div>

<div class="error"><pre class="knitr r">## Error: non-numeric argument to mathematical function
</pre></div>

<p></div></div></p>

<p>However, if you wrap the statement that creates the error in <code>try()</code>, the error message will still be printed but execution will continue:</p>

<div class="chunk" id="unnamed-chunk-239"><div class="rcode"><div class="source"><pre class="knitr r">f2 <- function(x) {
  try(log(x))
  10
}
f2()
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<p></div></div></p>

<p>Note that you pass larger blocks of code to <code>try()</code> by wrapping them in <code>{}</code>:</p>

<div class="chunk" id="unnamed-chunk-240"><div class="rcode"><div class="source"><pre class="knitr r">try({
  a <- 1
  b <- "x"
  a + b
})
a
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">b
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<p></div></div></p>

<p>You can also capture the output of the <code>try()</code> function. If succesful, it will be the last result evaluated in the block (just like a function); if unsuccesful it will be an (invisible) object of class &quot;try-error&quot;:</p>

<div class="chunk" id="unnamed-chunk-241"><div class="rcode"><div class="source"><pre class="knitr r">success <- try(1 + 2)
failure <- try("a" + "b")
str(success)
</pre></div>

<div class="output"><pre class="knitr r">##  num 3
</pre></div>

<div class="source"><pre class="knitr r">str(failure)
</pre></div>

<div class="output"><pre class="knitr r">## Class 'try-error'  atomic [1:1] Error in "a" + "b" : non-numeric argument to binary operator
## 
##   ..- attr(*, "condition")=List of 2
##   .. ..$ message: chr "non-numeric argument to binary operator"
##   .. ..$ call   : language "a" + "b"
##   .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
</pre></div>

<p></div></div></p>

<p>You can use the second argument to <code>try()</code>, <code>silent</code>, to suppress the printing of the error message.</p>

<p><code>try()</code> is particularly useful when you&#39;re applying a function to multiple elements in a list:</p>

<div class="chunk" id="unnamed-chunk-242"><div class="rcode"><div class="source"><pre class="knitr r">elements <- list(1:10, c(-1, 10), c(T, F), letters)
results <- lapply(elements, log)
</pre></div>

<div class="warning"><pre class="knitr r">## Warning: NaNs produced
</pre></div>

<div class="error"><pre class="knitr r">## Error: non-numeric argument to mathematical function
</pre></div>

<div class="source"><pre class="knitr r">results <- lapply(elements, function(x) try(log(x)))
</pre></div>

<div class="warning"><pre class="knitr r">## Warning: NaNs produced
</pre></div>

<p></div></div></p>

<p>There isn&#39;t a built-in function for testing for this class, so we&#39;ll define one. Then you can easily find the locations of errors with <code>sapply()</code> (learn more about it in the functionals chapter), and extract the successes or look at the inputs that lead to failures.</p>

<div class="chunk" id="unnamed-chunk-243"><div class="rcode"><div class="source"><pre class="knitr r">is.error <- function(x) inherits(x, "try-error")
succeeded <- !sapply(results, is.error)

# look at successful results
str(results[succeeded])
</pre></div>

<div class="output"><pre class="knitr r">## List of 3
##  $ : num [1:10] 0 0.693 1.099 1.386 1.609 ...
##  $ : num [1:2] NaN 2.3
##  $ : num [1:2] 0 -Inf
</pre></div>

<div class="source"><pre class="knitr r">
# look at inputs that failed
str(elements[!succeeded])
</pre></div>

<div class="output"><pre class="knitr r">## List of 1
##  $ : chr [1:26] "a" "b" "c" "d" ...
</pre></div>

<p></div></div></p>

<p>Another useful <code>try()</code> idiom is setting a default value if an expression fails. Simply assign the default value outside the try block, and then run the risky code:</p>

<div class="chunk" id="unnamed-chunk-244"><div class="rcode"><div class="source"><pre class="knitr r">default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
</pre></div>

<p></div></div></p>

<h3>Advanced error handling</h3>

<p><code>tryCatch</code> gives more control than <code>try</code>, but to understand how it works, we first need to learn a little about conditions, the S3 objects that represent errors, warnings and messages.</p>

<div class="chunk" id="unnamed-chunk-245"><div class="rcode"><div class="source"><pre class="knitr r">is.condition <- function(x) inherits(x, "condition")
</pre></div>

<p></div></div></p>

<p>There are three convenience methods for creating errors, warnings and messages.  All take two arguments: the <code>message</code> to display, and an optional <code>call</code> indicating where the condition was created</p>

<div class="chunk" id="unnamed-chunk-246"><div class="rcode"><div class="source"><pre class="knitr r">e <- simpleError("My error", quote(f(x = 71)))
w <- simpleWarning("My warning")
m <- simpleMessage("My message")
</pre></div>

<p></div></div></p>

<p>There is one class of conditions that can&#39;t be generated directly: interrupts, which occur when the user presses Ctrl + Break, Escape, or Ctrl + C (depending on the platform) to terminate execution.</p>

<p>The components of a condition can be extracted with <code>conditionMessage</code> and <code>conditionCall</code>:</p>

<div class="chunk" id="unnamed-chunk-247"><div class="rcode"><div class="source"><pre class="knitr r">conditionMessage(e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "My error"
</pre></div>

<div class="source"><pre class="knitr r">conditionCall(e)
</pre></div>

<div class="output"><pre class="knitr r">## f(x = 71)
</pre></div>

<p></div></div></p>

<p>Conditions can be signalled using <code>signalCondition</code>. By default, no one is listening, so this doesn&#39;t do anything.</p>

<div class="chunk" id="unnamed-chunk-248"><div class="rcode"><div class="source"><pre class="knitr r">signalCondition(e)
</pre></div>

<div class="error"><pre class="knitr r">## Error: My error
</pre></div>

<div class="source"><pre class="knitr r">signalCondition(w)
</pre></div>

<div class="warning"><pre class="knitr r">## Warning: My warning
</pre></div>

<div class="error"><pre class="knitr r">## Error: no 'restart' 'muffleWarning' found
</pre></div>

<div class="source"><pre class="knitr r">signalCondition(m)
</pre></div>

<div class="message"><pre class="knitr r">## My message
</pre></div>

<p></div></div></p>

<p>To listen to signals, we have two tools: <code>tryCatch()</code> and <code>withCallingHandlers()</code>. <code>tryCatch()</code> is an exiting handler: it catches the condition, but the rest of the code after the exception is not run. <code>withCallingHandlers()</code> sets up calling handlers: it catches the condition, and then resumes execution of the code.  We will focus first on <code>tryCatch()</code>.</p>

<p>The <code>tryCatch()</code> call has three arguments:</p>

<ul>
<li><p><code>expr</code>: the code to run.</p></li>
<li><p><code>...</code>: a set of named arguments setting up error handlers. If an error
occurs, <code>tryCatch</code> will call the first handler whose name matches one of the
classes of the condition. The only useful names for built-in conditions are
<code>interrupt</code>, <code>error</code>, <code>warning</code> and <code>message</code>.</p></li>
<li><p><code>finally</code>: code to run regardless of whether <code>expr</code> succeeds or fails. This
is useful for clean up, as described below. All handlers have been turned
off by the time the <code>finally</code> code is run, so errors will propagate as
usual.</p></li>
</ul>

<p>The following examples illustrate the basic properties of <code>tryCatch</code>:</p>

<div class="chunk" id="unnamed-chunk-249"><div class="rcode"><div class="source"><pre class="knitr r"># Handlers are passed a single argument
tryCatch(stop("error"), 
  error = function(...) list(...)
)
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## <simpleError in doTryCatch(return(expr), name, parentenv, handler): error>
</pre></div>

<div class="source"><pre class="knitr r"># This argument is the signalled condition, so we'll call
# it c for short.

# If multiple handlers match, the first is used
tryCatch(stop("error"), 
  error = function(c) "a",
  error = function(c) "b"
)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">
# If multiple signals are nested, the the most internal is used first.
tryCatch(
  tryCatch(stop("error"), error = function(c) "a"),
  error = function(c) "b"
)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">
# Uncaught signals propagate outwards. 
tryCatch(
  tryCatch(stop("error")),
  error = function(c) "b"
)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "b"
</pre></div>

<div class="source"><pre class="knitr r">
# The first handler that matches a class of the condition is used, 
# not the "best" match:
a <- structure(list(message = "my error", call = quote(a)), 
  class = c("a", "error", "condition"))

tryCatch(stop(a), 
  error = function(c) "error",
  a = function(c) "a"
)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "error"
</pre></div>

<div class="source"><pre class="knitr r">tryCatch(stop(a), 
  a = function(c) "a",
  error = function(c) "error"
)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a"
</pre></div>

<div class="source"><pre class="knitr r">
# No matter what happens, finally is run:
tryCatch(stop("error"), 
  finally = print("Done."))
</pre></div>

<div class="error"><pre class="knitr r">## Error: error
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Done."
</pre></div>

<div class="source"><pre class="knitr r">tryCatch(a <- 1, 
  finally = print("Done."))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "Done."
</pre></div>

<div class="source"><pre class="knitr r">  
# Any errors that occur in the finally block are handled normally
a <- 1
tryCatch(a <- 2, 
  finally = stop("Error!"))
</pre></div>

<div class="error"><pre class="knitr r">## Error: Error!
</pre></div>

<p></div></div></p>

<p>What can handler functions do?</p>

<ul>
<li><p>Return a value.</p></li>
<li><p>Pass the condition along, by re-signalling the error with <code>stop(c)</code>, or
<code>signalCondition(c)</code> for non-error conditions.</p></li>
<li><p>Kill the function completely and return to the top-level with
<code>invokeRestart(&quot;abort&quot;)</code></p></li>
<li><p>Invoke another restart defined by <code>withRestarts()</code>. </p></li>
</ul>

<p>We can write a simple version of <code>try</code> using <code>tryCatch</code>. The real version of <code>try</code> is considerably more complicated to preserve the usual error behaviour.</p>

<div class="chunk" id="unnamed-chunk-250"><div class="rcode"><div class="source"><pre class="knitr r">try <- function(code, silent = FALSE) {
  tryCatch(code, error = function(c) {
    if (!silent) message("Error:", conditionMessage(c))
    invisible(structure(conditionMessage(c), class = "try-error"))
  })
} 
try(1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">try(stop("Hi"))
</pre></div>

<div class="message"><pre class="knitr r">## Error:Hi
</pre></div>

<div class="source"><pre class="knitr r">try(stop("Hi"), silent = TRUE)

rm(try)

withCallingHandlers({
  a <- 1
  stop("Error")
  a <- 2
}, error = function(c) {})
</pre></div>

<div class="error"><pre class="knitr r">## Error: Error
</pre></div>

<p></div></div></p>

<h3>Using <code>tryCatch</code></h3>

<p>With the basics in place, we&#39;ll next develop some useful tools based the ideas we just learned about.  </p>

<p>The <code>finally</code> argument to <code>tryCatch</code> is particularly useful for clean up, because it is always called, regardless of whether the code executed successfully or not. This is useful when you have:</p>

<ul>
<li>modified <code>options</code>, <code>par</code> or locale</li>
<li>opened connections, or created temporary files and directories</li>
<li>opened graphics devices</li>
<li>changed the working directory</li>
<li>modified environment variables</li>
</ul>

<p>The following function changes the working directory, executes some code, and always resets the working directory back to what it was before, even if the code raises an error.</p>

<div class="chunk" id="unnamed-chunk-251"><div class="rcode"><div class="source"><pre class="knitr r">in_dir <- function(path, code) {
  cur_dir <- getwd()
  tryCatch({
    setwd(path)
    force(code)
  }, finally = setwd(cur_dir))
}

getwd()
</pre></div>

<div class="output"><pre class="knitr r">## [1] "/home/hesterj/adv-r/no_pandoc"
</pre></div>

<div class="source"><pre class="knitr r">in_dir(R.home(), dir())
</pre></div>

<div class="output"><pre class="knitr r">##  [1] "bin"          "COPYING"      "etc"          "include"     
##  [5] "lib"          "library"      "modules"      "NEWS"        
##  [9] "NEWS.pdf"     "SVN-REVISION"
</pre></div>

<div class="source"><pre class="knitr r">getwd()
</pre></div>

<div class="output"><pre class="knitr r">## [1] "/home/hesterj/adv-r/no_pandoc"
</pre></div>

<div class="source"><pre class="knitr r">in_dir(R.home(), stop("Error!"))
</pre></div>

<div class="error"><pre class="knitr r">## Error: Error!
</pre></div>

<div class="source"><pre class="knitr r">getwd()
</pre></div>

<div class="output"><pre class="knitr r">## [1] "/home/hesterj/adv-r/no_pandoc"
</pre></div>

<p></div></div></p>

<p>Another more casual way of cleaning up is the <code>on.exit</code> function, which is called when the function terminates.  It&#39;s not as fine grained as <code>tryCatch</code>, but it&#39;s a bit less typing.</p>

<div class="chunk" id="unnamed-chunk-252"><div class="rcode"><div class="source"><pre class="knitr r">in_dir <- function(path, code) {
  cur_dir <- getwd()
  on.exit(setwd(cur_dir))

  force(code)
}
</pre></div>

<p></div></div></p>

<p>If you&#39;re using multiple <code>on.exit</code> calls, make sure to set <code>add = TRUE</code>, otherwise they will replace the previous call. <strong>Caution</strong>: Unfortunately the default in <code>on.exit()</code> is <code>add = FALSE</code>, so that every time you run it, it overwrites existing exit expressions.  Because of the way <code>on.exit()</code> is implemented, it&#39;s not possible to create a variant with <code>add = TRUE</code>, so you must be careful when using it.</p>

<h3>Exercises</h3>

<ol>
<li>Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code worked).</li>
</ol>

<h2>Defensive programming</h2>

<p>Defensive programming is the art of making code fail in a well-defined manner even when something unexpected occurs. There are two components of this art related to exceptions: raising exceptions as soon as you notice something has gone wrong, and responding to errors as cleanly as possible.</p>

<p>A general principle for errors is to &quot;fail fast&quot; - as soon as you figure out something as wrong, and your inputs are not as expected, you should raise an error. This is more work for you as the function author, but will make it easier for the user to debug because they get errors early on, not after unexpected input has passed through several functions and caused a problem.</p>

<p>There is a tension between interactive analysis and programming. When you a doing an analysis, you want R to do what you mean, and if it guesses wrong, then you&#39;ll discover it right away and can fix it. If you&#39;re creating a function, then you want to make it as robust as possible so that any problems become apparent right away (see fail fast below).</p>

<ul>
<li><p>Be explicit:</p>

<ul>
<li>Check the types of inputs</li>
<li>Be explicit about missings: </li>
<li>Avoid functions that have non-standard evaluation rules (i.e 
<code>subset</code>, <code>with</code>, <code>transform</code>). These functions save you time when working
interactively, but when they fail inside a function they usually don&#39;t
return a useful error message.</li>
</ul></li>
<li><p>Avoid functions that can return different types of objects:</p>

<ul>
<li>Make sure you use preserving subsetting.</li>
<li>Don&#39;t use <code>sapply()</code>: use <code>vapply()</code>, or <code>lapply()</code> plus the appropriate
transformation</li>
</ul></li>
</ul>

<h3>Creating</h3>

<p>There are a number of options for letting the user know when something has gone wrong:</p>

<ul>
<li><p>don&#39;t use <code>cat()</code> or <code>print()</code>, except for print methods, or for optional
debugging information.</p></li>
<li><p>use <code>message()</code> to inform the user about something expected - I often do
this when filling in important missing arguments that have a non-trivial
computation or impact. Two examples are <code>reshape2::melt</code> package, which
informs the user what melt and id variables were used if not specified, and
<code>plyr::join</code>, which informs which variables were used to join the two
tables.  You can suppress messages with <code>suppressMessages</code>.</p></li>
<li><p>use <code>warning()</code> for unexpected problems that aren&#39;t show stoppers.
<code>options(warn = 2)</code> will turn warnings into errors. Warnings are often
more appropriate for vectorised functions when a single value in the vector
is incorrect, e.g. <code>log(-1:2)</code> and <code>sqrt(-1:2)</code>.  You can suppress warnings
with <code>suppressWarnings</code></p></li>
<li><p>use <code>stop()</code> when the problem is so big you can&#39;t continue</p></li>
<li><p><code>stopifnot()</code> is a quick and dirty way of checking that pre-conditions for
your function are met. The problem with <code>stopifnot</code> is that if they aren&#39;t
met, it will display the test code as an error, not a more informative
message. Checking pre-conditions with <code>stopifnot</code> is better than nothing,
but it&#39;s better still to check the condition yourself and return an
informative message with <code>stop()</code></p></li>
</ul>

<h3>An example</h3>

<p>The following function is naively written and might cause problems:</p>

<div class="chunk" id="unnamed-chunk-253"><div class="rcode"><div class="source"><pre class="knitr r">col_means <- function(df) {
  numeric <- sapply(df, is.numeric)
  numeric_cols <- df[, numeric]
  
  data.frame(lapply(numeric_cols, mean))
}
</pre></div>

<p></div></div></p>

<p>The ability to come up with a set of potential pathological inputs is a good skill to master. Common cases that I try and check are:</p>

<ul>
<li>dimensions of length 0</li>
<li>dimensions of length 1 (in case dropping occurs)</li>
<li>incorrect input types</li>
</ul>

<p>The following code exercises some of those cases for <code>col_means</code></p>

<div class="chunk" id="unnamed-chunk-254"><div class="rcode"><div class="source"><pre class="knitr r">col_means(mtcars)
</pre></div>

<div class="output"><pre class="knitr r">##     mpg   cyl  disp    hp  drat    wt  qsec     vs     am  gear  carb
## 1 20.09 6.188 230.7 146.7 3.597 3.217 17.85 0.4375 0.4062 3.688 2.812
</pre></div>

<div class="source"><pre class="knitr r">col_means(mtcars[, 0])
</pre></div>

<div class="error"><pre class="knitr r">## Error: invalid subscript type 'list'
</pre></div>

<div class="source"><pre class="knitr r">col_means(mtcars[0, ])
</pre></div>

<div class="output"><pre class="knitr r">##   mpg cyl disp  hp drat  wt qsec  vs  am gear carb
## 1 NaN NaN  NaN NaN  NaN NaN  NaN NaN NaN  NaN  NaN
</pre></div>

<div class="source"><pre class="knitr r">col_means(mtcars[, "mpg", drop = F])
</pre></div>

<div class="output"><pre class="knitr r">##   X21 X21.1 X22.8 X21.4 X18.7 X18.1 X14.3 X24.4 X22.8.1 X19.2 X17.8 X16.4
## 1  21    21  22.8  21.4  18.7  18.1  14.3  24.4    22.8  19.2  17.8  16.4
##   X17.3 X15.2 X10.4 X10.4.1 X14.7 X32.4 X30.4 X33.9 X21.5 X15.5 X15.2.1
## 1  17.3  15.2  10.4    10.4  14.7  32.4  30.4  33.9  21.5  15.5    15.2
##   X13.3 X19.2.1 X27.3 X26 X30.4.1 X15.8 X19.7 X15 X21.4.1
## 1  13.3    19.2  27.3  26    30.4  15.8  19.7  15    21.4
</pre></div>

<div class="source"><pre class="knitr r">col_means(1:10)
</pre></div>

<div class="error"><pre class="knitr r">## Error: incorrect number of dimensions
</pre></div>

<div class="source"><pre class="knitr r">col_means(as.matrix(mtcars))
</pre></div>

<div class="error"><pre class="knitr r">## Error: (subscript) logical subscript too long
</pre></div>

<div class="source"><pre class="knitr r">col_means(as.list(mtcars))
</pre></div>

<div class="error"><pre class="knitr r">## Error: incorrect number of dimensions
</pre></div>

<div class="source"><pre class="knitr r">
mtcars2 <- mtcars
mtcars2[-1] <- lapply(mtcars2[-1], as.character)
col_means(mtcars2)
</pre></div>

<div class="output"><pre class="knitr r">##   X21 X21.1 X22.8 X21.4 X18.7 X18.1 X14.3 X24.4 X22.8.1 X19.2 X17.8 X16.4
## 1  21    21  22.8  21.4  18.7  18.1  14.3  24.4    22.8  19.2  17.8  16.4
##   X17.3 X15.2 X10.4 X10.4.1 X14.7 X32.4 X30.4 X33.9 X21.5 X15.5 X15.2.1
## 1  17.3  15.2  10.4    10.4  14.7  32.4  30.4  33.9  21.5  15.5    15.2
##   X13.3 X19.2.1 X27.3 X26 X30.4.1 X15.8 X19.7 X15 X21.4.1
## 1  13.3    19.2  27.3  26    30.4  15.8  19.7  15    21.4
</pre></div>

<p></div></div></p>

<p>A better version of <code>col_means</code> might be:</p>

<div class="chunk" id="unnamed-chunk-255"><div class="rcode"><div class="source"><pre class="knitr r">col_means <- function(df) {
  numeric <- vapply(df, is.numeric, logical(1))
  numeric_cols <- df[, numeric, drop = FALSE]
  
  data.frame(lapply(numeric_cols, mean))
}
</pre></div>

<p></div></div></p>

<p>We use <code>vapply</code> instead of <code>sapply</code>, remember to use <code>drop = FALSE</code>.  It still doesn&#39;t check that the input is correct, or coerce it to the correct format.</p>

<p><a href="http://twitter.com/JohnDCook/status/29670670701">John D Cook</a></p>

<p>One use of anonymous functions is to create small functions that it&#39;s not worth naming; the other main use of anonymous functions is to create closures, functions written by functions. Closures are so called because they <strong>enclose</strong> the environment of the parent function, and can access all variables in the parent. This is useful because it allows us to have two levels of parameters. One level of parameters (the parent) controls how the function works; the other level (the child) does the work. The following example shows how we can use this idea to generate a family of power functions. The parent function (<code>power()</code>) creates child functions (<code>square()</code> and <code>cube()</code>) that do the work.</p>

<pre><code class="R">power &lt;- function(exponent) {
  function(x) x ^ exponent
}

square &lt;- power(2)
square(2)
square(4)

cube &lt;- power(3)
cube(2)
cube(4)
</code></pre>

<p>In R, almost every function is a closure, because all functions remember the environment in which they are created, typically either the global environment, if it&#39;s a function that you&#39;ve written, or a package environment, if it&#39;s a function that someone else has written. The only exception are primitive functions, which call to C directly.</p>

<p>When you print a closure, you don&#39;t see anything terribly useful:</p>

<pre><code class="R">square
cube
</code></pre>

<p>That&#39;s because the function itself doesn&#39;t change; it&#39;s the enclosing environment, <code>environment(square)</code>, that&#39;s different. One way to see the contents of the environment is to convert it to a list:</p>

<pre><code class="R">as.list(environment(square))
as.list(environment(cube))
</code></pre>

<p>Another way to see what&#39;s going on is to use <code>pryr::unenclose()</code>, which substitutes the variables defined in the enclosing environment into the original functon:</p>

<pre><code class="R">library(pryr)
unenclose(square)
unenclose(cube)
</code></pre>

<p>Note that the parent environment of the closure is the environment created when the parent function is called:</p>

<pre><code class="R">power &lt;- function(exponent) {
  print(environment())
  function(x) x ^ exponent
}
zero &lt;- power(0)
environment(zero)
</code></pre>

<p>This environment normally disappears once the function finishes executing, but because we return a function, the environment is captured and attached to the new function. Each time we re-run <code>power()</code> a new environment is created, so each function produced by power is independent.</p>

<p>Closures are useful for making function factories, and are one way to manage mutable state in R. </p>

<h3>Function factories</h3>

<p>We&#39;ve already seen two example of function factories, <code>missing_fixer()</code> and <code>power()</code>. In both these cases using a function factory instead of a single function with multiple arguments has little, if any, benefit. Function factories are most useful when:</p>

<ul>
<li><p>the different levels are more complex, with multiple arguments and complicated bodies</p></li>
<li><p>some work only needs to be done once, when the function is generated</p></li>
</ul>

<p>INSERT USEFUL EXAMPLE HERE</p>

<p>We&#39;ll see another compelling use of function factories when we learn more about [[functionals]]; they are particularly well suited to maximum likelihood problems.</p>

<h3>Mutable state</h3>

<p>Having variables at two levels makes it possible to maintain state across function invocations, because while the function environment is refreshed every time, its parent environment stays constant. The key to managing variables at different levels is the double arrow assignment operator (<code>&lt;&lt;-</code>). Unlike the usual single arrow assignment (<code>&lt;-</code>) that always assigns in the current environment, the double arrow operator will keep looking up the chain of parent environments until it finds a matching name. ([[Environments]] has more details on how it works)</p>

<p>Together, a static parent environment and <code>&lt;&lt;-</code> make it possible to maintain state across function calls.  The following example shows a counter that records how many times a function has been called. Each time <code>new_counter</code> is run, it creates an environment, initialises the counter <code>i</code> in this environment, and then creates a new function.</p>

<pre><code class="R">new_counter &lt;- function() {
  i &lt;- 0
  function() {
    i &lt;&lt;- i + 1
    i
  }
}
</code></pre>

<p>The new function is a closure, and its enclosing environment is the usually temporary environment created with <code>new_counter</code> is run.  When the closures <code>counter_one</code> and <code>counter_two</code> are run, each one modifies the counter in a different enclosing environment and so maintain different counts. </p>

<pre><code class="R">counter_one &lt;- new_counter()
counter_two &lt;- new_counter()

counter_one() # -&gt; [1] 1
counter_one() # -&gt; [1] 2
counter_two() # -&gt; [1] 1
</code></pre>

<p>We can use our environment inspection tools to see what&#39;s going on here:</p>

<pre><code class="R">as.list(environment(counter_one))
as.list(environment(counter_two))
</code></pre>

<p>The counters get around the &quot;fresh start&quot; limitation by not modifying variables in their local environment. Since the changes are made in the unchanging parent (or enclosing) environment, they are preserved across function calls.</p>

<p>What happens if we don&#39;t use a closure? What happens if we only use <code>&lt;-</code> instead of <code>&lt;&lt;-</code>? Make predictions about what will happen if you replace <code>new_counter()</code> with each variant below, then run the code and check your predictions.</p>

<pre><code class="R">i &lt;- 0
new_counter2 &lt;- function() {
  i &lt;&lt;- i + 1
  i
}
new_counter3 &lt;- function() {
  i &lt;- 0
  function() {
    i &lt;- i + 1
    i
  }
}
</code></pre>

<p>Modifying values in a parent environment is an important technique because it is one way to generate &quot;mutable state&quot; in R. Mutable state is normally hard to achieve, because every time it looks like you&#39;re modifying an object, you&#39;re actually creating a copy and modifying that. That said, if you do need mutable objects, except in the simplest of cases, it&#39;s usually better to use the [[R5]] OO system. R5 objects are easier to document, and provide easier ways to inherit behaviour.</p>

<p>The power of closures is tightly coupled to [[functionals]] and [[function operators]], and you&#39;ll see many more examples of closures in those two chapters.  The following section disucsses the remaining important property of functions: the ability to store them in a list.</p>

<h3>Exercises</h3>

<ul>
<li><p>What does the following statistical function do? What would be a better name for it? (The existing name is a bit of a hint)</p>

<pre><code class="R">bc &lt;- function(lambda) {
  if (lambda == 0) {
    function(x) log(x)
  } else {
    function(x) (x ^ lambda - 1) / lambda
  }
}
</code></pre></li>
<li><p>Create a function that creates functions that compute the ith <a href="http://en.wikipedia.org/wiki/Central_moment">central moment</a> of a numeric vector. You can test it by running the following code:</p>

<pre><code class="R">m1 &lt;- moment(1)
m2 &lt;- moment(2)

x &lt;- runif(m1, 100)
stopifnot(all.equal(m1(x), mean(x)))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))
</code></pre></li>
<li><p>What does <code>approxfun()</code> do? What does it return? </p></li>
<li><p>What does the <code>ecdf()</code> function do? What does it return? </p></li>
<li><p>Create a function <code>pick()</code>, that takes an index, <code>i</code>, as an argument and returns a function an argument <code>x</code> that subsets <code>x</code> with <code>i</code>.</p>

<pre><code class="R">lapply(mtcars, pick(5))
# should do the same this as
lapply(mtcars, function(x) x[[5]])
</code></pre></li>
</ul>

<h2>Lists of functions</h2>

<p>In R, functions can be stored in lists. Instead of giving a set of functions related names, you can store them in a list.  This makes it easier to work with groups of related functions, in the same way a data frame makes it easier to work with groups of related vectors.</p>

<p>We&#39;ll start with a simple example: benchmarking, when you are comparing the performance of multiple approaches to the same problem. For example, if you wanted to compare a few approaches to computing the mean, you could store each approach (function) in a list:</p>

<pre><code class="R">compute_mean &lt;- list(
  base = function(x) mean(x),
  sum = function(x) sum(x) / length(x),
  manual = function(x) {
    total &lt;- 0
    n &lt;- length(x)
    for (i in seq_along(x)) {
      total &lt;- total + x[i] / n
    }
    total
  }
)
</code></pre>

<p>Calling a function from a list is straightforward: just get it out of the list first:</p>

<pre><code class="R">x &lt;- runif(1e5)
system.time(compute_mean$base(x))
system.time(compute_mean[[2]](x))
system.time(compute_mean[[&quot;manual&quot;]](x))
</code></pre>

<p>If we want to call each functions to check that we&#39;ve implemented them correctly and they return the same answer, we can use <code>lapply()</code>, either with an anonymous function, or an equivalent named function.</p>

<pre><code class="R">lapply(compute_mean, function(f, ...) f(...), x)

call_fun &lt;- function(f, ...) f(...)
lapply(compute_mean, call_fun, x)
</code></pre>

<p>If we want to time how long each function takes, we can combine lapply with <code>system.time()</code>:</p>

<pre><code class="R">lapply(compute_mean, function(f) system.time(f(x)))
</code></pre>

<p>Coming back to our original motivating example, another use case of lists of functions is summarising an object in multiple ways. We could store each summary function in a list, and then run them all with <code>lapply()</code>:</p>

<pre><code class="R">funs &lt;- list(
  sum = sum,
  mean = mean,
  median = median
)
lapply(funs, function(f) f(1:10))
</code></pre>

<p>What if we wanted our summary functions to automatically remove missing values?  One approach would be make a list of anonymous functions that call our summary functions with the appropriate arguments:</p>

<pre><code class="R">funs2 &lt;- list(
  sum = function(x, ...) sum(x, ..., na.rm = TRUE),
  mean = function(x, ...) mean(x, ..., na.rm = TRUE),
  median = function(x, ...) median(x, ..., na.rm = TRUE)
)
</code></pre>

<p>But this leads to a lot of duplication - each function is almost identical apart from a different function name. We could write a closure to abstract this away:</p>

<p>Instead, we could modify our original <code>lapply()</code> call:</p>

<pre><code class="R">lapply(funs, function(f) f(x))
lapply(funs, function(f) f(x, na.rm = TRUE))

# Or use a named function instead of an anonymous function
remove_missings &lt;- function(f) {
  function(...) f(..., na.rm = TRUE)
}
funs2 &lt;- lapply(funs, remove_missings)
</code></pre>

<h3>Moving lists of functions to the global environment</h3>

<p>From time to time you may want to create a list of functions that you want to be available to your users without having to use a special syntax. For a simple example, imagine you want to make it easy to create HTML with code, by mapping each html tag to an R function. The following simple example creates functions for <code>&lt;p&gt;</code> (paragraphics), <code>&lt;b&gt;</code> (bold), <code>&lt;i&gt;</code> (italics), and <code>&lt;img&gt;</code> (images).  Note the use of a closure function factory to produce the text for <code>&lt;p&gt;</code>, <code>&lt;b&gt;</code> and <code>&lt;i&gt;</code> tags.</p>

<pre><code class="R">simple_tag &lt;- function(tag) {
  function(...) paste0(&quot;&lt;&quot;, tag, &quot;&gt;&quot;, paste0(...), &quot;&lt;/&quot;, tag, &quot;&gt;&quot;)
}
html &lt;- list(
  p = simple_tag(&quot;p&quot;),
  b = simple_tag(&quot;b&quot;),
  i = simple_tag(&quot;i&quot;),
  img = function(path, width, height) {
    paste0(&quot;&lt;img src=&#39;&quot;, path, &quot;&#39; width=&#39;&quot;, width, &quot;&#39; height = &#39;&quot;, height, &#39;&quot; /&gt;&#39;)
  }
)
</code></pre>

<p>We store the functions in a list because we don&#39;t want them to be available all the time: the risk of a conflict between an existing R function and an HTML tag is high. However, keeping them in a list means that our code is more verbose than necessary:</p>

<pre><code class="R">html$p(&quot;This is &quot;, html$b(&quot;bold&quot;), &quot;, &quot;, html$i(&quot;italic&quot;), &quot; and &quot;,
   html$b(html$i(&quot;bold italic&quot;)), &quot; text&quot;)
</code></pre>

<p>We have three options to eliminate the use of <code>html$</code>, depending on how long we want the effect to last:</p>

<ul>
<li><p>For a very temporary effect, we can use a <code>with()</code> block:</p>

<pre><code class="R">with(html, p(&quot;This is &quot;, b(&quot;bold&quot;), &quot;, &quot;, i(&quot;italic&quot;), &quot; and &quot;,
  b(i(&quot;bold italic&quot;)), &quot; text&quot;))
</code></pre></li>
<li><p>For a longer effect, we can use <code>attach()</code> to add the functions in <code>html</code> in to the search path.  It&#39;s possible to undo this action using <code>detach</code>:</p>

<pre><code class="R">attach(html)
p(&quot;This is &quot;, b(&quot;bold&quot;), &quot;, &quot;, i(&quot;italic&quot;), &quot; and &quot;,
  b(i(&quot;bold italic&quot;)), &quot; text&quot;)
detach(html)
</code></pre></li>
<li><p>Finally, we could copy the functions into the global environment with <code>list2env()</code>.  We can undo this action by deleting the functions after we&#39;re done.</p>

<pre><code class="R">list2env(html, environment())
p(&quot;This is &quot;, b(&quot;bold&quot;), &quot;, &quot;, i(&quot;italic&quot;), &quot; and &quot;,
  b(i(&quot;bold italic&quot;)), &quot; text&quot;)
rm(list = names(html), envir = environment())
</code></pre></li>
</ul>

<p>I recommend the first option because it makes it very clear what&#39;s going on, and when code is being executed in a special context.</p>

<h3>Exercises</h3>

<ul>
<li><p>Implement a summary function that works like <code>base::summary()</code>, but takes a list of functions to use to compute the summary. Modify the function so it returns a closure, making it possible to use it as a function factory.</p></li>
<li><p>Create a named list of all base functions.  Use <code>ls()</code>, <code>get()</code> and <code>is.function()</code>. Use that list of functions to answer the following questions:</p>

<ul>
<li>Which base function has the most arguments? </li>
<li>How many base functions have no arguments?</li>
</ul></li>
<li><p>Which of the following commands is <code>with(x, f(z))</code> equivalent to?</p>

<p>(a) <code>x$f(x$z)</code>
(b) <code>f(x$z)</code>
(c) <code>x$f(z)</code>
(d) <code>f(z)</code></p></li>
</ul>

<h2>Case study: numerical integration</h2>

<p>To conclude this chapter, we will develop a simple numerical integration tool, and along the way, illustrate the use of many properties of first-class functions. Each step is driven by a desire to make our approach more general and to reduce duplication.  The idea behind numerical integration is simple: we want to find the area under the curve by approximating a complex curve with simpler components.</p>

<p>The two simpliest approaches are the <strong>midpoint</strong> and <strong>trapezoid</strong> rules; the mid point rule approximates a curve by a rectangle, and the trapezoid rule by a trapezoid. Each takes a function we want to integrate, <code>f</code>, and a range to integrate over, from <code>a</code> to <code>b</code>. For this example we&#39;ll try to integrate <code>sin x</code> from 0 to pi, because it has a simple answer: 2.</p>

<pre><code class="R">midpoint &lt;- function(f, a, b) {
  (b - a) * f((a + b) / 2)
}

trapezoid &lt;- function(f, a, b) {
  (b - a) / 2 * (f(a) + f(b))
}

midpoint(sin, 0, pi)
trapezoid(sin, 0, pi)
</code></pre>

<p>Neither of these functions gives a very good approximation, so we&#39;ll do what we normally do in calculus: break up the range into smaller pieces and integrate each piece using one of the simple rules. This is called <strong>composite integration</strong>, and we&#39;ll implement it with two new functions:</p>

<pre><code class="R">midpoint_composite &lt;- function(f, a, b, n = 10) {
  points &lt;- seq(a, b, length = n + 1)
  h &lt;- (b - a) / n

  area &lt;- 0
  for (i in seq_len(n)) {
    area &lt;- area + h * f((points[i] + points[i + 1]) / 2)
  }
  area
}

trapezoid_composite &lt;- function(f, a, b, n = 10) {
  points &lt;- seq(a, b, length = n + 1)
  h &lt;- (b - a) / n

  area &lt;- 0
  for (i in seq_len(n)) {
    area &lt;- area + h / 2 * (f(points[i]) + f(points[i + 1]))
  }
  area
}

midpoint_composite(sin, 0, pi, n = 10)
midpoint_composite(sin, 0, pi, n = 100)
trapezoid_composite(sin, 0, pi, n = 10)
trapezoid_composite(sin, 0, pi, n = 100)

mid &lt;- sapply(1:20, function(n) midpoint_composite(sin, 0, pi, n))
trap &lt;- sapply(1:20, function(n) trapezoid_composite(sin, 0, pi, n))
matplot(cbind(mid = mid, trap))
</code></pre>

<p>But notice that there&#39;s a lot of duplication across <code>midpoint_composite</code> and <code>trapezoid_composite</code>: they are basically the same apart from the internal rule used to integrate over a simple range. Let&#39;s extract out a general composite integrate function:</p>

<pre><code class="R">composite &lt;- function(f, a, b, n = 10, rule) {
  points &lt;- seq(a, b, length = n + 1)

  area &lt;- 0
  for (i in seq_len(n)) {
    area &lt;- area + rule(f, points[i], points[i + 1])
  }

  area
}

midpoint_composite(sin, 0, pi, n = 10)
composite(sin, 0, pi, n = 10, rule = midpoint)
composite(sin, 0, pi, n = 10, rule = trapezoid)
</code></pre>

<p>This function now takes two functions as arguments: the function to integrate, and the integration rule to use for simple ranges. We can now add even better rules for integrating small ranges:</p>

<pre><code class="R">simpson &lt;- function(f, a, b) {
  (b - a) / 6 * (f(a) + 4 * f((a + b) / 2) + f(b))
}

boole &lt;- function(f, a, b) {
  pos &lt;- function(i) a + i * (b - a) / 4
  fi &lt;- function(i) f(pos(i))

  (b - a) / 90 * 
    (7 * fi(0) + 32 * fi(1) + 12 * fi(2) + 32 * fi(3) + 7 * fi(4))
}
</code></pre>

<p>Let&#39;s compare these different approaches.</p>

<pre><code class="R">expt1 &lt;- expand.grid(
  n = 5:50, 
  rule = c(&quot;midpoint&quot;, &quot;trapezoid&quot;, &quot;simpson&quot;, &quot;boole&quot;), 
  stringsAsFactors = F)

abs_sin &lt;- function(x) abs(sin(x))
run_expt &lt;- function(n, rule) {
  composite(abs_sin, 0, 4 * pi, n = n, rule = match.fun(rule))
}

library(plyr)
res1 &lt;- mdply(expt1, run_expt)

library(ggplot2)
qplot(n, V1, data = res1, colour = rule, geom = &quot;line&quot;)
</code></pre>

<p>It turns out that the midpoint, trapezoid, Simpson and Boole rules are all examples of a more general family called Newton-Cotes rules. (They are polynomials of increasing complexity).  We can take our integration one step further by extracting out this commonality to produce a function that can generate any general Newton-Cotes rule:</p>

<pre><code class="R"># http://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas
newton_cotes &lt;- function(coef, open = FALSE) {
  n &lt;- length(coef) + open

  function(f, a, b) {
    pos &lt;- function(i) a + i * (b - a) / n
    points &lt;- pos(seq.int(0, length(coef) - 1))

    (b - a) / sum(coef) * sum(f(points) * coef)        
  }
}

trapezoid &lt;- newton_cotes(c(1, 1))
midpoint &lt;- newton_cotes(1, open = TRUE)
simpson &lt;- newton_cotes(c(1, 4, 1))
boole &lt;- newton_cotes(c(7, 32, 12, 32, 7))
milne &lt;- newton_cotes(c(2, -1, 2), open = TRUE)

expt1 &lt;- expand.grid(n = 5:50, rule = names(rules), 
  stringsAsFactors = FALSE)
run_expt &lt;- function(n, rule) {
  composite(abs_sin, 0, 4 * pi, n = n, rule = rules[[rule]])
}
</code></pre>

<p>Mathematically, the next step in improving numerical integration is to move from a grid of evenly spaced points to a grid where the points are closer together near the end of the range, such as <strong>Gaussian quadrature</strong>.  That&#39;s beyond the scope of this case study, but you would use similar techniques to add it.</p>

<h3>Exercises</h3>

<ul>
<li><p>Instead of creating individual fuctions <code>midpoint()</code>, <code>trapezoid()</code>, <code>simpson()</code> etc, we could store them in a list. If we do that, how does the code change? Can you create the list of functions from a list of coefficients for the Newton-Cotes formulae?</p></li>
<li><p>The tradeoff in integration rules is that more complex rules are slower to compute, but need fewer pieces.  For <code>sin()</code> in the range [0, pi], determine the number of pieces needed to for each rule to be equally accurate. Illustrate your results with a graph.  How do they change for different functions? <code>sin(1 / x^2)</code> is particularly challenging. </p></li>
<li><p>For each of the Newton-Cotes rules, how many pieces do you need to get within 0.1% of the true answer for <code>sin()</code> in the range [0, pi].  Write a function that determines that automatically for any function (hint: look at <code>optim()</code> and construct a one-argument function with closures)</p></li>
</ul>

<p><a href="http://www.stroustrup.com/Software-for-infrastructure.pdf">Bjarne Stroustrup</a></p>

<p>Higher-order functions encompass any functions that either take a function as an input or return a function as output. We&#39;ve already seen closures, functions returned by another function. The complement to a closure is a <strong>functional</strong>, a function that takes a function as an input and returns a vector as output. </p>

<p>Here&#39;s a simple functional, it takes an input function and calls it with some random input:</p>

<div class="chunk" id="unnamed-chunk-256"><div class="rcode"><div class="source"><pre class="knitr r">randomise <- function(f) f(runif(1e3))
randomise(mean)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.4996
</pre></div>

<div class="source"><pre class="knitr r">randomise(sum)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 491.5
</pre></div>

<p></div></div></p>

<p>This function is not terribly useful, but it illustrates the basic idea: since functions are first class objects in R, there&#39;s no difference between calling a function with a vector or function as input. The chances are that you&#39;ve already used a functional: the most frequently used are <code>lapply()</code>, <code>apply()</code> and <code>tapply()</code>. These three functions all take a function as input (among other things) and give a vector as output.</p>

<p>Many functionals (like <code>lapply()</code>) offer alternatives to for loops. For loops have a bad rap in R, and some programmers try to eliminate them at all costs. The performance story is a little more complicated than what you might have heard (we&#39;ll explore that in the [[performance]] chapter); the real downside of for loops is that they&#39;re not very expressive. A for loop conveys that you&#39;re iterating over something, but it doesn&#39;t communicate the higher-level task you&#39;re trying to complete. Functionals are not as general as for loops, but by being more specific they allow you to communicate more clearly. A functional allows you to say I want to transform each element of this list, or each row of this array.</p>

<p>As well as more clearly communicating intent, functionals reduce the chances of bugs, and can be more efficient. Both of these features occur because functionals are used by many people, so they will be well tested, and may have been implemented with an eye to performance. For example, many functionals in base R are written in C, and often use a few tricks to get extra performance.</p>

<p>As well as replacements for for loops, functionals do play other roles. They are also useful tools for encapsulating common data manipulation tasks, the split-apply-combine pattern; for thinking &quot;functionally&quot;; and for working with mathematical functions. In this chapter, you&#39;ll learn about:</p>

<ul>
<li><p>Functionals that replace a common pattern of for-loop use, like <code>lapply</code>, <code>vapply</code> and <code>Map</code>.</p></li>
<li><p>Functionals for manipulating common R data structures, like <code>apply</code>, <code>split</code>, <code>tapply</code> and the plyr package.</p></li>
<li><p>Popular functionals from other programming languages, like <code>Map</code>, <code>Reduce</code> and <code>Filter</code>.</p></li>
<li><p>Mathematical functionals, like <code>integrate</code>, <code>uniroot</code>, and <code>optim</code>.</p></li>
</ul>

<p>We&#39;ll also talk about how (and why) you might convert loop to use a functional. The chapter concludes with a case study where we take simple scalar addition and use functionals to build a complete family of addition functions including vectorised addition, sum, cumulative sum, and row- and column-wise summation. </p>

<p>The focus in this chapter is on clear communication with your code, and developing tools to solve wide classes of problems. This will not always produce the fastest code, but it is a mistake to focus on speed until you know it will be a problem. Once you do have clear, correct code you can make it fast using the techniques in the [[performance]] chapter.</p>

<h2>My first functional: <code>lapply()</code></h2>

<p>The simplest functional is <code>lapply()</code>, which you may already be familiar with. <code>lapply()</code> takes a function and applies it to each element of a list, saving the results back into a list.  <code>lapply()</code> is the building block for many other functionals, so it&#39;s important to understand how it works</p>

<p><img src="data:image/png;base64,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" alt="A sketch of how `lapply()` works"/></p>

<p><code>lapply()</code> is written in C for performance, but we can create a simple R implementation that works the same way:</p>

<div class="chunk" id="unnamed-chunk-257"><div class="rcode"><div class="source"><pre class="knitr r">lapply2 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
</pre></div>

<p></div></div></p>

<p>From this code, you can see that <code>lapply()</code> is a wrapper around a common for loop pattern: we create a space for output, and then fill it in, applying <code>f()</code> to each component of the list. All other for loop functionals build on this base, modifying either the input, the output, or what data the function is applied to. From this code you can see that <code>lapply()</code> will also works with vectors: both <code>length()</code> and <code>&#39;[[</code> work the same way for lists and vectors.</p>

<p><code>lapply()</code> makes it easier to work with lists by eliminating much of the boilerplate, focussing on the operation you&#39;re applying to each piece:</p>

<div class="chunk" id="unnamed-chunk-258"><div class="rcode"><div class="source"><pre class="knitr r"># Create some random data
l <- replicate(20, runif(sample(1:10, 1)), simplify = FALSE)

# With a for loop
out <- vector("list", length(l))
for (i in seq_along(l)) {
  out[[i]] <- length(l[[i]])    
}
unlist(out)
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  5  2  3  7  7  5 10  6  5  4  2 10  8  2  8 10  8  5  2 10
</pre></div>

<div class="source"><pre class="knitr r">
# With lapply
unlist(lapply(l, length))
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  5  2  3  7  7  5 10  6  5  4  2 10  8  2  8 10  8  5  2 10
</pre></div>

<p></div></div></p>

<p>(We&#39;re using <code>unlist()</code> to convert the output from a list to a vector to make the output more compact. We&#39;ll see other ways of making the output a vector shortly.)</p>

<p>Since data frames are also lists, <code>lapply()</code> is useful when you want to do something to each column of a data frame:</p>

<div class="chunk" id="unnamed-chunk-259"><div class="rcode"><div class="source"><pre class="knitr r"># What class is each column?
unlist(lapply(mtcars, class))
</pre></div>

<div class="output"><pre class="knitr r">##       mpg       cyl      disp        hp      drat        wt      qsec 
## "numeric" "numeric" "numeric" "numeric" "numeric" "numeric" "numeric" 
##        vs        am      gear      carb 
## "numeric" "numeric" "numeric" "numeric"
</pre></div>

<div class="source"><pre class="knitr r">
# Divide each column by the mean
mtcars[] <- lapply(mtcars, function(x) x / mean(x))
</pre></div>

<p></div></div></p>

<p>The pieces of <code>x</code> are always supplied as the first argument to <code>f</code>. You can override this using R&#39;s regular function calling semantics, supplying additional named arguments. For example, imagine you wanted to compute various trimmed means of the same dataset. <code>trim</code> is the second parameter of <code>mean()</code>, so we want to vary that, keeping the first argument (<code>x</code>) fixed.  It&#39;s easy provided that you remember that the following two calls are equivalent </p>

<div class="chunk" id="unnamed-chunk-260"><div class="rcode"><div class="source"><pre class="knitr r">mean(1:100, trim = 0.1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 50.5
</pre></div>

<div class="source"><pre class="knitr r">mean(0.1, x = 1:100)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 50.5
</pre></div>

<p></div></div></p>

<p>So to use <code>lapply()</code> with the second argument, we just need to name the first argument:</p>

<div class="chunk" id="unnamed-chunk-261"><div class="rcode"><div class="source"><pre class="knitr r">trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(100)
unlist(lapply(trims, mean, x = x))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.1771 0.1771 0.1771 0.1771
</pre></div>

<p></div></div></p>

<h3>Looping patterns</h3>

<p>When using <code>lapply()</code> and friends, it&#39;s useful to remember that there are usually three ways to loop over an vector: </p>

<ol>
<li>loop over the elements of the vector: <code>for(x in xs)</code></li>
<li>loop over the numeric indices of the vector: <code>for(i in seq_along(xs))</code></li>
<li>loop over the names of the vector: <code>for(nm in names(xs))</code></li>
</ol>

<p>If you&#39;re saving the results from a for loop, you usually can&#39;t use the first form because it makes very inefficient code.  When extending an existing data structure, all the existing data must be copied every time you extend it:</p>

<div class="chunk" id="unnamed-chunk-262"><div class="rcode"><div class="source"><pre class="knitr r">xs <- runif(1e3)
res <- c()
for(x in xs) {
  # This is slow!
  res <- c(res, sqrt(x))
}
</pre></div>

<p></div></div></p>

<p>It&#39;s much better to create enough space for the output and then fill it in, using the second looping form:</p>

<div class="chunk" id="unnamed-chunk-263"><div class="rcode"><div class="source"><pre class="knitr r">res <- numeric(length(xs))
for(i in seq_along(xs)) {
  res[i] <- sqrt(xs[i])
}
</pre></div>

<p></div></div></p>

<p>Corresponding to the three ways to use a for loop there are three ways to use <code>lapply()</code> with an object:</p>

<div class="chunk" id="unnamed-chunk-264"><div class="rcode"><div class="source"><pre class="knitr r">lapply(xs, function(x) {})
lapply(seq_along(xs), function(i) {})
lapply(names(xs), function(nm) {})
</pre></div>

<p></div></div></p>

<p>Typically you use the first form because <code>lapply()</code> takes care of saving the output for you. However, if you need to know the position or the name of the element you&#39;re working with, you&#39;ll need to use the second or third form; they give you both the position of the object (<code>i</code>, <code>nm</code>) and its value (<code>xs[[i]]</code>, <code>xs[[nm]]</code>). If you&#39;re struggling to solve a problem using one form, you might find it easier with a different form.</p>

<p>If you&#39;re working with a list of functions, remember to use <code>call_fun</code>:</p>

<div class="chunk" id="unnamed-chunk-265"><div class="rcode"><div class="source"><pre class="knitr r">call_fun <- function(f, ...) f(...)
f <- list(sum, mean, median, sd)
lapply(f, call_fun, x = runif(1e3))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 510.4
## 
## [[2]]
## [1] 0.5104
## 
## [[3]]
## [1] 0.5102
## 
## [[4]]
## [1] 0.282
</pre></div>

<p></div></div></p>

<p>Or you could create a variant, <code>fapply()</code>, specifically for working with lists of functions:</p>

<div class="chunk" id="unnamed-chunk-266"><div class="rcode"><div class="source"><pre class="knitr r">fapply <- function(fs, ...) {
  out <- vector("list", length(fs))
  for (i in seq_along(fs)) {
    out[[i]] <- fs[[i]](...)
  }
  out
}
fapply(f, x = runif(1e3))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 508
## 
## [[2]]
## [1] 0.508
## 
## [[3]]
## [1] 0.5093
## 
## [[4]]
## [1] 0.2809
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li>The function <code>scale01()</code> given below scales a vector to have range 0-1. How would you apply it to every column in a data frame? How would you apply it to every numeric column in a data frame?</li>
</ul>

<div class="chunk" id="unnamed-chunk-267"><div class="rcode"><div class="source"><pre class="knitr r">scale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
</pre></div>

<p></div></div></p>

<ul>
<li>For each formula in the list below, use a for-loop and lapply to fit the corresponding model to the <code>mtcars</code> dataset</li>
</ul>

<div class="chunk" id="unnamed-chunk-268"><div class="rcode"><div class="source"><pre class="knitr r">formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)
</pre></div>

<p></div></div></p>

<ul>
<li>Fit the model <code>mpg ~ disp</code> to each of the bootstrap replicates of <code>mtcars</code> in the list below, using a for loop and then <code>lapply()</code>. Can you do it without an anonymous function?</li>
</ul>

<div class="chunk" id="unnamed-chunk-269"><div class="rcode"><div class="source"><pre class="knitr r">bootstraps <- lapply(1:10, function(i) {
  rows <- sample(1:nrow(mtcars), rep = TRUE)
  mtcars[rows, ]
})
</pre></div>

<p></div></div></p>

<ul>
<li>For each model in the previous two exercises extract the R<sup>2</sup> using the function below.</li>
</ul>

<div class="chunk" id="unnamed-chunk-270"><div class="rcode"><div class="source"><pre class="knitr r">rsq <- function(mod) summary(mod)$r.squared
</pre></div>

<p></div></div></p>

<h2>For loop functionals: friends of <code>lapply()</code></h2>

<p>The art of using functionals is to recognise what common looping patterns are implemented in existing base functionals, and then use them instead of loops. Once you&#39;ve mastered the existing functionals, the next step is to start writing your own: if you discover you&#39;re duplicating the same looping pattern in many places, you should extract it out into its own function. </p>

<p>The following sections build on <code>lapply()</code> and discuss:</p>

<ul>
<li><p><code>sapply()</code> and <code>vapply()</code>, variants of <code>lapply()</code> that produce 
vectors, matrices and arrays as <strong>output</strong>, instead of lists.</p></li>
<li><p><code>Map()</code> and <code>mapply()</code> which iterate over multiple <strong>input</strong> data structures in parallel.</p></li>
<li><p><strong>Parallel</strong> versions of <code>lapply()</code> and <code>Map()</code>, <code>mclapply()</code> and <code>mcMap()</code></p></li>
<li><p><strong>Rolling computations</strong>, showing how a new problem can be solved with for loops, or by building on top of <code>lapply()</code>.</p></li>
</ul>

<h3>Vector output: <code>sapply</code> and <code>vapply</code></h3>

<p><code>sapply()</code> and <code>vapply()</code> are very similar to <code>lapply()</code> except they will simplify their output to produce an atomic vector. <code>sapply()</code> guesses, while <code>vapply()</code> takes an additional argument specifying the output type. <code>sapply()</code> is useful for interactive use because it saves typing, but if you use it inside your functions you will get weird errors if you supply the wrong type of input. <code>vapply()</code> is more verbose, but gives more informative error messages and never fails silently, so is better suited for use inside other functions.</p>

<p>The following example illustrates these differences.  When given a data frame <code>sapply()</code> and <code>vapply()</code> give the same results. When given an empty list, <code>sapply()</code> has no basis to guess the correct type of output, and returns <code>NULL</code>, instead of the more correct zero-length logical vector.</p>

<div class="chunk" id="unnamed-chunk-271"><div class="rcode"><div class="source"><pre class="knitr r">sapply(mtcars, is.numeric)
</pre></div>

<div class="output"><pre class="knitr r">##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
## TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
</pre></div>

<div class="source"><pre class="knitr r">vapply(mtcars, is.numeric, logical(1))
</pre></div>

<div class="output"><pre class="knitr r">##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
## TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
</pre></div>

<div class="source"><pre class="knitr r">sapply(list(), is.numeric)
</pre></div>

<div class="output"><pre class="knitr r">## list()
</pre></div>

<div class="source"><pre class="knitr r">vapply(list(), is.numeric, logical(1))
</pre></div>

<div class="output"><pre class="knitr r">## logical(0)
</pre></div>

<p></div></div></p>

<p>If the function returns results of different types or lengths, <code>sapply()</code> will silently return a list, while <code>vapply()</code> will throw an error. <code>sapply()</code> is fine for interactive use because you&#39;ll normally notice if something went wrong, but it&#39;s dangerous when writing functions. </p>

<p>The following example illustrates a possible problem when extracting the class of columns in data frame: if you falsely assume that class only has one value and use <code>sapply()</code> you won&#39;t find out about the problem until some future function is given a list instead of a character vector.</p>

<div class="chunk" id="unnamed-chunk-272"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:10, y = letters[1:10])
sapply(df, class)
</pre></div>

<div class="output"><pre class="knitr r">##         x         y 
## "integer"  "factor"
</pre></div>

<div class="source"><pre class="knitr r">vapply(df, class, character(1))
</pre></div>

<div class="output"><pre class="knitr r">##         x         y 
## "integer"  "factor"
</pre></div>

<div class="source"><pre class="knitr r">
df2 <- data.frame(x = 1:10, y = Sys.time() + 1:10)
sapply(df2, class)
</pre></div>

<div class="output"><pre class="knitr r">## $x
## [1] "integer"
## 
## $y
## [1] "POSIXct" "POSIXt"
</pre></div>

<div class="source"><pre class="knitr r">vapply(df2, class, character(1))
</pre></div>

<div class="error"><pre class="knitr r">## Error: values must be length 1, but FUN(X[[2]]) result is length 2
</pre></div>

<p></div></div></p>

<p><code>sapply()</code> is a thin wrapper around <code>lapply()</code>, transforming a list into a vector in the final step; <code>vapply()</code> reimplements <code>lapply()</code> but assigns results into a vector (or matrix) of the appropriate type instead of into a list. The following code shows pure R implementation of the essence of <code>sapply()</code> and <code>vapply()</code>; the real functions have better error handling and preserve names, among other things. </p>

<div class="chunk" id="unnamed-chunk-273"><div class="rcode"><div class="source"><pre class="knitr r">sapply2 <- function(x, f, ...) {
  res <- lapply2(x, f, ...)
  simplify2array(res)
}

vapply2 <- function(x, f, f.value, ...) {
  out <- matrix(rep(f.value, length(x)), nrow = length(x))
  for (i in seq_along(x)) {
    res <- f(x[i], ...)
    stopifnot(
      length(res) == length(f.value), 
      typeof(res) == typeof(f.value)
    )
    out[i, ] <- res
  }
  out
}
vapply2(1:10, f, logical(1))
</pre></div>

<div class="error"><pre class="knitr r">## Error: typeof(res) == typeof(f.value) is not TRUE
</pre></div>

<p></div></div></p>

<p><img src="data:image/png;base64,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WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K8EgYCAAAQABJREFUeAHtnQn8V1P+/08riigt2heErG1MRUgkS8mSoSEmP0RjmWSsrT9+QwxG2QaVsWbP0s82JcJvGLKUyRoSSlKK9v49j//5zP18vp/t+/1s597P6zwe93s/37ue+7z3nvs67/f7nFNt0+ZklERABERABERABERABETAEwLVPcmHsiECIiACIiACIiACIiACloAEqh4EERABERABERABERABrwjU9Co3yowIiIAIiIAIhIjAqFGjvMztmDFjSpIv8SgJ9kieVBbUSN5WXZQIiIAIiEChCSACx44da6pXr+7VNG7cOFMKoSgehX7iyuv4sqBW4X6X4sXPJpuqMcdTKhWP+FzoPxEQgSgTGDlyZEnEYCamGzduzLRJQdaLR0GwluVBZUGt5G1XDTEemHjE89B/IiACIiACIiACuROQBbUKDFVDjIcmHvE89J8IiIAIiIAIiEBuBGRBzY2f9hYBERABERABERABEcgzAQnUPAPV4URABERABERABERABHIjIIGaGz/tLQIiIAIiIAIiIAIikGcCEqh5BqrDiYAIiIAIiIAIiIAI5EZAAjU3ftpbBERABERABERABEQgzwQkUPMMVIcTAREQAREQAREQARHIjYAEam78tLcIiIAIiIAIiIAIiECeCUig5hmoDicCIiACIiACIiACIpAbAQnU3PhpbxEQAREQAREQAREQgTwTkEDNM1AdTgREQAREQAREQAREIDcCEqi58dPeIiACIiACIiACIiACeSZQM8/H0+FEQAREQAQiQGDUqFERuIr/XMKYMWP+849+VYrA4sWLTePGjSu1T7KN33//fTNhwgTTtGlTc+mll5otttgibrM1a9aYV155xfTu3TtuebJ/XnzxRXPIIYeYatWqJVutZREgIAtqBG6iLkEEREAE8kkAMTd27FhTvXr1SEzjxo0zURPc+bzf6Y710UcfmZNOOsn8/ve/N0899ZRZuXJlus1TrkNQ7rXXXmannXYyTzzxhNlyyy3jtv3666/tshNOOCFueap/Dj30UPts/vzzz6k20fKQE4izoEbtBVaNOeRPZ8izr/cp5DewzLM/cuTISIm6jRs3lvkdrdrlr1ixwtStW9d88cUX5rbbbjMTJ040Xbp0Mf379zedO3e2IjGbIyM8X3jhBWsdHTFihFmwYEFsNyynLVq0sM/b6NGjY8vT/di0aZPZZ599bN42bNiQdT7SHVPr/CIQE6iuxpztw+HXZVTMjROnbl5xCy1JReDHH38022yzjalRo0aqTbJaTs2Wjxxp2LBhpk2bNvZ38M/UqVPN8ccfn7FwoRZfv35906hRo+Du3v7W++TtrVHGRMArApMnTzann366zVPPnj3NzJkz8+K2/uWXX8yUKVNyvtZFixaZ9evX2+OsXr3azl9//XUzZ84cW2736dPHDBw4MGXZTMXgtddeM3xX3nnnHbv/AQccEPc94Pr33ntvk6g/ELEdO3a0+7LjwoULTfPmze0x+EMecPEPHTrU3H777bHl+hENAjGByuWoxhyNm5rrVVx22WVm/vz5ZsCAAeaoo46KK0iyPTY1Ymrd7E8tu23btoaaOMLXJQQnhdYPP/xgxadbnmyOe+jcc8+N1cCTbePbMr1Pvt0R5UcE/COAOKO8xYLYvXt3K8gQXr4nBHCtWrXMY489ZnbeeWdz2GGHJc3yqlWrrIGClbfccovZdtttbTnujA1YQh944AHz+eefV9ifb9FVV11lhgwZYu666y7LCMEbjDt97733bOgA1t3g8goH04LQEYgTqKHLvTJcEAIupmfatGnm2WeftTVjxGqvXr1MvXr1sjonge4kYpZIJ598cpw4xTWDOE0sbOzGSf6cc845pmHDhoa4IwqkPffcM8lWWiQCIiAC4SKAQCNRFt555522jMvHFWy11VZm8ODBOR/qrbfeMlhMMTqQiEuuXbu2Lc9x82NBbdCgQcrzYJRAcGOQePXVV+MsoMGdEOiJ6f7777eLsOCecsop1khBDGzQ0LHHHnvYbXDz16wpSZPIMMz/q5FUke8eLgteVGp6TASG+5p44SmUcKvccccd1o1zySWXWHdNujzjjr/ooousy4YCiZab7du3j+3C+nfffdfgLgrWeCmEELKODa6v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zBAi4FrzvvHGG7ZRRXA71+oXq+wf//hHc8kllwRXl91vPBeu+5bvvvsuFkIDCNfX7ueff24rBZMnT7aVBqzVSiIgAiIgAuVLIPQClX45ccUjPmllfvLJJ1vr5//8z/9Ylw7uxEyJYGbikrp3725OOukkBTNnAlbG6+nrzvWDCAas9XRYnSwhzBCpPFM0vohCwoJMhc71BRicB5cHf7t+Al0XLi7GO8jDNSBgEAhiuG6//fbgav0WAREQAREoMwKhF6i45vORbrvttnwcRscoMwJYBGmAgUsfyyviizkWfCo+WFAZgWb8+PHek0FUMmKYE51BkUm8NuK0b9++9rqc2OQa3W/ic6koBpexDlEfbPnMMVy8N14LEuN4Dxw40I644j0oZVAEREAERKDgBEIvUAtOSCcQgTQE6KIM6zvdiDDCSocOHazIGjNmjBWuxDmHJWHpJPYWgUkMHtfixOekSZOsyLzqqqvycjkIU6ymeDwYNpG4VCUREAEREAERcAQkUB0JzUWgCgQQc1GxvhP3ed555yWlgFUYS3E+El1/IUjpY5f+JZVEQAREQAREIJGAvg6JRPS/CIhAQQnQhY+SCIiACIiACKQjUD3dSq0TAREQAREQAREQAREQgWITkEAtNnGdTwREQAREQAREQAREIC0BCdS0eLRSBERABERABERABESg2AQkUItNXOcTAREQAREQAREQARFIS0ACNS0erRQBERABERABERABESg2AbXiLzZxnU8EREAERCAyBMaOHevdtZCnkSNHliRf4lES7JE8qQRqJG+rLkoEREAERKDQBEaNGlXoU1Tp+KNHjzalyFspzpkNoFLxyCZv2iY1AQnU1Gy0RgREQAREQATSEvBVlKXNdAFXikcB4ZbZoRWDWmY3XJcrAiIgAiIgAiIgAr4TkAW1CndIMTbx0MQjnof+EwEREAEREAERyI2ABGol+fnqvihVjI14VPIB0uYiIAIiIAIiIAIZCUigZkRUcQNfRVnFnBZniXgUh7POIgIiIAIiEC0C8kCmvp8SqKnZaI0IiIAIiIAIiIAIFISAr8adUnlkEyFLoCYS0f8iIAIiIAIiIAIiUAQCGzduLMJZwnkKteIP531TrkVABERABERABEJMYMyYMQYXf/Xq1b2axo0bV5J+dBNvpSyoiUT0vwiIgBcEKLhnzpzpRV4SMzFr1qyS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adWqlWnevLmd6tatW7Z8dOEiIAIiIAK/EpBA1ZMgAiJQNAL16tUzderUMT///LNZvHixnebMmWO22GILU7NmTbNq1SqDQO3cuXPR8qQTiYAIiIAI+EdALn7/7olyJAKRJdC2bVuzevXqCte3Zs0as2HDBmtNveeeeyqs1wIREAEREIHyIiALanndb12tCBSVwA8//GDmzp1rpw8//NB8/PHH1kL6008/xfLBaFa1atUyQ4YMMQMGDDDVqlWLrdMPERABERCB8iQggVqe911XLQJ5J7B+/XorQOfNm2cQowhTXPm777676dChgxk8eLDZbbfdzN/+9jfz5JNP2vNvueWWZscdd7RxqU2aNMl7nnRAERABEfCBAOFLP/74o52aNm1qGjRo4EO2vM6DBKrXt0eZEwF/CSxdutQgRhGizD/55BPbyAlB2rVrVytIW7ZsWeEC9t57bytQEafDhg0zffv2rbCNFoiACIhAGAl8+umnZvLkyWbZsmVWjOItoqLuPEW//PKL2XXXXc3EiRPDeHlFzbMEalFx62QiEE4CGzduNBS0jz76qBWjCFIKWiyjTKeffrotdLfaaquMF9ijRw/Tu3dvc9ZZZ8mKkJGWNhABEQgTgZdfftm8+eabZt26dXHZpgxFpFKBv+666+LW6Z/kBCRQk3PRUhEoawJYR51llPm///1vg/ikO6j99tvPCtIWLVpUiRGt9S+99NIq7audREAERMBnAgMHDjSPPPJIhSwSZ9+6dWszfvx4U7t27QrrtaAiAQnUiky0RATKkgCidOzYsdZCSkt7Fzv6+9//3jz++OO28dIFF1xQlmx00SIgAiKQDQEGIiGe/ptvvolZUamUU6G/4YYbbJd62RxH2xgjgaqnQAREwBJYu3at6datm21NT6f5wTRt2jSDi0pJBERABESgIgEaht5///22gn/kkUeaqVOn2o0QpwxIcuONN1ovVMU9tSQVAQnUVGS0XATKjAAtSw899NAyu2pdrgjkRmDUqFG5HaBAe48ZM6ZAR05/2HLj8fbbb5v77rvPLFq0yJx44onmyiuvtC58uth78cUXTcOGDc1NN91ktt566/TgtLYCAQnUCki0QAREQAREQAQyE0AEEhYzevTozBsXcQsnTt28WKcuFx6bNm0ys2fPthZTWuiffPLJ5pBDDrFDODvW/fr1M3ilLrzwQllOHZRKziVQKwmMzcuthpgJkXhkIqT1IiACUSUwcuRIL78JpQrJiTIPRrt76aWXzAMPPGDoJg9huv/++ycdXKR9+/bmsssui+pjX5TrkkCtJOZyqSFmi0U8siWl7URABERABMJIAEvos88+ax566CEbT0r/zZ07dw7jpYQqzxKoVbhdUa4hVgGHEY+qUNM+IiACIiACPhNg9CcaiNJtFP09861jNDyl4hCQQC0OZ51FBERABERABEQgBAQYkpRBSZ566inb7/P1119v2rRpE4KcRyuLEqjRup+6GhEQAREoWwJLliyxramxeHXv3t26Y8sWhi680gQWL15s3fgvvPCC6dWrl7ntttvMDjvsUOnjVGYHGtn5lsgT1uJSJwnUUt8BnV8EREAERCAvBOjSh/TFF1+YBx980NSrV8/27bt8+XJ185MXwtE8yFdffWUbPtEynz5MJ0+eXJRhmH1tYEyvFD7kTQI1mu+brqpIBL788ks77GfLli1tgda4cWNb46ZPPIa2o/PmbManL1J2Q3UaHy0LDqAvFgaXH81/JVCtWjWz/fbbm+HDhxu6AmKI3tdff9188sknZs2aNebaa6+1grVLly4Z38uvv/7avtN6f6P7dH300Ue2q6j33nvPHHvssbY/02L3V+qDEPT1DodeoF5yySU2NgR3DkMz1qhRw1fWylcECdDVCM8cNXAml6pXr267HvnjH/9o+8Lr2bOnW6V5FgR8L7R9sTBkgbJsN0Gs0qCFiXeT/ip33nlnG1f45z//2ey1115WrDJ6WqNGjSpw4ttCRfOuu+6y35gKG2hBaAm8++67VoxiaR84cKDhXlOWK/lFIPQC9eyzzzYvv/yymThxoiF+ZN9997WxR+vXrzeIBCURKCQBLKbbbrutYdSQYKIPQp6/Bg0a2CHubrnlluBq/c6CgO8iNYtL0CYeEUCADBgwwE6I1TfffNO89tpr5u6777ZeD4QqE/1XIkwZU510zjnnmAsuuMAcdthhHl2NslIVAljTGY6UkI+TTjrJjpzHUKRKfhII/Z1ps7llHdPgwYMNAfI8gNOnTzf/+te/bPzR448/bgVrkyZNMt6BBQsWqKackZI2gAAfL54xptWrV1eAgjhFvE6aNMkOe1dhAy0QAREoGYE6deqYAw880E50vj537lwrVq+66irzyy+/mBYtWsTyRmgA46i/8847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x9YaERABESgagVatWll3ufsABE+cbl1wu8Tf9OuI+GSksVTdOrl96AsV1z7COptEY6t8xZ5yTtcCOJtz53ObqIWjFDrGOp/sdaxwEECYIlAvv/zyWIZbt25tPS8uvEjhSjE09kdlw5UkUOP56T8REAGPCCBMU4nIdOvSXQKWWOeiS7edW1cZd32+xKk7d6prd+sLOY+aSC0kKx27/AgQm54Y4kOlUuFK+QtXql5+j5WuWAREQAREQAREQAQKQ4BKcKLXx7n/XbhScH26delySLgSophQpEzhSm0291ZCuFKiqE51fB/CleIsqIo5SnWrtFwEKk9A71PlmWkPERABEYgigXQhSenWpWMR9XClmECNmjtHMUfpHmutKzQBvU+FJqzji4AIiEB4CKQLSUq3Lt0VRj1cKSZQgRC1j2q6G6t1IlBoAnqfCk1YxxcBERABEYgqAcWgRvXO6rpEQAREQAREQAREIKQEJFBDeuOUbREQAREQAREQARGIKgEJ1KjeWV2XCIiACIiACIiACISUgARqSG+csi0CIiACIiACIiACUSUggRrVO6vrEgEREAEREAEREIGQEpBADemNU7ZFQAREQAREQAREIKoEJFCjemd1XSIgAiIgAiIgAiIQUgJx/aCG9BqUbREQAREQAREoCQEfR4wjTyNHjhSP/0+glDxKchMiclIJ1IjcSF2GCIiACISBwLJly0yDBg3MqlWrTJ06dQz/t2vXzixdurTC+OW+X4+vg3GUaiRF8fD9iQ1X/iRQw3W/lFsREAERCDWB+vXrm549e5rmzZtbcYpYRdgw3GMYk6+irFQsxaNU5KN3XgnU6N1TXZEIiIAIeE1gxowZpkaNGqZatWpmu+22M1j8lERABEQgSKAoAvWWW24x06dPN0899ZQ99+TJk82jjz4a+z+YoTD8VsxR/F0Sj3ge+k8ERCA9Aayl06ZNM/369TP33HNP+o21VgREoCwJVNu0ORX6ytevX29q1aplHnroIdO3b19Tr149s3DhQuviKfS5dXwREAEREAG/CPDZCbr0N27caK2pfuVSuREBESglgaIE/dSsWdO8+eab5sQTT7Ti9Nprr5U4LeVd17lFQAREoIQEBg0aZM+OMCVhSVUSAREQgSCBolhQ3Qnbtm1rFixYYDZs2BBXe3brNRcBERABEYg2gSVLlpjGjRubxYsXm0aNGsUaSs2fP9+0b98+2hevqxMBEciaQFEsqOQGYcpEGjp0qJ3rjwiIgAiIQHkRQJTi4mdOolU//0ucltdzoKsVgUwEiiJQKXywnk6cONH88MMP5o477jBvvfVWprxpvQiIgAiIgAiIgAiIQBkSKEor/hEjRtiuRM455xyLeNKkSaZr165GgfFl+MTpkkVABERABERABEQgA4GixqBmyItWi4AIiIAIiIAIiIAIiIApiotfnEVABERABERABERABEQgWwISqNmS0nYiIAIiIAIiIAIiIAJFISCBWhTMOokIiIAIiIAIiIAIiEC2BP4fdiib0A9dYPQAAAAASUVORK5CYII=" alt="Schematics of `sapply` and `vapply`, cf `lapply`."/></p>

<p><code>vapply()</code> and <code>sapply()</code> are like <code>lapply()</code>, but with different outputs; the following section discusses <code>Map()</code>, which is like <code>lapply()</code> but with different inputs. </p>

<h3>Multiple inputs: <code>Map</code> (and <code>mapply</code>)</h3>

<p>With <code>lapply()</code>, only one argument to the function varies; the others are fixed. This makes it poorly suited for some problems. For example, how would you find the weighted means when you have two lists, one of observations and the other of weights:</p>

<div class="chunk" id="unnamed-chunk-274"><div class="rcode"><div class="source"><pre class="knitr r"># Generate some sample data
xs <- replicate(10, runif(10), simplify = FALSE)
ws <- replicate(10, rpois(10, 5) + 1, simplify = FALSE)
</pre></div>

<p></div></div></p>

<p>It&#39;s easy to use <code>lapply()</code> to compute the unweighted means:</p>

<div class="chunk" id="unnamed-chunk-275"><div class="rcode"><div class="source"><pre class="knitr r">unlist(lapply(xs, mean))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 0.5198 0.6977 0.5292 0.5111 0.5197 0.4936 0.4433 0.4107 0.5178 0.5983
</pre></div>

<p></div></div></p>

<p>But how could we supply the weights to <code>weighted.mean()</code>? <code>lapply(x, means, w)</code> won&#39;t work because the additional arguments to <code>lapply()</code> are passed to every call. We could change looping forms:</p>

<div class="chunk" id="unnamed-chunk-276"><div class="rcode"><div class="source"><pre class="knitr r">unlist(lapply(seq_along(xs), function(i) {
  weighted.mean(xs[[i]], ws[[i]])
}))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 0.4962 0.7034 0.5161 0.5342 0.5508 0.5059 0.4348 0.4279 0.5516 0.5716
</pre></div>

<p></div></div></p>

<p>This works, but is a little clumsy. A cleaner alternative is to use <code>Map</code>, a variant of <code>lapply()</code>, where all arguments vary.  This lets us write:</p>

<div class="chunk" id="unnamed-chunk-277"><div class="rcode"><div class="source"><pre class="knitr r">unlist(Map(weighted.mean, xs, ws))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 0.4962 0.7034 0.5161 0.5342 0.5508 0.5059 0.4348 0.4279 0.5516 0.5716
</pre></div>

<p></div></div></p>

<p>(Note that the order of arguments is a little different: with <code>Map()</code> the function is the first argument, with <code>lapply()</code> it&#39;s the second.</p>

<p>This is equivalent to:</p>

<div class="chunk" id="unnamed-chunk-278"><div class="rcode"><div class="source"><pre class="knitr r">stopifnot(length(x) == length(w))
out <- vector("list", length(x))
for (i in seq_along(x)) {
  out[[i]] <- weighted.mean(x[[i]], w[[i]])
}
</pre></div>

<p></div></div></p>

<p>There&#39;s a natural equivalence between <code>Map()</code> and <code>lapply()</code> because you can always convert a <code>Map()</code> to an <code>lapply()</code> that iterates over indices, but using <code>Map()</code> is more concise, and more clearly indicates what you&#39;re trying to do.</p>

<p><code>Map</code> is useful whenever you have two (or more) lists (or data frames) that you need to process in parallel. For example, another way of standardising columns, is to first compute the means and then divide by them. We could do this with <code>lapply()</code>, but if we do it in two steps, we can more easily check the results at each step, which is particularly important if the first step is more complicated.</p>

<div class="chunk" id="unnamed-chunk-279"><div class="rcode"><div class="source"><pre class="knitr r">mtmeans <- lapply(mtcars, mean)
mtmeans[] <- Map(`/`, mtcars, mtmeans)

# In this case, equivalent to
mtcars[] <- lapply(mtcars, function(x) x / mean(x))
</pre></div>

<p></div></div></p>

<p>If some of the arguments should be fixed, and not varying, you need to use an anonymous function:</p>

<div class="chunk" id="unnamed-chunk-280"><div class="rcode"><div class="source"><pre class="knitr r">Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws)
</pre></div>

<p></div></div></p>

<p>We&#39;ll see a more compact way to express the same idea in the next chapter.</p>

<!-- This should be a sidebar -->

<p>You may be more familiar with <code>mapply()</code> than <code>Map()</code>. I prefer <code>Map()</code> because:</p>

<ul>
<li><p>it is equivalent to <code>mapply</code> with <code>simplify = FALSE</code>, which is almost always what you want. </p></li>
<li><p>Instead of using an anonymous function to provide constant inputs, <code>mapply</code> has the <code>MoreArgs</code> argument which takes a list of extra arguments that will be supplied, as is, to each call. This breaks R&#39;s usual lazy evaluation semantics, and is inconsistent with other functions.</p></li>
</ul>

<p>In brief, <code>mapply()</code> is more complicated for little gain.</p>

<h3>Rolling computations</h3>

<p>What if you need a for-loop replacement that doesn&#39;t exist in base R? You can often create your own by recognising common looping structures and implementing your own wrapper. For example, you might be interested in smoothing your data using a rolling (or running) mean function:</p>

<div class="chunk" id="roll-mean"><div class="rcode"><div class="source"><pre class="knitr r">rollmean <- function(x, n) {
  out <- rep(NA, length(x))

  offset <- trunc(n / 2)
  for (i in (offset + 1):(length(x) - n + offset - 1)) {
    out[i] <- mean(x[(i - offset):(i + offset - 1)])
  }
  out
}
x <- seq(1, 3, length = 1e2) + runif(1e2)
plot(x)
</pre></div>

<div class="rimage default"><img src="data:image/png;base64,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" title="plot of chunk roll-mean" alt="plot of chunk roll-mean" class="plot" /></div>

<div class="source"><pre class="knitr r">lines(rollmean(x, 5), col = "blue", lwd = 2)
</pre></div>

<div class="error"><pre class="knitr r">## Error: only 0's may be mixed with negative subscripts
</pre></div>

<div class="source"><pre class="knitr r">lines(rollmean(x, 10), col = "red", lwd = 2)
</pre></div>

<div class="error"><pre class="knitr r">## Error: only 0's may be mixed with negative subscripts
</pre></div>

<p></div></div></p>

<p>But if the noise was more variable (i.e. it had a longer tail) you might worry that your rolling mean was too sensitive to the occasional outlier and instead implement a rolling median. </p>

<div class="chunk" id="outliers"><div class="rcode"><div class="source"><pre class="knitr r">x <- seq(1, 3, length = 1e2) + rt(1e2, df = 2) / 3
plot(x)
</pre></div>

<div class="rimage default"><img src="data:image/png;base64,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" title="plot of chunk outliers" alt="plot of chunk outliers" class="plot" /></div>

<div class="source"><pre class="knitr r">lines(rollmean(x, 5), col = "red", lwd = 2)
</pre></div>

<div class="error"><pre class="knitr r">## Error: only 0's may be mixed with negative subscripts
</pre></div>

<p></div></div></p>

<p>To modify <code>rollmean()</code> to <code>rollmedian()</code> all you need to do is replace <code>mean</code> with <code>median</code> inside the loop, but instead of copying and pasting to create a new function, we could extract the idea of computing a rolling summary into its own function:</p>

<div class="chunk" id="roll-apply"><div class="rcode"><div class="source"><pre class="knitr r">rollapply <- function(x, n, f, ...) {
  out <- rep(NA, length(x))

  offset <- trunc(n / 2)
  for (i in (offset + 1):(length(x) - n + offset - 1)) {
    out[i] <- f(x[(i - offset):(i + offset - 1)], ...)
  }
  out
}
plot(x)
</pre></div>

<div class="rimage default"><img src="data:image/png;base64,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" title="plot of chunk roll-apply" alt="plot of chunk roll-apply" class="plot" /></div>

<div class="source"><pre class="knitr r">lines(rollapply(x, 5, median), col = "red", lwd = 2)
</pre></div>

<div class="error"><pre class="knitr r">## Error: only 0's may be mixed with negative subscripts
</pre></div>

<p></div></div></p>

<p>You might notice that the internal loop looks pretty similar to a <code>vapply()</code> loop, so we could rewrite the function as:</p>

<div class="chunk" id="roll-apply-2"><div class="rcode"><div class="source"><pre class="knitr r">rollapply <- function(x, n, f, ...) {
  offset <- trunc(n / 2)
  locs <- (offset + 1):(length(x) - n + offset - 1)
  vapply(locs, function(i) f(x[(i - offset):(i + offset - 1)], ...),
    numeric(1))
}
</pre></div>

<p></div></div></p>

<p>This is effectively the same as the implementation in <code>zoo::rollapply()</code>, but it provides many more features and much more error checking.</p>

<h3>Parallelisation</h3>

<p>One thing that&#39;s interesting about the defintions of <code>lapply()</code> is that because each iteration is isolated from all others, the order in which they are computed doesn&#39;t matter. For example, while <code>lapply3()</code>, defined below, scrambles the order in which computation occurs, the results are same every time:</p>

<div class="chunk" id="unnamed-chunk-281"><div class="rcode"><div class="source"><pre class="knitr r">lapply3 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in sample(seq_along(x))) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
unlist(lapply3(1:10, sqrt))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 1.000 1.414 1.732 2.000 2.236 2.449 2.646 2.828 3.000 3.162
</pre></div>

<div class="source"><pre class="knitr r">unlist(lapply3(1:10, sqrt))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 1.000 1.414 1.732 2.000 2.236 2.449 2.646 2.828 3.000 3.162
</pre></div>

<p></div></div></p>

<p>This has a very important consequence: since we can compute each element in any order, it&#39;s easy to dispatch the tasks to different cores, and compute in parallel.  This is what <code>mclapply()</code> (and <code>mcMap</code>) in the parallel package do:</p>

<div class="chunk" id="unnamed-chunk-282"><div class="rcode"><div class="source"><pre class="knitr r">library(parallel)
unlist(mclapply(1:10, sqrt, mc.cores = 4))
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 1.000 1.414 1.732 2.000 2.236 2.449 2.646 2.828 3.000 3.162
</pre></div>

<p></div></div></p>

<p>In this case <code>mclapply()</code> is actually slower than <code>lapply()</code>, because the cost of the individual computations is low, and some additional work is needed to send the computation to the different cores then collect the results together. If we take a more realistic example, generating bootstrap replicates of a linear model, we see more of an advantage:</p>

<div class="chunk" id="unnamed-chunk-283"><div class="rcode"><div class="source"><pre class="knitr r">boot_df <- function(x) x[sample(nrow(x), rep = T), ]
rsquared <- function(mod) summary(mod)$r.square
boot_lm <- function(i) {
  rsquared(lm(mpg ~ wt + disp, data = boot_df(mtcars)))
}

system.time(lapply(1:500, boot_lm))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   1.143   0.002   1.177
</pre></div>

<div class="source"><pre class="knitr r">system.time(mclapply(1:500, boot_lm, mc.cores = 2))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.003   0.035   0.630
</pre></div>

<p></div></div></p>

<p>It is rare to get an exactly linear improvement with increasing number of cores, but if your code uses <code>lapply()</code> or <code>Map()</code>, this is an easy way to improve performance.</p>

<h3>Exercises</h3>

<ul>
<li><p>Use <code>vapply()</code> to:</p>

<ul>
<li>Compute the standard deviation of every column in a numeric data frame.</li>
<li>Compute the standard deviation of of every numeric column in a mixed data frame (Hint: you&#39;ll need to use <code>vapply()</code> twice)</li>
</ul></li>
<li><p>Recall: why is using <code>sapply()</code> to get the <code>class()</code> of each element in a data frame dangerous?</p></li>
<li><p>The following code simulates the performance of a t-test for non-normal data. Use <code>sapply()</code> and an anonymous function to extract the p value from every trial. Extra challenge: get rid of the anonymous function and use the <code>&#39;[[</code> function.  </p></li>
</ul>

<div class="chunk" id="unnamed-chunk-284"><div class="rcode"><div class="source"><pre class="knitr r">trials <- replicate(100, t.test(rpois(10, 10), rpois(7, 10)), 
  simplify = FALSE)
</pre></div>

<p></div></div></p>

<ul>
<li><p>Implement a combination of <code>Map()</code> and <code>vapply()</code> to create an <code>lapply()</code> variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix).  What arguments should the function take?</p></li>
<li><p>What does <code>replicate()</code> do? What sort of for loop does it eliminate? Why do its arguments differ from <code>lapply()</code> and friends?</p></li>
<li><p>Implement <code>mcsapply()</code>, a multicore version of <code>sapply()</code>.  Can you implement <code>mcvapply()</code> a parallel version of <code>vapply()</code>? Why/why not?</p></li>
<li><p>Implement a version of <code>lapply()</code> that supplies <code>f()</code> with both the name and the value of each component.</p></li>
</ul>

<h2>Data structure functionals</h2>

<p>As well as functionals that exist to eliminate common looping constructs, another family of functionals works to eliminate loops for common data manipulation tasks. In this section, we&#39;ll give a brief overview of the available options. We&#39;ll show you some of the available options, hint at how they can help you, and point you in the right direction to learn more. We&#39;ll cover three categories of data structure functionals:</p>

<ul>
<li><p>base functions for working with matrices: <code>apply()</code>, <code>sweep()</code> and <code>outer()</code></p></li>
<li><p><code>tapply()</code>, which summarises a vector divided into groups by the values of another vector</p></li>
<li><p>the <code>plyr</code> package, which generalises the ideas of <code>tapply()</code> to work with inputs of data frames, lists and arrays, and outputs of data frames, lists, arrays and nothing</p></li>
</ul>

<h3>Matrix and array operations</h3>

<p>So far, all the functionals we&#39;ve seen work with 1d input structures. The three functionals in this section provide useful tools for working with high-dimensional data structures.  <code>apply()</code> is a variant of <code>sapply()</code> that works with matrices and arrays. You can think of it as an operation that summarises a matrix or array, collapsing each row or column to a single number.  It has four arguments: </p>

<ul>
<li><code>X</code>, the matrix or array to summarise</li>
<li><code>MARGIN</code>, an integer vector giving the dimensions to summarise over, 1 = rows, 2 = columns, etc</li>
<li><code>FUN</code>, a summary function</li>
<li><code>...</code> other arguments passed on to <code>FUN</code></li>
</ul>

<p>A typical example of <code>apply()</code> looks like this</p>

<div class="chunk" id="unnamed-chunk-285"><div class="rcode"><div class="source"><pre class="knitr r">a <- matrix(1:20, nrow = 5)
apply(a, 1, mean)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  8.5  9.5 10.5 11.5 12.5
</pre></div>

<div class="source"><pre class="knitr r">apply(a, 2, mean)
</pre></div>

<div class="output"><pre class="knitr r">## [1]  3  8 13 18
</pre></div>

<p></div></div></p>

<p>There are a few caveats to using <code>apply()</code>: it does not have a simplify argument, so you can never be completely sure what type of output you will get. This generally means that <code>apply()</code> is not safe to use inside a function, unless you carefully check the inputs. <code>apply()</code> is also not idempotent in the sense that if the summary function is the identity operator, the output is not always the same as the input:</p>

<div class="chunk" id="unnamed-chunk-286"><div class="rcode"><div class="source"><pre class="knitr r">a1 <- apply(a, 1, identity)
identical(a, a1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">identical(a, t(a1))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">a2 <- apply(a, 2, identity)
identical(a, a2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>(You can put high-dimensional arrays back in the right order using <code>aperm()</code>, or use <code>plyr::aaply()</code>, which is idempotent.)</p>

<p><code>sweep()</code> is a function that allows you to &quot;sweep&quot; out the values of a summary statistic. It is most often useful in conjunction with <code>apply()</code> and it often used to standardise arrays in some way. The following example scales a matrix so that all values lie between 0 and 1.</p>

<div class="chunk" id="unnamed-chunk-287"><div class="rcode"><div class="source"><pre class="knitr r">x <- matrix(runif(20), nrow = 4)
x1 <- sweep(x, 1, apply(x, 1, min))
</pre></div>

<div class="error"><pre class="knitr r">## Error: dim(X) must have a positive length
</pre></div>

<div class="source"><pre class="knitr r">x2 <- sweep(x1, 1, apply(x1, 1, max), "/")
</pre></div>

<div class="error"><pre class="knitr r">## Error: dim(X) must have a positive length
</pre></div>

<p></div></div></p>

<p>The final matrix functional is <code>outer()</code>. It&#39;s a little different in that it takes multiple vector inputs and creates a matrix or array output where the input function is run over every combination of the inputs:</p>

<div class="chunk" id="unnamed-chunk-288"><div class="rcode"><div class="source"><pre class="knitr r"># Create a times table
outer(1:9, 1:9, "*")
</pre></div>

<div class="output"><pre class="knitr r">##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    1    2    3    4    5    6    7    8    9
##  [2,]    2    4    6    8   10   12   14   16   18
##  [3,]    3    6    9   12   15   18   21   24   27
##  [4,]    4    8   12   16   20   24   28   32   36
##  [5,]    5   10   15   20   25   30   35   40   45
##  [6,]    6   12   18   24   30   36   42   48   54
##  [7,]    7   14   21   28   35   42   49   56   63
##  [8,]    8   16   24   32   40   48   56   64   72
##  [9,]    9   18   27   36   45   54   63   72   81
</pre></div>

<p></div></div></p>

<p>Good places to learn more about <code>apply()</code> and friends are:</p>

<ul>
<li><a href="http://petewerner.blogspot.com/2012/12/using-apply-sapply-lapply-in-r.html">&quot;Using apply, sapply, lapply in R&quot;</a> by Peter Werner.</li>
<li><a href="http://rforpublichealth.blogspot.no/2012/09/the-infamous-apply-function.html">&quot;The infamous apply function&quot;</a> by Slawa Rokicki.</li>
<li><a href="http://forgetfulfunctor.blogspot.com/2011/07/r-apply-function-tutorial-with-examples.html">&quot;The R apply function – a tutorial with examples&quot;</a> by axiomOfChoice.</li>
<li>The stack overflow question <a href="http://stackoverflow.com/questions/3505701">&quot;R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate vs&quot;</a>.</li>
</ul>

<h3>Group apply</h3>

<p>You can think about <code>tapply()</code> as a generalisation to <code>apply()</code> that allows for &quot;ragged&quot; arrays, where each row can have different numbers of columns. This is often needed when you&#39;re trying to summarise a data set. For example, imagine you&#39;ve collected some pulse rate from a medical trial, and you want to compare the two groups:</p>

<div class="chunk" id="unnamed-chunk-289"><div class="rcode"><div class="source"><pre class="knitr r">pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))

tapply(pulse, group, length)
</pre></div>

<div class="output"><pre class="knitr r">##  A  B 
## 10 12
</pre></div>

<div class="source"><pre class="knitr r">tapply(pulse, group, mean)
</pre></div>

<div class="output"><pre class="knitr r">##    A    B 
## 69.9 75.5
</pre></div>

<p></div></div></p>

<p>It&#39;s easiest to understand how <code>tapply()</code> works by first creating a &quot;ragged&quot; data structure from the inputs. This is the job of the <code>split()</code> function, which takes two inputs and returns a list, where all the elements in the first vector with equal entries in the second vector get put in the same element of the list:</p>

<div class="chunk" id="unnamed-chunk-290"><div class="rcode"><div class="source"><pre class="knitr r">split(pulse, group)
</pre></div>

<div class="output"><pre class="knitr r">## $A
##  [1] 71 69 66 76 68 74 71 67 67 70
## 
## $B
##  [1] 78 75 77 74 77 78 75 76 75 72 71 78
</pre></div>

<p></div></div></p>

<p>Then you can see that <code>tapply()</code> is just the combination of <code>split()</code> and <code>sapply()</code>:</p>

<div class="chunk" id="unnamed-chunk-291"><div class="rcode"><div class="source"><pre class="knitr r">tapply2 <- function(x, group, f, ..., simplify = TRUE) {
  pieces <- split(x, group)
  sapply(pieces, f, simplify = simplify)
}
tapply2(pulse, group, length)
</pre></div>

<div class="output"><pre class="knitr r">##  A  B 
## 10 12
</pre></div>

<div class="source"><pre class="knitr r">tapply2(pulse, group, mean)
</pre></div>

<div class="output"><pre class="knitr r">##    A    B 
## 69.9 75.5
</pre></div>

<p></div></div></p>

<p>Be able to rewrite our <code>tapply()</code> as a combination of <code>split()</code> and <code>sapply()</code> is a good indication that we&#39;ve been able to extract independent pieces that we can recombine to solve new problems.</p>

<h3>The plyr package</h3>

<p>One challenge with using the base functionals is that they have grown organically over time, and have been written by multiple authors. This means that they are not very consistent. For example,</p>

<ul>
<li><p>The simplify argument is called <code>simplify</code> in <code>tapply()</code> and <code>sapply()</code>, but <code>SIMPLIFY</code> for <code>mapply()</code>, and <code>apply()</code> lacks the argument altogether.</p></li>
<li><p><code>vapply()</code> is a variant of <code>sapply()</code> that allows you to describe what the output should be, but there are no corresponding variants of <code>tapply()</code>, <code>apply()</code>, or <code>Map()</code>.</p></li>
<li><p>The first to most functionals is the vector, but the first argument to <code>Map()</code> is the function.</p></li>
</ul>

<p>This makes learning these operators challenging, as you have to memorise all of the variations. Additionally, if you think about the combination of input and output types, base R only provides a partial set of functions:</p>

<table><thead>
<tr>
<th></th>
<th>list</th>
<th>data frame</th>
<th>array</th>
</tr>
</thead><tbody>
<tr>
<td>list</td>
<td>lapply</td>
<td></td>
<td>sapply</td>
</tr>
<tr>
<td>data frame</td>
<td>by</td>
<td></td>
<td></td>
</tr>
<tr>
<td>array</td>
<td></td>
<td></td>
<td>apply</td>
</tr>
</tbody></table>

<p>This was one of the driving forces behind the creation of the plyr package, which provides consistently named functions with consistently named arguments and implements all combinations of input and output data structures:</p>

<table><thead>
<tr>
<th></th>
<th>list</th>
<th>data frame</th>
<th>array</th>
</tr>
</thead><tbody>
<tr>
<td>list</td>
<td>llply</td>
<td>ldply</td>
<td>laply</td>
</tr>
<tr>
<td>data frame</td>
<td>dlply</td>
<td>ddply</td>
<td>daply</td>
</tr>
<tr>
<td>array</td>
<td>alply</td>
<td>adply</td>
<td>aaply</td>
</tr>
</tbody></table>

<p>Each of these functions splits up the input, applies a function to each piece and then joins the results back together. Overall, this process is called &quot;split-apply-combine&quot;, and you can read more about it and plyr in <a href="http://www.jstatsoft.org/v40/i01/">The Split-Apply-Combine Strategy for Data Analysis</a>, an open-access article published in the Journal of Statistical Software.</p>

<h3>Exercises</h3>

<ul>
<li><p>How does <code>apply()</code> arrange the output.  Read the documentation and perform some experiments.</p></li>
<li><p>There&#39;s no equivalent to <code>split()</code> + <code>vapply()</code>. Should there be? When would it be useful? Implement it yourself.</p></li>
<li><p>Implement a pure R version of <code>split()</code>. (Hint: use unique and subseting)</p></li>
<li><p>What other types of input and output are missing? Brainstorm before you look up some answers in the <a href="http://www.jstatsoft.org/v40/i01/">plyr paper</a></p></li>
</ul>

<h2>Functional programming</h2>

<!-- 
  http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
  http://docs.scala-lang.org/overviews/collections/trait-traversable.html#operations_in_class_traversable

  Clojure and python documentation is not so useful
 -->

<p>Another way of thinking about functionals is as a set of general tools for altering, subsetting and collapsing lists. Every functional programming has three tools for this: <code>Map()</code>, <code>Reduce()</code>, and <code>Filter()</code>. We&#39;ve seen <code>Map()</code> already, and the following sections described <code>Reduce()</code>, a powerful tool for extending two-argument functions, and <code>Filter()</code>, a member of an important class of functionals that work with predicates, functions that return a single boolean.</p>

<h3><code>Reduce()</code></h3>

<p><code>Reduce()</code> recursively reduces a vector, <code>x</code>, to a single value by recursively calling a function <code>f</code> with two arguments at a time.  It combines the first two elements with <code>f</code>, then combines the result of that call with the third element, and so on. Reduce is also known as fold, because it folds together adjacent elements in the list.</p>

<p>The following two examples show what <code>Reduce</code> does with an infix and prefix function:</p>

<div class="chunk" id="unnamed-chunk-292"><div class="rcode"><div class="source"><pre class="knitr r">Reduce(`+`, 1:3)
((1 + 2) + 3)

Reduce(sum, 1:3)
sum(sum(1, 2), 3)
</pre></div>

<p></div></div></p>

<p>As you might have come to expect by now, the essence of <code>Reduce()</code> can be described by a simple for loop: </p>

<div class="chunk" id="unnamed-chunk-293"><div class="rcode"><div class="source"><pre class="knitr r">Reduce2 <- function(f, x) {
  out <- x[[1]]
  for(i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out  
}
</pre></div>

<p></div></div></p>

<p>The real <code>Reduce()</code> is more complicated because it includes arguments to control whether the values are reduced from the left or from the right (<code>right</code>), an optional initial value (<code>init</code>), and an option to output every intermediate result (<code>accumulate</code>).</p>

<p>Reduce is an elegant way of turning binary functions into functions that can deal with any number of arguments. It&#39;s useful for implementing many types of recursive operations, like merges and intersections (We&#39;ll see another use in the final case study). For example, imagine you had a list of numeric vectors, and you wanted to find the values that occurred in every element:</p>

<div class="chunk" id="unnamed-chunk-294"><div class="rcode"><div class="source"><pre class="knitr r">l <- replicate(5, sample(1:10, 15, rep = T), simplify = FALSE)
l
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
##  [1] 9 9 4 7 9 6 3 4 6 1 7 2 7 5 4
## 
## [[2]]
##  [1]  9  9  5  2  4  3  7  3  3  6  7  5 10  2  6
## 
## [[3]]
##  [1]  5  1  3  1  1 10  6  6  5  1  9  2  9  4  3
## 
## [[4]]
##  [1] 1 9 7 3 2 5 2 2 1 8 2 6 4 1 8
## 
## [[5]]
##  [1]  2  1  4 10  4  1  1  5 10  1  8  6  7  7  4
</pre></div>

<p></div></div></p>

<p>You could do that by intersecting each element in turn:</p>

<div class="chunk" id="unnamed-chunk-295"><div class="rcode"><div class="source"><pre class="knitr r">intersect(intersect(intersect(intersect(l[[1]], l[[2]]), 
  l[[3]]), l[[4]]), l[[5]])
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4 6 2 5
</pre></div>

<p></div></div></p>

<p>That&#39;s hard to read because of the dagwood sandwich problem, and is equivalent to:</p>

<div class="chunk" id="unnamed-chunk-296"><div class="rcode"><div class="source"><pre class="knitr r">Reduce(intersect, l)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4 6 2 5
</pre></div>

<p></div></div></p>

<h3>Predicate functionals</h3>

<p>A <strong>predicate</strong> is a function that returns a single <code>TRUE</code> or <code>FALSE</code>, like <code>is.character</code>, <code>all</code>, or <code>is.NULL</code>.  <code>is.na</code> isn&#39;t a predicate function because it returns a vector of values. Predicate functionals make it easy to apply predicates to lists or data frames.  There are a three useful predicate functionals in base R: <code>Filter()</code>, <code>Find()</code> and <code>Position()</code>.</p>

<ul>
<li><p><code>Filter</code>: returns a new vector containing only elements where the predicate is <code>TRUE</code>.</p></li>
<li><p><code>Find()</code>: return the first element that matches the predicate (or the last element if <code>right = TRUE</code>).</p></li>
<li><p><code>Position()</code>: return the position of the first element that matches the predicate (or the last element if <code>right = TRUE</code>).</p></li>
</ul>

<p>Another useful functional makes it easy to generate a logical vector from a list (or a data frame) and a predicate:</p>

<div class="chunk" id="unnamed-chunk-297"><div class="rcode"><div class="source"><pre class="knitr r">where <- function(x, f) {
  vapply(x, f, logical(1))
}
</pre></div>

<p></div></div></p>

<p>The following example shows how you might use these functionals with a data frame:</p>

<div class="chunk" id="unnamed-chunk-298"><div class="rcode"><div class="source"><pre class="knitr r">str(Filter(is.character, iris))
</pre></div>

<div class="output"><pre class="knitr r">## 'data.frame':   150 obs. of  0 variables
</pre></div>

<div class="source"><pre class="knitr r">where(iris, is.character)
</pre></div>

<div class="output"><pre class="knitr r">## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##        FALSE        FALSE        FALSE        FALSE        FALSE
</pre></div>

<div class="source"><pre class="knitr r">str(Find(is.character, iris))
</pre></div>

<div class="output"><pre class="knitr r">##  NULL
</pre></div>

<div class="source"><pre class="knitr r">Position(is.character, iris)
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<p></div></div></p>

<p>One function I use a lot is <code>compact()</code>:</p>

<div class="chunk" id="unnamed-chunk-299"><div class="rcode"><div class="source"><pre class="knitr r">compact <- function(x) Filter(function(y) !is.null(y), x)
</pre></div>

<p></div></div></p>

<p>It removes all null elements from a list - you&#39;ll see it again in the [[function operators]] chapter.</p>

<h3>Exercises</h3>

<ul>
<li><p>Use <code>Filter()</code> and <code>vapply()</code> to create a function that applies a summary statistic to every column in a data frame.</p></li>
<li><p>What&#39;s the relationship between <code>which()</code> and <code>Position()</code>? </p></li>
<li><p>Re-write <code>compact</code> to eliminate the anonymous function.</p></li>
<li><p>Implement <code>Any</code>, a function that takes a list and a predicate function, and returns <code>TRUE</code> if the predicate function returns <code>TRUE</code> for any of the inputs. Implement the complementary <code>All</code> function.</p></li>
<li><p>Implement the <code>span</code> function from Haskell, which given a list <code>x</code> and a predicate function <code>f</code>, returns the longest sequential run of elements where the predicate is true. (Hint: you might find <code>rle()</code> helpful. Make sure to read the source and figure out how it works)</p></li>
</ul>

<h2>Mathematical functionals</h2>

<!-- 
  find_funs("package:stats", fun_args, "upper")
  find_funs("package:stats", fun_args, "^f$")
-->

<p>Functionals are very common in mathematics. The limit, the maximum, the roots (the set of points where <code>f(x) = 0</code>), and the definite integral are all functionals: given a function, they return a single number (or a vector of numbers). At first glance, these functions don&#39;t seem to fit in with the theme of eliminating loops, but if you dig deeper you&#39;ll see all of them are implemented using an algorithm that involves iteration.</p>

<p>In this section we&#39;ll explore some of R&#39;s built-in mathematical functionals. There are three functions that work with functions that return a single numeric value:</p>

<ul>
<li><code>integrate</code>: find the area under the curve given by <code>f</code></li>
<li><code>uniroot</code>: find where <code>f</code> hits zero</li>
<li><code>optimise</code>: find location of lowest (or highest) value of <code>f</code></li>
</ul>

<p>Let&#39;s explore how these are used with a simple function, <code>sin</code>:</p>

<div class="chunk" id="unnamed-chunk-300"><div class="rcode"><div class="source"><pre class="knitr r">integrate(sin, 0, pi)
</pre></div>

<div class="output"><pre class="knitr r">## 2 with absolute error < 2.2e-14
</pre></div>

<div class="source"><pre class="knitr r">uniroot(sin, pi * c(1 / 2, 3 / 2))
</pre></div>

<div class="output"><pre class="knitr r">## $root
## [1] 3.142
## 
## $f.root
## [1] 1.225e-16
## 
## $iter
## [1] 2
## 
## $estim.prec
## [1] 6.104e-05
</pre></div>

<div class="source"><pre class="knitr r">optimise(sin, c(0, 2 * pi))
</pre></div>

<div class="output"><pre class="knitr r">## $minimum
## [1] 4.712
## 
## $objective
## [1] -1
</pre></div>

<div class="source"><pre class="knitr r">optimise(sin, c(0, pi), maximum = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## $maximum
## [1] 1.571
## 
## $objective
## [1] 1
</pre></div>

<p></div></div></p>

<p>In statistics, optimisation is often used for maximum likelihood estimation. Maximum likelihood estimation (MLE) is a natural fit for functional programming because we have a well defined problem domain and a general technique to solve it. In MLE, we have two sets of parameters: the data, which is fixed for a given problem, and the parameters, which will vary as we try to find the maximum. That fits naturally with closures because we can have two layers of parameters to a closure. Closures plus optimisation gives rise to an approach to solving MLE problems like the following.</p>

<p>First, we create a function that computes the negative log likelihood (NLL) for a given dataset. In R, it&#39;s common to use the negative since <code>optimise()</code> defaults to finding the minimum.</p>

<div class="chunk" id="unnamed-chunk-301"><div class="rcode"><div class="source"><pre class="knitr r">poisson_nll <- function(x) {
  n <- length(x)
  function(lambda) {
    n * lambda - sum(x) * log(lambda) # + terms not involving lambda
  }
}
</pre></div>

<p></div></div></p>

<p>With the general NLL in hand, we create two specific NLL functions for two datasets, and use <code>optimise()</code> to find the best values, given a generous starting range.</p>

<div class="chunk" id="unnamed-chunk-302"><div class="rcode"><div class="source"><pre class="knitr r">nll1 <- poisson_nll(c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)) 
nll2 <- poisson_nll(c(6, 4, 7, 3, 3, 7, 5, 2, 2, 7, 5, 4, 12, 6, 9)) 

optimise(nll1, c(0, 100))$minimum
</pre></div>

<div class="output"><pre class="knitr r">## [1] 32.1
</pre></div>

<div class="source"><pre class="knitr r">optimise(nll2, c(0, 100))$minimum
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5.467
</pre></div>

<p></div></div></p>

<p>We can verify these values are correct by using the analytic solution: in this case, it&#39;s just the mean of the data values, 32.1 and 5.45. </p>

<p>Another important mathematical functional is <code>optim()</code>. It is a generalisation of <code>optimise()</code> to more than one dimension. If you&#39;re interested in how <code>optim()</code> works, you might want to explore the <code>Rvmmin</code> package, which provides a pure-R implementation of R. Interestingly <code>Rvmmin</code> is no slower than <code>optim()</code>, even though it is written in R, not C: for this problem, the bottleneck is evaluating the function multiple times, not controlling the optimisation.</p>

<h3>Exercises</h3>

<ul>
<li><p>Implement the <code>arg_max</code> function. It should take a function, and a vector of inputs, returning the elements of the input where the function returns the highest number. For example, <code>arg_max(-10:5, function(x) x ^ 2)</code> should return -10. <code>arg_max(-5:5, function(x) x ^ 2)</code> should return <code>c(-5, 5)</code>.  Also implement the matching <code>arg_min</code>.</p></li>
<li><p>Challenge: read about the <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3">fixed point algorithm</a>. Complete the exercises using R.</p></li>
</ul>

<h2>Converting loops to functionals, and when it&#39;s not possible</h2>

<p>There are a wide class of for loops that do not naturally match of the functionals we&#39;ve described so far. Sometimes it&#39;s possible to torture your code to make it work, but it&#39;s usually not a good idea: for loops are verbose and not very expressive, but all R programmers are familiar with them. It takes a while before you can identify whether or not a for loop has a related vectorised solution, or a matching functional. It&#39;s also easy to go too far: trying to convert for loops that really should stay as loops.  This section provides some more resources for learning and highlights three types of loop that you shouldn&#39;t try and convert into a functional:</p>

<ul>
<li>modifying in place</li>
<li>recursive functions</li>
<li>while loops</li>
</ul>

<p>Stackoverflow is a good resource for learning more about converting for loops to use functionals. A couple of questions and answers that I think are particularly helpful are:</p>

<ul>
<li><a href="http://stackoverflow.com/a/14520342/16632">&quot;Alternative to loops in R&quot;</a></li>
<li><a href="http://stackoverflow.com/a/2970284/16632">&quot;Speed up the loop operation in R&quot;</a></li>
</ul>

<p>You can also look for other similar questions that have cropped up since I wrote this with a <a href="http://stackoverflow.com/search?tab=votes&amp;q=%5br%5d%20for%20loop">search</a></p>

<h3>Modifying in place</h3>

<p>If you need to modify part of an existing data frame, it&#39;s often better to use a for loop. For example, the following code sample performs a variable-by-variable transformation by matching the names of a list of functions to the names of variables in a data frame.</p>

<div class="chunk" id="unnamed-chunk-303"><div class="rcode"><div class="source"><pre class="knitr r">trans <- list(
  disp = function(x) x * 0.0163871,
  am = function(x) factor(x, levels = c("auto", "manual"))
)
for(var in names(trans)) {
  mtcars[[var]] <- trans[[var]](mtcars[[var]])
}
</pre></div>

<p></div></div></p>

<p>We couldn&#39;t normally use <code>lapply()</code> to replace this loop directly, but it is <em>possible</em> to replace the loop with <code>lapply()</code> by using <code>&lt;&lt;-</code>:</p>

<div class="chunk" id="unnamed-chunk-304"><div class="rcode"><div class="source"><pre class="knitr r">lapply(names(trans), function(var) {
  mtcars[[var]] <<- trans[[var]](mtcars[[var]])
})
</pre></div>

<p></div></div></p>

<p>We&#39;ve eliminated the for loop, but our code is longer and we&#39;ve had to use an unusual language feature, <code>&lt;&lt;-</code>. And to understand what <code>mtcars[[var]] &lt;&lt;- ...</code> does, you have to understand not only how <code>&lt;&lt;-</code> works, but also what <code>x[[y]] &lt;&lt;- z</code> does behind the scenes. We&#39;ve taken a simple, easily understood for loop, and turned it into something few people will understand: not a good idea!</p>

<h3>Recursive relationships</h3>

<p>Another case where it&#39;s hard to convert a for loop into a functional is when the relationship is defined recursively. For example, exponential smoothing smoothes data values by taking a weighted average of the current and previous point. The <code>exps()</code> function below implements exponential smoothing with a for loop.</p>

<div class="chunk" id="unnamed-chunk-305"><div class="rcode"><div class="source"><pre class="knitr r">exps <- function(x, alpha) {
  s <- numeric(length(x) + 1)
  for (i in seq_along(s)) {
    if (i == 1) {
      s[i] <- x[i]
    } else {
      s[i] <- alpha * x[i - 1] + (1 - alpha) * s[i - 1]
    }
  }
  s
}
x <- runif(10)
exps(x, 0.5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.4393 0.4393
</pre></div>

<p></div></div></p>

<p>We can&#39;t eliminate the for loop because none of the functionals we&#39;ve seen allow the output at position <code>i</code> to depend on the input  and output at position <code>i - 1</code>. </p>

<p>If we encountered this pattern a lot, we could create our own function. I&#39;ve called it <code>lbapply()</code>, where <code>lb</code> is short for lookback.</p>

<div class="chunk" id="unnamed-chunk-306"><div class="rcode"><div class="source"><pre class="knitr r">lbapply <- function(x, f, init = x[1], ...) {
  out <- numeric(length(x))
  out[1] <- init
  for(i in seq(2, length(x))) {
    out[i] <- f(x[i - 1], out[i - 1], ...)
  }  
  out
}

f <- function(x, out, alpha) alpha * x + (1 - alpha) * out
lbapply(x, f, alpha = 0.5)
</pre></div>

<div class="error"><pre class="knitr r">## Error: replacement has length zero
</pre></div>

<p></div></div></p>

<p>This is only worthwhile if we need this function frequently: otherwise it just places an additional cognitive burden on the reader.</p>

<p>Another solution for eliminate the for loop in these cases is to <a href="http://en.wikipedia.org/wiki/Recurrence_relation#Solving">solve the recurrence relation</a>, removing the recursion and replacing it explicit references. This requires a new set of tools, and is mathematically challenging, but it can pay off by producing a simpler function. For exponential smoothing, it is possible to rewrite in terms of <code>i</code>:</p>

<div class="chunk" id="unnamed-chunk-307"><div class="rcode"><div class="source"><pre class="knitr r">exps1 <- function(x, alpha) {
  n <- length(x)
  i <- seq_along(x) - 1
  cumsum(alpha * rev(x[-1]) * (1 - alpha) ^ i[-n]) + 
    (1 - alpha) ^ (n - 1) * x[1]
}
exps1(x, 0.5)
</pre></div>

<div class="output"><pre class="knitr r">## numeric(0)
</pre></div>

<p></div></div></p>

<p>It&#39;s arguable whether or not that&#39;s more understandable for this case, but it may be useful for your problem. We&#39;ll see another example of a function defined recursively, the Fibonacci series, in the [[SoftwareSystems]] chapter.</p>

<h3>While loops</h3>

<p>Another type of looping construct in R is the <code>while</code> loop: this keeps running code until a condition is met. <code>while</code> loops are more general than <code>for</code> loops because you can rewrite every for loop as a while loop, but you can&#39;t do the opposite.  For example, this for loop:</p>

<div class="chunk" id="unnamed-chunk-308"><div class="rcode"><div class="source"><pre class="knitr r">for (i in 1:10) print(i)
</pre></div>

<p></div></div></p>

<p>Can be turned into this while loop:</p>

<div class="chunk" id="unnamed-chunk-309"><div class="rcode"><div class="source"><pre class="knitr r">i <- 1
while(i <= 10) {
  print(i)
  i <- i + 1
}
</pre></div>

<p></div></div></p>

<p>Not every while loop can be turned into a for loop, because many while loops don&#39;t know in advance how many times they will be run:</p>

<div class="chunk" id="unnamed-chunk-310"><div class="rcode"><div class="source"><pre class="knitr r">i <- 0
while(TRUE) {
  if (runif(1) > 0.9) break
  i <- i + 1
}
</pre></div>

<p></div></div></p>

<p>This is a common situation when you&#39;re writing simulations: one of the random parameters in your simulation may be how many times a process occurs.</p>

<p>In some cases, like above, you may be able to remove the loop by recongnising some special feature of the problem. For example, the above problem is counting how many times a Bernoulli trial with p = 0.1 is run before it is successful: this is a geometric random variable so you could replace the above code with <code>i &lt;- rgeom(1, 0.1)</code>.  Similar to solving recurrence relations, this is extremely difficult to do in general, but you&#39;ll get big gains if you can do it for your situation. </p>

<h2>A family of functions</h2>

<p>The following case study shows how you can use functionals to start small, with very simple functions, then build them up into more complicated and featureful tools. We&#39;ll start with a simple idea, adding two numbers together, and show how we can extend it to summing multiple numbers, computing parallel sums, cumulative sums, and sums for arrays. While we&#39;ll illustrate the ideas with addition, and you can use exactly the same ideas for multiplication, smallest and largest, and string concatenation to generate a wide family of functions, including over 20 functions provided in base R.</p>

<p>We&#39;ll start by defining a very simple plus function, that takes two scalar arguments:</p>

<div class="chunk" id="unnamed-chunk-311"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(x, y) {
  stopifnot(length(x) == 1, length(y) == 1, 
    is.numeric(x), is.numeric(y))
  x + y
}
</pre></div>

<p></div></div></p>

<p>(We&#39;re using R&#39;s existing addition operator here, which does much more, but the focus in this section is on how we can take very very simple functions and extend them to do more).</p>

<p>We really should also have some way to deal with missing values. A helper function will make this a bit easier: if <code>x</code> is missing it should return <code>y</code>, if <code>y</code> is missing it should returns <code>x</code>, and if both <code>x</code> and <code>y</code> are missing then it should returns another argument to the function: <code>identity</code>. (We&#39;ll talk a bit later about while we&#39;ve called it identity). This function is probably a bit more general than what we need now, but it will come in handy when you implement other binary operators.</p>

<div class="chunk" id="unnamed-chunk-312"><div class="rcode"><div class="source"><pre class="knitr r">rm_na <- function(x, y, identity) {
  if (is.na(x) && is.na(y)) {
    identity
  } else if (is.na(x)) {
    y
  } else {
    x
  }  
}
rm_na(NA, 10, 0)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<div class="source"><pre class="knitr r">rm_na(10, NA, 0)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<div class="source"><pre class="knitr r">rm_na(NA, NA, 0)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<p></div></div></p>

<p>That allows us to write a version of <code>add</code> that can deal with missing values if needed: (and it often is!)</p>

<div class="chunk" id="unnamed-chunk-313"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(x, y, na.rm = FALSE) {
  if (na.rm && (is.na(x) || is.na(y))) rm_na(x, y, 0) else x + y
}
add(10, NA)
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<div class="source"><pre class="knitr r">add(10, NA, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 10
</pre></div>

<div class="source"><pre class="knitr r">add(NA, NA)
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<div class="source"><pre class="knitr r">add(NA, NA, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<p></div></div></p>

<p>Why did we pick an identity of <code>0</code>? Why should <code>add(NA, NA, na.rm = TRUE)</code> return 0?  Well, for every other input it returns a numeric vector of length 1, so it should do that even if both arguments are missing values. We next needs to figure out what that number should be. We can use a special property of add to work this out: add is associative, which the order of addition doesn&#39;t matter. In other words, the following two function calls should return the same value:</p>

<div class="chunk" id="unnamed-chunk-314"><div class="rcode"><div class="source"><pre class="knitr r">add(add(3, NA, na.rm = TRUE), NA, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<div class="source"><pre class="knitr r">add(3, add(NA, NA, na.rm = TRUE), na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<p></div></div></p>

<p>That implies that <code>add(NA, NA, na.rm = TRUE)</code> must be 0.</p>

<p>Now we have the basics working, we can extend this function to deal with more complicated inputs. The first way we might want to extend it is add more than two numbers together. This is a simple application of <code>Reduce</code>: if the input is <code>c(1, 2, 3)</code>, then we want to compute <code>add(1, add(2, 3))</code>:</p>

<div class="chunk" id="unnamed-chunk-315"><div class="rcode"><div class="source"><pre class="knitr r">r_add <- function(xs, na.rm = TRUE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs)
}
r_add(c(1, 4, 10))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 15
</pre></div>

<p></div></div></p>

<p>This looks good, but we need to test it for a few special cases:</p>

<div class="chunk" id="unnamed-chunk-316"><div class="rcode"><div class="source"><pre class="knitr r">r_add(NA, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<div class="source"><pre class="knitr r">r_add(numeric())
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<p></div></div></p>

<p>These are incorrect: in the first case we get a missing value even thought we&#39;ve explicitly asked for them to be ignored, and in the second case we get <code>NULL</code>, instead of a length 1 numeric vector (as for every other set of inputs).</p>

<p>The two problems are related: if we give <code>Reduce()</code> a length one vector it doesn&#39;t have anything to reduce, so it just returns the input; if we give it a length 0 input it always returns <code>NULL</code>.  There are two ways to fix this: we can concatenate <code>0</code> to every input vector, or we can use the <code>init</code> argument to <code>Reduce()</code> (which effectively does the same thing):</p>

<div class="chunk" id="unnamed-chunk-317"><div class="rcode"><div class="source"><pre class="knitr r">r_add <- function(xs, na.rm = TRUE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), c(0, xs))
}
r_add(c(1, 4, 10))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 15
</pre></div>

<div class="source"><pre class="knitr r">r_add(NA, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<div class="source"><pre class="knitr r">r_add(numeric())
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<p></div></div></p>

<p>(This is equivalent to <code>sum()</code>)</p>

<p>It would also be nice to have a vectorised version of <code>add</code> so that we can give it two vectors of numbers to add in parallel. We have two ways, using <code>Map()</code> or <code>vapply()</code>, to implement this, neither of which are perfect. <code>Map()</code> returns a list (we want a numeric vector), and while <code>vapply()</code> returns a vector, we&#39;ll need to loop over the indices.</p>

<p>A few test cases makes sure that it behaves as we expect.  We&#39;re a bit stricter than base R here because we don&#39;t do recycling - you could add that if you wanted, but I find problems with recycling a common source of silent bugs.</p>

<div class="chunk" id="unnamed-chunk-318"><div class="rcode"><div class="source"><pre class="knitr r">v_add <- function(x, y, na.rm = TRUE) {
  stopifnot(length(x) == length(x), is.numeric(x), is.numeric(y))
  Map(function(x, y) add(x, y, na.rm = na.rm), x, y)
}

v_add <- function(x, y, na.rm = TRUE) {
  stopifnot(length(x) == length(x), is.numeric(x), is.numeric(y))
  vapply(seq_along(x), function(i) add(x[i], y[i], na.rm = na.rm),
    numeric(1))
}
v_add(1:10, 1:10)
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  2  4  6  8 10 12 14 16 18 20
</pre></div>

<div class="source"><pre class="knitr r">v_add(numeric(), numeric())
</pre></div>

<div class="output"><pre class="knitr r">## numeric(0)
</pre></div>

<div class="source"><pre class="knitr r">v_add(c(1, NA), c(1, NA))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 0
</pre></div>

<div class="source"><pre class="knitr r">v_add(c(1, NA), c(1, NA), na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2 0
</pre></div>

<p></div></div></p>

<p>(This is the usual behavior of <code>+</code> in R, although we have more control over missing values.)</p>

<p>Another variant of adding is the cumulative sum: it&#39;s like the reductive version, but we see every step along the way to the final result. This is easy to implement with <code>Reduce()</code>&#39;s <code>accumuate</code> argument:</p>

<div class="chunk" id="unnamed-chunk-319"><div class="rcode"><div class="source"><pre class="knitr r">c_add <- function(xs, na.rm = FALSE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs, 
    accumulate = TRUE)
}
c_add(1:10)
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  1  3  6 10 15 21 28 36 45 55
</pre></div>

<div class="source"><pre class="knitr r">c_add(10:1)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 10 19 27 34 40 45 49 52 54 55
</pre></div>

<p></div></div></p>

<p>(This function is equivalent to <code>cumsum()</code>)</p>

<p>Finally, we might want to define versions for more complicated data structures like matrices.  We could create <code>row</code> and <code>col</code> variants that sum across rows and columns respectively, or we could go the whole hog and define an array version that would sum across any arbitrary dimensions of an array.  These are easy to implement: they&#39;re a combination of <code>add()</code> and <code>apply()</code></p>

<div class="chunk" id="unnamed-chunk-320"><div class="rcode"><div class="source"><pre class="knitr r">row_sum <- function(x, na.rm = TRUE) apply(x, 1, add, na.rm = na.rm)
col_sum <- function(x, na.rm = TRUE) apply(x, 2, add, na.rm = na.rm)
arr_sum <- function(x, dim, na.rm = TRUE) apply(x, dim, add, na.rm = na.rm)
</pre></div>

<p></div></div></p>

<p>(These are equivalent to <code>rowSums()</code> and <code>colSums()</code>)</p>

<p>If every function we have created already has an existing equivalent in base R, why did we bother? There are two main reasons:</p>

<ul>
<li><p>we&#39;ve created all our variants from a very simple binary operator (<code>add</code>) and a well-tested functional (<code>Reduce</code>, <code>Map</code> and <code>apply</code>), so we know all the variants will behave consistently.</p></li>
<li><p>we&#39;ve seen the infrastructure for addition, so we can now adapt it to other operators that might not have the full suite variants in base R.</p></li>
</ul>

<p>The downside of this approach is that these implementations are unlikely to be efficient (For example, <code>colSums(x)</code> is much faster than <code>apply(x, 2, sum)</code>). However, even if they don&#39;t turn out to be fast enough, they are still a good starting point because they are less likely to have bugs; and when you create faster versions (maybe using [[Rcpp]]), you can compare results to make sure your fast versions are still correct.</p>

<p>If you enjoyed this section, you might also enjoy <a href="http://stevelosh.com/blog/2013/03/list-out-of-lambda/">List out of lambda</a>, a blog article by Steve Losh that explores how you can produces higher level language structures (like lists) out of more primitive language features (like closures, aka lambdas).</p>

<h3>Exercises</h3>

<ul>
<li><p>Implement <code>smaller</code> and <code>larger</code> functions that given two inputs return either the smaller or the larger value. Implement <code>na.rm = TRUE</code>: what should the identity be? (Hint: <code>smaller(x, smaller(NA, NA, na.rm = TRUE), na.rm = TRUE)</code> must be <code>x</code>, so <code>smaller(NA, NA, na.rm = TRUE)</code> must be bigger than any other value of x.). Use <code>smaller</code> and <code>larger</code> to implement equivalents of <code>min</code>, <code>max</code>, <code>pmin</code>, <code>pmax</code>, and new functions <code>row_min</code> and <code>row_max</code></p></li>
<li><p>Create a table that has add, multiply, smaller, larger, and, and or in the columns and binary operator, reducing variant, vectorised variant, array variants in the rows.</p>

<ul>
<li>Fill in the cells with the names of base R functions that perform each of the roles</li>
<li>Compare the names and arguments of the existing R functions. How consistent are they? How could you improve them?</li>
<li>Complete the matrix by implementing any missing functions</li>
</ul></li>
<li><p>How does <code>paste()</code> fit into this structure? What is the scalar binary function that underlies <code>paste()</code>? What are the <code>sep</code> and <code>collapse</code> arguments to <code>paste()</code> equivalent to? Are there are any paste variants that don&#39;t have existing R implementations?</p></li>
</ul>

<h1>Function operators</h1>

<p>In this chapter, you&#39;ll learn about function operators: functions that take one (or more) function as input and return a function as output. Function operators are a FP technique related to functionals, but where functionals abstract away common uses of loops, function operators abstract over common uses of anonymous functions. Like functionals, there&#39;s nothing you can&#39;t do without them; but they can make your code more readable, more expressive and faster to write. </p>

<p>Here&#39;s an example of a simple function operator (FO) that makes a function chatty, showing its input and output (albeit in a naive way). It&#39;s useful because it gives a window into functionals, and we can use it to see how <code>lapply()</code> and <code>mclapply()</code> execute code differently. (We&#39;ll explore this theme in more detail below with the fully-featured <code>tee()</code> function)</p>

<div class="chunk" id="unnamed-chunk-321"><div class="rcode"><div class="source"><pre class="knitr r">library(parallel)
chatty <- function(f) {
  function(x) {
    res <- f(x)
    cat(format(x), " -> ", format(res, digits = 3), "\n", sep = "")
    res
  }
}
s <- c(0.4, 0.3, 0.2, 0.1)
x2 <- lapply(s, chatty(Sys.sleep))
x2 <- mclapply(s, chatty(Sys.sleep))
</pre></div>

<p></div></div></p>

<pre><code class="r"># 0.3 -&gt; NULL
# 0.4 -&gt; NULL
# 0.1 -&gt; NULL
# 0.2 -&gt; NULL
</code></pre>

<p>In the last chapter, we saw that most built-in functionals, like <code>Reduce</code>, <code>Filter</code> and <code>Map</code>, have very few arguments, and we used anonymous functions to modify how they worked. In this chapter, we&#39;ll start to build up tools that replace standard anonymous functions with specialised equivalents that allow us to communicate our intent more clearly. For example, in the last chapter we used an anonymous function plus <code>Map</code> to supply fixed arguments:</p>

<div class="chunk" id="unnamed-chunk-322"><div class="rcode"><div class="source"><pre class="knitr r">Map(function(x, y) f(x, y, zs), xs, ys)
</pre></div>

<p></div></div></p>

<p>Later in this chapter, we&#39;ll learn about partial application and the <code>partial()</code> function. Partial application encapsulates the use of an anonymous function to supply default arguments, and leads to the following succinct code:</p>

<div class="chunk" id="unnamed-chunk-323"><div class="rcode"><div class="source"><pre class="knitr r">Map(partial(f, zs = zs), xs, yz)
</pre></div>

<p></div></div></p>

<p>This is an important use of FOs: you can eliminate parameters to a functional by instead transforming the input function. This approach allows your functionals to be more extensible: as long as the inputs and outputs of the function remain the same, your functional can be extended in ways you haven&#39;t thought of. </p>

<p>In this chapter, we&#39;ll explore four types of function operators (FOs). Function operators can:</p>

<ul>
<li><p><strong>add behaviour</strong> while leaving the function otherwise unchanged, like automatically logging when the function is run, ensuring a function is run only once, or delaying the operation of a function.</p></li>
<li><p><strong>change output</strong>, for example by returning a value if the function throws an error, or negating the result of a logical predicate.</p></li>
<li><p><strong>change input</strong>, like partially evaluating the function, converting a function that takes multiple arguments to a function that takes a list, or automatically vectorising a function.</p></li>
<li><p><strong>combine functions</strong>, for example, combining the results of predicate functions with boolean operators, or composing multiple function calls.</p></li>
</ul>

<p>For each type, we&#39;ll show you useful FOs, and how you can use them as another way of describing tasks in R: as combinations of multiple functions instead of combinations of arguments to a single function. The goal is not to provide an exhaustive list of every possible FO, but to show a selection and demonstrate how well with each other and in concert with functionals. For your own work, you will need to think about and experiment with what function operators help you solve recurring problems. </p>

<p>The examples in this chapter come from five years of creating function operators in different R packages (particularly plyr), and from reading about useful operators in other languages.</p>

<h3>In other languages</h3>

<p>Function operators are used extensively in FP languages like haskell, and are common in lisp, scheme and clojure. They are an important part of modern javascript programming, like in the <a href="http://underscorejs.org/">underscore.js</a> library, and are particularly common in coffescript, since the syntax for anonymous functions is so concise. Stack based languages like Forth and Factor use function operators almost exclusively, since it is rare to refer to variables by name. Python&#39;s decorators are just function operators by a <a href="http://stackoverflow.com/questions/739654/">different name</a>. They are very rare in Java, because it&#39;s difficult to manipulate functions (although possible if you wrap them up in strategy-type objects), and also rare in C++; while it&#39;s possible to create objects that work like functions (&quot;functors&quot;) by overloading the <code>()</code> operator, modifying these objects with other functions is not a common programming technique. That said, C++ 11 adds partial application (<code>std::bind</code>) to the standard library.</p>

<h2>Behavioural FOs</h2>

<p>The first class of FOs are those that leave the inputs and outputs of a function unchanged, but add some extra behaviour. In this section, we&#39;ll see functions that:</p>

<ul>
<li>log to disk everytime a function is run</li>
<li>add a delay to avoid swamping a server with work</li>
<li>print to console every n invocations (useful if you want to check on a long running process)</li>
<li>save time by caching previous computations</li>
</ul>

<p>To make these use cases concrete, imagine we want to download a long vector of urls with <code>download.file()</code>. That&#39;s pretty simple with <code>lapply()</code>:</p>

<div class="chunk" id="unnamed-chunk-324"><div class="rcode"><div class="source"><pre class="knitr r">lapply(urls, download.file, quiet = TRUE)
</pre></div>

<p></div></div></p>

<p>(This example ignores the fact that <code>download.file</code> also needs a file name, so pretend it has a useful default for the purposes of this exposition.)</p>

<p>Because we have a long list we want to print some output so that we know it&#39;s working (we&#39;ll print a <code>.</code> every ten urls), and we also want to avoid hammering the server, so we add a small delay to the function between each call. That leads to a rather more complicated for loop (we can no longer use <code>lapply()</code> because we need an external counter): </p>

<div class="chunk" id="unnamed-chunk-325"><div class="rcode"><div class="source"><pre class="knitr r">i <- 1
for(url in urls) {
  i <- i + 1
  if (i %% 10 == 0) cat(".")
  Sys.delay(1)
  download.file(url, quiet = TRUE) 
}
</pre></div>

<p></div></div></p>

<p>Reading this code is quite hard because we are using low-level functions, and it&#39;s not obvious (without some thought), what the overall objective is. In the remainder of this chapter we&#39;ll create FOs that encapsulate each of the modifications, allowing us to write:</p>

<div class="chunk" id="unnamed-chunk-326"><div class="rcode"><div class="source"><pre class="knitr r">lapply(urls, dot_every(10, delay_by(1, download.file)), quiet = TRUE)
</pre></div>

<p></div></div></p>

<h3>Useful behavioural FOs</h3>

<p>Implementing <code>delay_by</code> is straightforward, and follows the same basic template that we&#39;ll see for the majority of FOs in this chapter:</p>

<div class="chunk" id="unnamed-chunk-327"><div class="rcode"><div class="source"><pre class="knitr r">delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
system.time(runif(100))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0       0
</pre></div>

<div class="source"><pre class="knitr r">system.time(delay_by(1, runif)(100))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.001   0.000   1.001
</pre></div>

<p></div></div></p>

<p><code>dot_every</code> is a little bit more complicated because it needs to modify state in the parent environment using <code>&lt;&lt;-</code>. If it&#39;s not clear how this works, you might want to re-read the mutable state section in <a href="Functional-programming.html">Functional programming</a>.</p>

<div class="chunk" id="unnamed-chunk-328"><div class="rcode"><div class="source"><pre class="knitr r">dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}
x <- lapply(1:100, runif)
x <- lapply(1:100, dot_every(10, runif))
</pre></div>

<div class="output"><pre class="knitr r">## ..........
</pre></div>

<p></div></div></p>

<p>Notice that I&#39;ve made the function the last argument to each FO. This make it reads a little better when we compose multiple function operators. If the function was the first argument, then instead of:</p>

<div class="chunk" id="unnamed-chunk-329"><div class="rcode"><div class="source"><pre class="knitr r">download <- dot_every(10, delay_by(1, download.file))
</pre></div>

<p></div></div></p>

<p>we&#39;d have</p>

<div class="chunk" id="unnamed-chunk-330"><div class="rcode"><div class="source"><pre class="knitr r">download <- dot_every(delay_by(download.file, 1), 10)
</pre></div>

<p></div></div></p>

<p>which is a little harder to follow because the argument to <code>dot_every()</code> is far away from the its call.  That&#39;s sometimes called the <a href="http://en.wikipedia.org/wiki/Dagwood_sandwich">Dagwood sandwich</a> problem: you have too much filling (too many long arguments) between your slices of bread (parentheses).  I&#39;ve also tried to give my FOs names that you can read easily: delay by 1 (second), (print a) dot every 10 (invocations). The more clearly your code expresses your interent through function names, the easier it is for others (and future you) to understand the code.</p>

<p>Two other tasks that you can solve with a behaviour FO are:</p>

<ul>
<li>Logging a time stamp and message to a file everytime a function is run:</li>
</ul>

<div class="chunk" id="unnamed-chunk-331"><div class="rcode"><div class="source"><pre class="knitr r">log_to <- function(path, message, f) {
  stopifnot(file.exists(path))

  function(...) {
    cat(Sys.time(), ": ", message, sep = "", file = path, 
      append = TRUE)
    f(...)
  }
}
</pre></div>

<p></div></div></p>

<ul>
<li>Ensuring that if the first input is <code>NULL</code> then the output is <code>NULL</code> (the name is inspired by Haskell&#39;s maybe monad which fills a similar role in Haskell, making it possible for any function to work with a <code>NULL</code> argument).</li>
</ul>

<div class="chunk" id="unnamed-chunk-332"><div class="rcode"><div class="source"><pre class="knitr r">maybe <- function(f) {
  function(x, ...) {
    if (is.null(x)) return(NULL)
    f(x, ...)
  }
}
</pre></div>

<p></div></div></p>

<h3>Memoisation</h3>

<p>Another thing you might worry about when downloading multiple files is accidentally downloading the same file multiple times. You could avoid it by calling <code>unique</code> on the list of input urls, or manually managing a data structure that mapped the url to the result. An alternative approach is to use memoisation: a way of modifying a function to automatically cache its results.</p>

<div class="chunk" id="unnamed-chunk-333"><div class="rcode"><div class="source"><pre class="knitr r">library(memoise)
</pre></div>

<p></div></div></p>

<div class="chunk" id="unnamed-chunk-334"><div class="rcode"><div class="source"><pre class="knitr r">slow_function <- function(x) {
  Sys.sleep(1)
  10
}
system.time(slow_function())
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0       1
</pre></div>

<div class="source"><pre class="knitr r">system.time(slow_function())
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.000   0.000   1.001
</pre></div>

<div class="source"><pre class="knitr r">fast_function <- memoise(slow_function)
system.time(fast_function())
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.000   0.000   1.001
</pre></div>

<div class="source"><pre class="knitr r">system.time(fast_function())
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##       0       0       0
</pre></div>

<p></div></div></p>

<p>Memoisation is an example of a classic tradeoff in computer science: trading space for speed. A memoised function uses more memory (because it stores all of the previous inputs and outputs), but is much faster.</p>

<p>A somewhat more realistic use case is implementing the Fibonacci series (a topic we&#39;ll come back to [[software systems]]). The Fibonacci series is defined recursively: the first two values are 1 and 1, then f(n) = f(n - 1) + f(n - 2).  A naive version implemented in R is very slow because (e.g.) <code>fib(10)</code> computes <code>fib(9)</code> and <code>fib(8)</code>, and <code>fib(9)</code> computes <code>fib(8)</code> and <code>fib(7)</code>, and so on, so that the value for each location gets computed many many times.  Memoising <code>fib()</code> makes the implementation much faster because each value is only computed once, and then remembered.</p>

<div class="chunk" id="unnamed-chunk-335"><div class="rcode"><div class="source"><pre class="knitr r">fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.178   0.000   0.179
</pre></div>

<div class="source"><pre class="knitr r">system.time(fib(24))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.293   0.000   0.293
</pre></div>

<div class="source"><pre class="knitr r">
fib2 <- memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.004   0.000   0.004
</pre></div>

<div class="source"><pre class="knitr r">system.time(fib2(24))
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   0.001   0.000   0.000
</pre></div>

<p></div></div></p>

<p>It doesn&#39;t make sense to memoise all functions. The example below shows that a memoised random number generator is no longer random:</p>

<div class="chunk" id="unnamed-chunk-336"><div class="rcode"><div class="source"><pre class="knitr r">runifm <- memoise(runif)
runifm(5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.10818 0.83771 0.28084 0.06719 0.12512
</pre></div>

<div class="source"><pre class="knitr r">runifm(5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.10818 0.83771 0.28084 0.06719 0.12512
</pre></div>

<p></div></div></p>

<p>Once we understand <code>memoise()</code>, it&#39;s straightforward to apply it to our problem:</p>

<div class="chunk" id="unnamed-chunk-337"><div class="rcode"><div class="source"><pre class="knitr r">download <- dot_every(10, memoise(delay_by(1, download.file)))
</pre></div>

<p></div></div></p>

<p>This gives a function that we can easily use with <code>lapply()</code>. If something goes wrong with the loop inside <code>lapply()</code>, it can be difficult to tell what&#39;s going on; the next section shows how we can use FOs to open the curtain and look inside.</p>

<h3>Capturing function invocations</h3>

<p>One challenge with functionals is that it can be hard to see what&#39;s going on - it&#39;s not easy to pry open the internals like it is with a for loop. However, we can use FOs to help us.  The <code>tee</code> function, defined below, has three arguments, all functions: <code>f</code>, the original function; <code>on_input</code>, a function that&#39;s called with the inputs to <code>f</code>, and <code>on_output</code> a function that&#39;s called with the output from <code>f</code>.</p>

<div class="chunk" id="unnamed-chunk-338"><div class="rcode"><div class="source"><pre class="knitr r">ignore <- function(...) NULL
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    input <- if (nargs() == 1) c(...) else list(...)
    on_input(input)
    output <- f(...)
    on_output(output)
    output
  }
}
</pre></div>

<p></div></div></p>

<p>(The function is inspired by the unix <code>tee</code> shell command which is used to split streams of file operations up so that you can see what&#39;s happening or save intermediate results to a file. It&#39;s named after the <code>t</code> connector in plumbing)</p>

<p>We can use <code>tee</code> to look into how <code>uniroot</code> finds where <code>x</code> and <code>cos(x)</code> intersect:</p>

<div class="chunk" id="unnamed-chunk-340"><div class="rcode"><div class="source"><pre class="knitr r">g <- function(x) cos(x) - x
zero <- uniroot(g, c(-5, 5))

# The location where the function is evaluated
zero <- uniroot(tee(g, on_input = print), c(-5, 5))
</pre></div>

<div class="output"><pre class="knitr r">## [1] -5
## [1] 5
## [1] 0.283662
## [1] 0.875203
## [1] 0.72298
## [1] 0.738631
## [1] 0.739085
## [1] 0.739024
## [1] 0.739085
</pre></div>

<div class="source"><pre class="knitr r"># The value of the function
zero <- uniroot(tee(g, on_output = print), c(-5, 5))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5.28366
## [1] -4.71634
## [1] 0.676375
## [1] -0.234363
## [1] 0.0268568
## [1] 0.00076012
## [1] -0.000000260399
## [1] 0.000101887
## [1] -0.000000260399
</pre></div>

<p></div></div></p>

<p>Using <code>print()</code> allows us to see what&#39;s happening as the function runs, but it doesn&#39;t give us any ability to work with the values. Instead we might want to capture the sequence of the calls. To do that we create a function called <code>remember()</code> that remembers every argument it was called with, and retrieves them when coerced into a list. (The small amount of S3 magic that makes this simple is explained in the [[S3]] chapter).</p>

<div class="chunk" id="unnamed-chunk-342"><div class="rcode"><div class="source"><pre class="knitr r">remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }
  
  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
}
</pre></div>

<p></div></div></p>

<p>Now we can see exactly how uniroot zeros in on the final answer:</p>

<div class="chunk" id="uniroot-explore"><div class="rcode"><div class="source"><pre class="knitr r">locs <- remember()
vals <- remember()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
# FIXME: should need as.list.remember, but knitr environment
# seems to prevent S3 from finding the right method
x <- sapply(as.list.remember(locs), "[[", 1)
error <- sapply(as.list.remember(vals), "[[", 1)
plot(x, type = "b"); abline(h = 0.739, col = "grey50")
</pre></div>

<div class="rimage default"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAACfFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgAAAAAAAAPDw8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/f38AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+fn4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvLy8AAAAAAAAAAAAAAAAAAAAAAAAAAAArKysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKSkoAAAAAAAAAAAAAAAAAAAAAAAAAAABFRUUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABd2CwXAAAA1HRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFxgZGhscHR4fICAhIiIkJSYnKCkqKywtMDEyMzQ1Njk7PEBBQ0RERUZHS0xNTk9QUVNUVVZXWFlaW19hYmNlZmdoaWprbm9wcXJ0dXZ3d3h5fH1+f4CEhYaIiouMjY6PkJGSk5SVlpeYmZqbnp+goaKjpKanqKmqq6yvsLGysrO1trm6u729vr/AwcLDxMXFxsnKy8zNzs7Q0tPU1dbX2dvc3t/g4ePl5ufo6err7e7v8PP09fb3+Pn6+/z+/9Z1zg0AAAAJcEhZcwAACxIAAAsSAdLdfvwAAAodSURBVHic7d2Nc1xVGcfxs2l3ExqkmGykVTEmKpQCqbWVWmtRARUKVvAVGmoBRdZKCmIVg92o1FpbhSJqhV1jEaqmKdKC1IRNIktVhPqSrPcfcrOVzfSk6STec7In+/t+ZshenmGeeyffuXs3TDM1BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAteyw0I2CcW+Qq/+enPIVzDF3sLf6uvzXBgF+E1EV5U/PAbi4WNRyYGVtpzwgctfvgX3vexaGvTTQP2nPBBix9+zKSiJmP+bM8JHzQHd/zqa6Pu1I3c8QuLg2f8ycLVg6UjPOMXFj7ViyK8KFfhu6Lq4dovVfzsO242wwsPd/yyDRWPH3C+Ge74e6t/aL+vzXAgfvh0tlCaGO5tseeED1r88PmezmSqI5Oz54QPWvzwxUTlZcieEz5o8cP3l+/4ZHsmb88JHzQHz/i+kVKpkE3bc8IHjU/1oggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvymP4P3wZ4frtu7yF/9WHEK6fv9NbeN7qQ8YzXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXlT88MtnmBM+aPHDRw9fcNY54YPmIPzHj25qOMuc8EFzEN60PXxsy0XT5oQPmovwxqz83qsv2nPCB81NeGNSH7DnhA9a/PB3zDAnfND4OV6Uq/BdUfXwulzF6JNuNsML7nhRhBcVP3w6WyhNDPe22HPCBy1++HxPZzLVkcnZc8IHLX74YqLyMmTPCR+0+OH7y3d8sj2Tt+eED5qDZ3zfSKlUyKbtOeGDxqd6UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEFxU/fPveVWuPjz9zqT0nfNDih3/29uYTtzV+6vf2nPBBix++mDD/aiy/2HPCBy1++P27VuzsbrzlKXtO+KDFD9+848R49Mqei+w54YPGp3pRhBflKnxXVD286r6KowfdbIYXHu749OqKRx51vhnu8FYvKn74dLZQmhjubbHnhA9a/PD5ns5kqiOTs+eED5qT/3M3acieEz5o8cP3l+/4ZHsmb88JHzQHz/i+kVKpkE3bc8IHjU/1oggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rws7T8vW+u9SU4NcvwV05+WTenzfUVvu/AV3NfqPVFuDTL8EPdiab7p/1Zi3Oqq/Cb7zQm8aMVtb4Mh2YZ/sI9TxzPnj+nzXUV/vvvLn/54u5aX4ZDswy/6K6hl26Y2+a6Cv/1teUv3bfU+jIcmmX4w3uXvjU3t5J1Ff6Sg8vMqtzc3vLCNsvwm8r/NGyb0+a6Cm/ef+Dx3R21vgiX+HFOFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRRFeFOFFEV4U4UURXhThRcUP32fMymfH+99uzwkftPjhI2N+97XzPvNLe074oDkJX1piEi/bc8IHzUH4tyReeJtpHrPnhA9a/PBPjb7+953m0IP2nPBBc/GpvunSy8xtSXtK+KDx45woV+G7ourhdbmK0ZybzfCCO14U4UXFD5/OFkoTw70t9pzwQYsfPt/TmUx1ZKY90QkftPjhi4nKy7S/f5TwQYsfvr98xyfbM3l7TvigOXjG942USoVs2p4TPmh8qhdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQXRXhRhBdFeFGEF0V4UYQX5Sj8uukjwgfNUfho+ojwQYsf/lR0mj0nfNDih79i8Hru+IXHwVv90sceSBJ+oXHxjG/4yiHCLzRuPtytv3f6jPBB4+d4Ua7Cd0292V91X8XRg242wwsPd3x6dcX2O51vhjv+3uo33+prMxyIHz6dLZQmhntb7DnhgxY/fL6nM5nqyOTsOeGDFj98MVF5GbLnhA9a/PD95Ts+2Z7J23PCB83BM75vpFQqZNP2nPBB41O9KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKL8hf+9ih3htf+6tc/2H9Ofzszx6k2X+FtT7O/rvfX7MTsr+3+mp2Y/bXdX7MTs7+2+2t2YvbXdn/NTsz+2u6f0ZPsr+v9M2pkf13vBwAAAAAAwILT1n+yP105WrKvePQdHvdveH7s+Q3O95uGP047k5/9ny6MDVzpcb8xV5xyv35G2R2JHdnK0Y5sw9Yfetz/yhqzpuh8/2dz0bQzedn/nlcvMTc/52+/MUsHo3P9l46NdJrOQuXoxArTvMrj/sI1yWsLzvev/+gb362pM3nZ/8FvGtP8b3/7TeKx6+czfClpkhOVo/Fv/PPFNR73Xx1F0Ubn+41547s1dSY/+41ZvHOfx/13P2DmOXzq9LfrP1ubthzzuP/I1qZtA873nxE+5TX8R459d4m//esPJec1/Ei76RiuHBUbTdO4x/2l8n6fYabO5GV/4lv5yzxsr+6/N5q0zsspziZ7j7nnIWO6jNl9s/nkYY/7BzeZm7zd8V3VM/nav35wsYflU/urh/Ok7ddD+dbKKZf9pjiwwuP+ywdfPnK58/3/+25F1TP52r+9ckf62z/1FQAAAAAAAAAAAAAAAAAAAPh/Ref4N9Qxwosqp44+/9zJu03rIydHeyJzwQ+GRn9xsbnx8KIL/+Tht5kRisnwW8zKcfOTbCr57cjs+XAicc0zxuy9a093ra8NHk2GP2/y5VSLMa2ReW3yF13GjVk69ESi1tcGj6LTD/bIvF4O31Luf74xi5YZs/yl4021vjZ4VA3/6K7U4gfLLzuTDdv3mYbcpuz9tb42eFQN3/bTv4zcEZnWH4+NHmg12/abNw3N3y8bAwAAAAAAAAAAAAAAAAAWiP8CJxkVovz5eaQAAAAASUVORK5CYII=" title="plot of chunk uniroot-explore" alt="plot of chunk uniroot-explore" class="plot" /></div>

<div class="source"><pre class="knitr r">plot(error, type = "b"); abline(h = 0, col = "grey50")
</pre></div>

<div class="rimage default"><img src="data:image/png;base64,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" title="plot of chunk uniroot-explore" alt="plot of chunk uniroot-explore" class="plot" /></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li>What does the following function do? What would be a good name for it?</li>
</ul>

<div class="chunk" id="unnamed-chunk-343"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(g) {
  result <- NULL
  function(...) {
    if (is.null(result)) {
      result <<- g(...)
    }
    result
  }
}
runif2 <- f(runif)
runif2(5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.8520 0.3369 0.7967 0.1409 0.9580
</pre></div>

<div class="source"><pre class="knitr r">runif2(5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.8520 0.3369 0.7967 0.1409 0.9580
</pre></div>

<p></div></div></p>

<ul>
<li><p>Modify <code>delay_by()</code> so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called <code>g &lt;- delay_by(1, f); g(); Sys.sleep(2); g()</code> there shouldn&#39;t be an extra delay.</p></li>
<li><p>Write <code>wait_until()</code> which delays execution until a specific time. Or write <code>run_after()</code> which only runs a function after a specified time, returning <code>NULL</code> otherwise.</p></li>
<li><p>There are three places we could have added a memoise call: why did we choose the one we did?</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-344"><div class="rcode"><div class="source"><pre class="knitr r">download <- memoise(dot_every(10, delay_by(1, download.file)))
download <- dot_every(10, memoise(delay_by(1, download.file)))
download <- dot_every(10, delay_by(1, memoise(download.file)))
</pre></div>

<p></div></div></p>

<ul>
<li>Why is the <code>remember()</code> function inefficient? How could you implement it in more efficient way?</li>
</ul>

<h2>Output FOs</h2>

<p>The next step up in complexity is to modify the output of a function. This could be quite simple, or it could fundamentally change the operation of the function, returning something completely different to its usual output. In this section you&#39;ll learn about two simple modifications, <code>Negate()</code> and <code>failwith()</code>, and two fundamental modifications, <code>capture_it()</code> and <code>time_it()</code>.</p>

<h3>Minor modifications</h3>

<p><code>base::Negate</code> and <code>plyr::failwith</code> offer two minor, but useful, modifications of a function that are particularly handy in conjunction with functionals.</p>

<p><code>Negate</code> takes a function that returns a logical vector (a predicate function), and returns the negation of that function. This can be a useful shortcut when the function you have returns the opposite of what you need.  Its essence is very simple:</p>

<div class="chunk" id="unnamed-chunk-345"><div class="rcode"><div class="source"><pre class="knitr r">Negate <- function(f) {
  function(...) !f(...)
}
(Negate(is.null))(NULL)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<p>I often use this idea to make a <code>compact()</code> function that removes all null elements from a list:</p>

<div class="chunk" id="unnamed-chunk-346"><div class="rcode"><div class="source"><pre class="knitr r">compact <- function(x) Filter(Negate(is.null), x)
</pre></div>

<p></div></div></p>

<p><code>plyr::failwith()</code> turns a function that throws an error into a function that returns a default value when there&#39;s an error. Again, the essence of <code>failwith()</code> is simple, it&#39;s just a wrapper around <code>try()</code>, which captures errors and continues execution. (if you haven&#39;t seen <code>try()</code> before, it&#39;s discussed in more detail in the <a href="Exceptions-Debugging.html">exceptions and debugging</a> chapter):</p>

<div class="chunk" id="unnamed-chunk-347"><div class="rcode"><div class="source"><pre class="knitr r">failwith <- function(default = NULL, f, quiet = FALSE) {
  function(...) {
    out <- default
    try(out <- f(...), silent = quiet)
    out
  }
}
log("a")
</pre></div>

<div class="error"><pre class="knitr r">## Error: non-numeric argument to mathematical function
</pre></div>

<div class="source"><pre class="knitr r">failwith(NA, log)("a")
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<div class="source"><pre class="knitr r">failwith(NA, log, quiet = TRUE)("a")
</pre></div>

<div class="output"><pre class="knitr r">## [1] NA
</pre></div>

<p></div></div></p>

<p><code>failwith()</code> is very useful in conjunction with functionals: instead of the failure propagating and terminating the higher-level loop, you can complete the iteration and then find out what went wrong.  For example, imagine you&#39;re fitting a set of generalised linear models (glms) to a list of data frames. Sometimes glms fail because of optimisation problems. You still want to try to fit all the models, then once that&#39;s complete, look at the data sets that failed to fit:</p>

<div class="chunk" id="unnamed-chunk-348"><div class="rcode"><div class="source"><pre class="knitr r"># If any model fails, all models fail to fit:
models <- lapply(datasets, glm, formula = y ~ x1 + x2 * x3)
# If a model fails, it will get a NULL value 
models <- lapply(datasets, failwith(NULL, glm), 
  formula = y ~ x1 + x2 * x3)

# remove failed models (NULLs) with compact
ok_models <- compact(models)
# use where to extract the datasets corresponding to failed models
failed_data <- datasets[where(models, is.null)]
</pre></div>

<p></div></div></p>

<p>I think this is a great example of the power of combining functionals and function operators: it makes it easy to succinctly express what you need to solve a common data analysis problem.</p>

<h3>Changing what a function does</h3>

<p>Other output function operators can have a more profound affect on the operation of the function. Instead of returning the original return value, we can return some other effect of the function evaluation. Here&#39;s two examples:</p>

<ul>
<li>Return text that the function <code>print()</code>ed:</li>
</ul>

<div class="chunk" id="unnamed-chunk-349"><div class="rcode"><div class="source"><pre class="knitr r">capture_it <- function(f) {
  function(...) {
    capture.output(f(...))
  }
}
str_out <- capture_it(str)
str(1:10)
</pre></div>

<div class="output"><pre class="knitr r">##  int [1:10] 1 2 3 4 5 6 7 8 9 10
</pre></div>

<div class="source"><pre class="knitr r">str_out(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] " int [1:10] 1 2 3 4 5 6 7 8 9 10"
</pre></div>

<p></div></div></p>

<ul>
<li>Return how long a function took to run:</li>
</ul>

<div class="chunk" id="unnamed-chunk-350"><div class="rcode"><div class="source"><pre class="knitr r">time_it <- function(f) {
  function(...) {
    system.time(f(...))
  }
}
</pre></div>

<p></div></div></p>

<p><code>time_it()</code> allows us to rewrite some of the code from the functionals chapter:</p>

<div class="chunk" id="unnamed-chunk-351"><div class="rcode"><div class="source"><pre class="knitr r">compute_mean <- list(
  base = function(x) mean(x),
  sum = function(x) sum(x) / length(x)
)
x <- runif(1e6)

# Instead of using an anonymous function to time
lapply(compute_mean, function(f) system.time(f(x)))
</pre></div>

<div class="output"><pre class="knitr r">## $base
##    user  system elapsed 
##       0       0       0 
## 
## $sum
##    user  system elapsed 
##   0.000   0.000   0.001
</pre></div>

<div class="source"><pre class="knitr r">
# We can compose function operators
call_fun <- function(f, ...) f(...)
lapply(compute_mean, time_it(call_fun), x)
</pre></div>

<div class="output"><pre class="knitr r">## $base
##    user  system elapsed 
##   0.000   0.000   0.001 
## 
## $sum
##    user  system elapsed 
##       0       0       0
</pre></div>

<p></div></div></p>

<p>In this example, there&#39;s not a huge benefit to using function operators, because the composition is simple and we&#39;re applying the same operator to each function. Generally, using function operators is more effective when you are using multiple operators or if the gap between creating them and using them is large.</p>

<h3>Exercises</h3>

<ul>
<li><p>Create a <code>negative</code> function that flips the sign of the output from the function to which it&#39;s applied.</p></li>
<li><p>The <code>evaluate</code> package makes it easy to capture all the outputs (results, text, messages, warnings, errors and plots) from an expression. Create a function like <code>capture_it()</code> that also captures the warnings and errors generated by a function.</p></li>
<li><p>Create a FO that tracks files created or deleted in the working directory (Hint: use <code>setDiff()</code> and <code>dir()</code>).  What other global effects do functions have you might want to track?</p></li>
<li><p>Modify the final example to use <code>fapply()</code> from the <a href="Functionals.html">functionals</a> chapter instead of <code>lapply()</code>.</p></li>
</ul>

<h2>Input FOs</h2>

<p>The next step up in complexity is to modify the inputs of a function.Again, you can modify how a function works in a minor way (e.g., prefilling some of the arguments), or fundamentally change the inputs (e.g. converting inputs from scalar to vector, or vector to matrix).</p>

<h3>Prefilling function arguments: partial function application</h3>

<p>A common use of anonymous functions is to make a variant of a function that has certain arguments &quot;filled in&quot; already. This is called &quot;partial function application&quot;, and is implemented by <code>pryr::partial</code>. (Once you have read the computing on the language chapter, I encourage you to read the source code for <code>partial</code> and puzzle out how it works - it&#39;s only 5 lines of code!)</p>

<p><code>partial()</code> allows us to replace code like</p>

<div class="chunk" id="unnamed-chunk-352"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(a) g(a, b = 1)
compact <- function(x) Filter(Negate(is.null), x)
Map(function(x, y) f(x, y, zs), xs, ys)
</pre></div>

<p></div></div></p>

<p>with</p>

<div class="chunk" id="unnamed-chunk-353"><div class="rcode"><div class="source"><pre class="knitr r">f <- partial(g, b = 1)
compact <- partial(Filter, Negate(is.null))
Map(partial(f, zs = zs), xs, ys)
</pre></div>

<p></div></div></p>

<p>We can use this idea to simplify some of the code we used when working with lists of functions. Instead of:</p>

<div class="chunk" id="unnamed-chunk-354"><div class="rcode"><div class="source"><pre class="knitr r">funs2 <- list(
  sum = function(x, ...) sum(x, ..., na.rm = TRUE),
  mean = function(x, ...) mean(x, ..., na.rm = TRUE),
  median = function(x, ...) median(x, ..., na.rm = TRUE)
)
</pre></div>

<p></div></div></p>

<p>We can write:</p>

<div class="chunk" id="unnamed-chunk-355"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
funs2 <- list(
  sum = partial(sum, na.rm = TRUE),
  mean = partial(mean, na.rm = TRUE),
  median = partial(median, na.rm = TRUE)
)
</pre></div>

<p></div></div></p>

<p>But if you look closely you&#39;ll notice we&#39;re just applying a function to every element in a list, and that&#39;s the job of <code>lapply</code>. This allows us to reduce the code still further::</p>

<div class="chunk" id="unnamed-chunk-356"><div class="rcode"><div class="source"><pre class="knitr r">funs <- c(sum = sum, mean = mean, median = median)
funs2 <- lapply(funs, partial, na.rm = TRUE)
</pre></div>

<p></div></div></p>

<p>Let&#39;s think about a similar, but subtly different case. Say we have a numeric vector and we want to generate a list of trimmed means with that amount of trimming. The following code doesn&#39;t work because we want the first argument of <code>partial</code> to be fixed to mean. We could try specifying the argument name because fixed matching overrides positional, but that doesn&#39;t work because the <code>trims</code> end up supplied to the first argument of <code>mean</code>.</p>

<div class="chunk" id="unnamed-chunk-357"><div class="rcode"><div class="source"><pre class="knitr r">(trims <- seq(0, 0.9, length = 5))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.000 0.225 0.450 0.675 0.900
</pre></div>

<div class="source"><pre class="knitr r">funs3 <- lapply(trims, partial, `_f` = mean)
sapply(funs3, call_fun, c(1:100, (1:50) * 100))
</pre></div>

<div class="error"><pre class="knitr r">## Error: 'trim' must be numeric of length one
</pre></div>

<p></div></div></p>

<p>Instead we could use an anonymous function</p>

<div class="chunk" id="unnamed-chunk-358"><div class="rcode"><div class="source"><pre class="knitr r">funs4 <- lapply(trims, function(t) partial(mean, trim = t))
funs4[[1]]
</pre></div>

<div class="output"><pre class="knitr r">## function (...) 
## mean(trim = t, ...)
## <environment: 0x203208e8>
</pre></div>

<div class="source"><pre class="knitr r">sapply(funs4, call_fun, c(1:100, (1:50) * 100))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 75.5 75.5 75.5 75.5 75.5
</pre></div>

<p></div></div></p>

<p>But that doesn&#39;t work because each function gets a promise to evaluate <code>t</code>, and that promise isn&#39;t evaluated until all of the functions are run, by which time <code>t = 0.9</code>. To make it work you need to manually force the evaluation of t:</p>

<div class="chunk" id="unnamed-chunk-359"><div class="rcode"><div class="source"><pre class="knitr r">funs5 <- lapply(trims, function(t) {
  force(t)
  partial(mean, trim = t)
})
funs5[[1]]
</pre></div>

<div class="output"><pre class="knitr r">## function (...) 
## mean(trim = t, ...)
## <environment: 0x1f3edf70>
</pre></div>

<div class="source"><pre class="knitr r">sapply(funs5, call_fun, c(1:100, (1:50) * 100))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 883.7 235.6  75.5  75.5  75.5
</pre></div>

<p></div></div></p>

<p>When writing functionals, you can expect your users to know of <code>partial()</code> and not use <code>...</code> For example, instead of implementing <code>lapply()</code> like:</p>

<div class="chunk" id="unnamed-chunk-360"><div class="rcode"><div class="source"><pre class="knitr r">lapply2 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
unlist(lapply2(1:5, log, base = 10))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.0000 0.3010 0.4771 0.6021 0.6990
</pre></div>

<p></div></div></p>

<p>we could implement it as:</p>

<div class="chunk" id="unnamed-chunk-361"><div class="rcode"><div class="source"><pre class="knitr r">lapply3 <- function(x, f) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]])
  }
  out
}
unlist(lapply3(1:5, partial(log, base = 10)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.0000 0.3010 0.4771 0.6021 0.6990
</pre></div>

<p></div></div></p>

<p>Partial function application is straightforward in many functional programming languages, but it&#39;s not entirely clear how it should interact with R&#39;s lazy evaluation rules. The approach of <code>plyr::partial</code> takes is to create a function as similar as possible to the anonymous function you&#39;d create by hand. Peter Meilstrup takes a different approach in his <a href="https://github.com/crowding/ptools/">ptools package</a>; you might want to read about <code>%()%</code>, <code>%&gt;&gt;%</code> and <code>%&lt;&lt;%</code> if you&#39;re interested in the topic.</p>

<h3>Changing input types</h3>

<p>Instead of a minor change to the function&#39;s inputs, it&#39;s also possible to make a function work with a fundamentally different type of data. There are a few existing functions along these lines:</p>

<ul>
<li><p><code>base::Vectorize</code> converts a scalar function to a vector function. <code>Vectorize</code> takes a non-vectorised function and vectorises with respect to the arguments given in the <code>vectorizge.args</code> parameter. This doesn&#39;t give you any magical performance improvements, but it is useful if you want a quick and dirty way of making a vectorised function.</p>

<p>A mildly useful extension of <code>sample</code> would be to vectorize it with respect to size: this would allow you to generate multiple samples in one call.</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-362"><div class="rcode"><div class="source"><pre class="knitr r">sample2 <- Vectorize(sample, "size", SIMPLIFY = FALSE)
sample2(1:5, c(1, 1, 3))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 5
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 3 1 2
</pre></div>

<div class="source"><pre class="knitr r">sample2(1:5, 5:3)
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 2 4 5 1 3
## 
## [[2]]
## [1] 4 5 3 2
## 
## [[3]]
## [1] 2 5 1
</pre></div>

<p></div></div></p>

<pre><code>In this example we have used `SIMPLIFY = FALSE` to ensure that our newly vectorised function always returns a list. This is usually what you want. 
</code></pre>

<ul>
<li> <code>splat</code> converts a function that takes multiple arguments to a function that takes a single list of arguments.</li>
</ul>

<div class="chunk" id="unnamed-chunk-363"><div class="rcode"><div class="source"><pre class="knitr r">splat <- function (f) {
  function(args) {
    do.call(f, args)
  }
}
</pre></div>

<p></div></div></p>

<pre><code>This is useful if you want to invoke a function with varying arguments:
</code></pre>

<div class="chunk" id="unnamed-chunk-364"><div class="rcode"><div class="source"><pre class="knitr r">x <- c(NA, runif(100), 1000)
args <- list(
  list(x),
  list(x, na.rm = TRUE),
  list(x, na.rm = TRUE, trim = 0.1)
)
lapply(args, splat(mean))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 0.8885
## 
## [[2]]
## [1] 0.08739
## 
## [[3]]
## [1] 0.4042
</pre></div>

<p></div></div></p>

<ul>
<li><code>plyr::colwise()</code> converts a vector function to one that works with data frames:</li>
</ul>

<div class="chunk" id="unnamed-chunk-365"><div class="rcode"><div class="source"><pre class="knitr r">median(mtcars)
</pre></div>

<div class="error"><pre class="knitr r">## Error: need numeric data
</pre></div>

<div class="source"><pre class="knitr r">median(mtcars$mpg)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.9557
</pre></div>

<div class="source"><pre class="knitr r">plyr::colwise(median)(mtcars)
</pre></div>

<div class="error"><pre class="knitr r">## Error: need numeric data
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>Our previous <code>download()</code> function will only download a single file. How can you use <code>partial()</code> and <code>lapply()</code> to create a function that downloads multiple files at once? What are the pros and cons of using <code>partial()</code> vs. writing a function by hand?</p></li>
<li><p>Read the source code for <code>plyr::colwise()</code>. How does code work?  It performs three main tasks. What are they? How could you make <code>colwise</code> simpler by implementing each separate task as a function operator? (Hint: think about <code>partial</code>)</p></li>
<li><p>Write FOs that convert a function to return a matrix instead of a data frame, or a data frame instead of a matrix. (If you already know [[S3]], make these methods of <code>as.data.frame</code> and <code>as.matrix</code>)</p></li>
<li><p>You&#39;ve seen five functions that modify a function to change it&#39;s output from one form to another. What are they? Draw a table: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.</p></li>
<li><p>Look at all the examples of using an anonymous function to partially apply a function in this and the previous chapter. Replace the anonymous function with <code>partial</code>. What do you think of the result? Is it easier or harder to read?</p></li>
</ul>

<h2>Combining FOs</h2>

<p>Instead of operating on single functions, function operators can take multiple functions as input. One simple example of this is <code>plyr::each()</code> which takes a list of vectorised functions and returns a single function that applies each in turn to the input:</p>

<div class="chunk" id="unnamed-chunk-366"><div class="rcode"><div class="source"><pre class="knitr r">summaries <- plyr::each(mean, sd, median)
summaries(1:10)
</pre></div>

<div class="output"><pre class="knitr r">##   mean     sd median 
##  5.500  3.028  5.500
</pre></div>

<p></div></div></p>

<p>Two more complicated examples are combining functions through composition, or through boolean algebra. These are glue that join multiple functions together.</p>

<h3>Function composition</h3>

<p>An important way of combining functions is through composition: <code>f(g(x))</code>.  Composition takes a list of functions and applies them sequentially to the input. It&#39;s a replacement for the common anonymous function pattern where you chain together multiple functions to get the result you want:</p>

<div class="chunk" id="unnamed-chunk-367"><div class="rcode"><div class="source"><pre class="knitr r">sapply(mtcars, function(x) length(unique(x)))
</pre></div>

<div class="output"><pre class="knitr r">##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
##   25    3   27   22   22   29   30    2    1    3    6
</pre></div>

<p></div></div></p>

<p>A simple version of compose looks like this:</p>

<div class="chunk" id="unnamed-chunk-368"><div class="rcode"><div class="source"><pre class="knitr r">compose <- function(f, g) {
  function(...) f(g(...))
}
</pre></div>

<p></div></div></p>

<p>(<code>pryr::compose()</code> provides a fuller-featured alternative that can accept multiple functions).</p>

<p>This allows us to write:</p>

<div class="chunk" id="unnamed-chunk-369"><div class="rcode"><div class="source"><pre class="knitr r">sapply(mtcars, compose(length, unique))
</pre></div>

<div class="output"><pre class="knitr r">##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
##   25    3   27   22   22   29   30    2    1    3    6
</pre></div>

<p></div></div></p>

<p>Mathematically, function composition is often denoted with an infix operator, o, <code>(f o g)(x)</code>.  Haskell, a popular functional programming language, uses <code>.</code> in a similar manner.  In R, we can create our own infix function that works similarly:</p>

<div class="chunk" id="unnamed-chunk-370"><div class="rcode"><div class="source"><pre class="knitr r">"%.%" <- compose
sapply(mtcars, length %.% unique)
</pre></div>

<div class="output"><pre class="knitr r">##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
##   25    3   27   22   22   29   30    2    1    3    6
</pre></div>

<div class="source"><pre class="knitr r">
sqrt(1 + 8)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<div class="source"><pre class="knitr r">compose(sqrt, `+`)(1, 8)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<div class="source"><pre class="knitr r">(sqrt %.% `+`)(1, 8)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<p></div></div></p>

<p>Compose also allows for a very succinct implement of <code>Negate</code>: it&#39;s just a partially evaluated version of <code>compose()</code>.</p>

<div class="chunk" id="unnamed-chunk-371"><div class="rcode"><div class="source"><pre class="knitr r">Negate <- partial(compose, `!`)
</pre></div>

<p></div></div></p>

<p>We could also implement the standard deviation by breaking it down into a separate set of function compositions:</p>

<div class="chunk" id="unnamed-chunk-372"><div class="rcode"><div class="source"><pre class="knitr r">square <- function(x) x ^ 2
deviation <- function(x) x - mean(x)

sd <- sqrt %.% mean %.% square %.% deviation
sd(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2.872
</pre></div>

<p></div></div></p>

<p>This type of programming is called tacit or point-free programming.  (The term point free comes from use the of the word point to refer values in topology; this style is also derogatorily known as pointless). In this style of programming you don&#39;t explicitly refer to variables, focussing on the high-level composition of functions, rather than the low-level flow of data. Since we&#39;re using only functions and not parameters, we use verbs and not nouns, and this style leads to code that focusses on what&#39;s being done, not what it&#39;s being done to. This style is common in Haskell, and is the typical style in stack based programming languages like Forth and Factor. It&#39;s not a terribly natural or elegant style in R, but it is a useful tool to have in your toolbox.</p>

<p><code>compose()</code> is particularly useful in conjunction with <code>partial()</code>, because <code>partial()</code> allows you to supply additional arguments to the functions being composed.  One nice side effect of this style of programming is that it keeps the arguments to each function near the function name. This is important because code gets harder to understand as the size of the chunk of code you have to hold in your head grows.</p>

<p>Below I take the example from the first section of the chapter and modify it to use the two styles of function composition defined above. They are both longer than the original code but maybe easier to understand because the function and its arguments are closer together.  Note that we still have to read them from right to left (bottom to top): the first function called is the last one written. We could define <code>compose()</code> to work in the opposite direction, but in the long run, this is likely to lead to confusion since we&#39;d create a small part of the langugage that reads differently to every other part.</p>

<pre><code class="R">download &lt;- dot_every(10, memoise(delay_by(1, download.file)))

download &lt;- pryr::compose(
  partial(dot_every, 10),
  memoise, 
  partial(delay_by, 1), 
  download.file
)

download &lt;- partial(dot_every, 10) %.% 
  memoise %.% 
  partial(delay_by, 1) %.% 
  download.file
</code></pre>

<h3>Logical predicates and boolean algebra</h3>

<p>When I use <code>Filter()</code> and other functionals that work with logical predicates, I often find myself using anonymous functions to combine multiple conditions:</p>

<pre><code class="R">Filter(function(x) is.character(x) || is.factor(x), iris)
</code></pre>

<p>As an alternative, we could define some function operators that combine logical predicates:</p>

<pre><code class="R">and &lt;- function(f1, f2) {
  function(...) {
    f1(...) &amp;&amp; f2(...)
  }
}
or &lt;- function(f1, f2) {
  function(...) {
    f1(...) || f2(...)
  }
}
not &lt;- function(f1) {
  function(...) {
    !f1(...)
  }
}
</code></pre>

<p>which would allow us to write:</p>

<pre><code class="R">Filter(or(is.character, is.factor), iris)
</code></pre>

<p>This allows us to express arbitrarily complicated boolean expressing involving functions in a succinct way.</p>

<h3>Exercises</h3>

<ul>
<li><p>Implement your own version of <code>compose</code> using <code>Reduce</code> and <code>%.%</code>. For bonus points, do it without calling <code>function</code>.</p></li>
<li><p>Extend <code>and()</code> and <code>or()</code> to deal with any number of input functions. Can you do it with <code>Reduce()</code>? Can you keep them lazy (so e.g. for <code>and()</code> the function returns as soon as it sees the first <code>FALSE</code>)?</p></li>
<li><p>Implement the <code>xor()</code> binary operator. Implement it using the existing <code>xor()</code> function. Implement it as a combination of <code>and()</code> and <code>or()</code>. What are the advantages and disadvantages of each approach? Also think about what you&#39;ll call the resulting function, and how you might need to change the names of <code>and()</code>, <code>not()</code> and <code>or()</code> in order to keep them consistent.</p></li>
<li><p>Above, we implemented boolean algebra for functions that return a logical function. Implement elementary algebra (<code>plus()</code>, <code>minus()</code>, <code>multiply()</code>, <code>divide()</code>, <code>exponentiate()</code>, <code>log()</code>) for functions that return numeric vectors. </p></li>
</ul>

<h2>The common pattern and a subtle bug</h2>

<p>Most function operators we&#39;ve seen follow a similar pattern:</p>

<div class="chunk" id="unnamed-chunk-373"><div class="rcode"><div class="source"><pre class="knitr r">funop <- function(f, otherargs) {
  function(...) {
    # maybe do something
    res <- f(...)
    # maybe do something else
    res
  }
}
</pre></div>

<p></div></div></p>

<p>There&#39;s a subtle problem with this implementation. It does not work well with <code>lapply()</code> because <code>f</code> is lazily evaluated.  This means that if you give <code>lapply()</code> a list of functions and a FO to apply it to each of them, it will look like it repeatedly applied the FO to the last function:</p>

<div class="chunk" id="unnamed-chunk-374"><div class="rcode"><div class="source"><pre class="knitr r">wrap <- function(f) {
  function(...) f(...)
}
fs <- list(sum = sum, mean = mean, min = min)
gs <- lapply(fs, wrap)
gs$sum(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">environment(gs$sum)$f
</pre></div>

<div class="output"><pre class="knitr r">## function (..., na.rm = FALSE)  .Primitive("min")
</pre></div>

<p></div></div></p>

<p>Another problem is that as designed, we have to pass in a funtion object, not the name of a function, which is often convenient. We can solve both problems by using <code>match.fun()</code>: it forces evaluation of <code>f</code>, and will find the function object if given its name:</p>

<div class="chunk" id="unnamed-chunk-375"><div class="rcode"><div class="source"><pre class="knitr r">wrap2 <- function(f) {
  f <- match.fun(f)
  function(...) f(...)
}
fs <- c(sum = "sum", mean = "mean", min = "min")
hs <- lapply(fs, wrap2)
hs$sum(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 55
</pre></div>

<div class="source"><pre class="knitr r">environment(hs$sum)$f
</pre></div>

<div class="output"><pre class="knitr r">## function (..., na.rm = FALSE)  .Primitive("sum")
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li>Why does the following code (from <a href="http://stackoverflow.com/questions/8440675">stackoverflow</a>) not do what you expect?</li>
</ul>

<div class="chunk" id="unnamed-chunk-376"><div class="rcode"><div class="source"><pre class="knitr r">a <- list(0, 1)
b <- list(0, 1)

# return a linear function with slope a and intercept b.
f <- function(a, b) function(x) a * x + b

# create a list of functions with different parameters.
fs <- Map(f, a, b)

fs[[1]](3)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<p></div></div></p>

<pre><code>How can you modify `f` so that it works correctly?
</code></pre>

<h1>Metaprogramming</h1>

<p>&#39;&#39;Flexibility in syntax, if it does not lead to ambiguity, would seem a reasonable thing to ask of an interactive programming language.&#39;&#39; --- Kent Pitman, <a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a></p>

<p>R has powerful tools for computing not only on values, but also on the actions that lead to those values. These tools are powerful and magical, and one of the most surprising features if you&#39;re coming from another programming language.  Take the following simple snippet of code that draws a sine curve:</p>

<div class="chunk" id="plot-labels"><div class="rcode"><div class="source"><pre class="knitr r">x <- seq(0, 2 * pi, length = 100)
sinx <- sin(x)
plot(x, sinx, type = "l")
</pre></div>

<div class="rimage default"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAACSVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADVTbiYAAAAw3RSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFxgaGxwdHiAhIiUmJygpKissLTAxMzQ2OTo8QEFCQ0RFRkdIS0xOT1BRUlNUVVZXWFpbXV9hYmNmaGlqa21ub3Byc3R2d3h5fH1/gIGEhYaHiIqMjo+QkZOUlZaXmJmanp+goaOlpqeqrK6vsLG2t7i5uru8vb6/wMHDxMXGyMnKy8zNztDR0tPU1dbX2Nnb3N7f4OHi4+Xm5+jp6uvt7u/w8fP09ff4+fr7/P8aBvgUAAAACXBIWXMAAAsSAAALEgHS3X78AAAKBUlEQVR4nO3dj3fVdR3H8c/ddsdwGbbuBM1tRVsyTVuUWGRlAlFZBoWZhN6KYYo1884oKCxSs3UHpCVOy2VGm3dsuLRAodru9y/r7m78+myze/28L/vM1/Nxjtx73vO89zk++d773Tww5wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALDstWxCxL5QX6vwW39/F+I1el3Nwm+r1WYYeJTwmggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiwsNvmCxseH76WJc/J3zUwsO//NHPJd9q+uIxf074qIWHn3CNSZNzJ/054aNmcMXfeFuyo3ELV/zyYvAe/3rh1qHi87zHLy/c1YsivCir8N3J+ae3D5W99mubzaiJ2l3xjxys1WYYILyo8PCZXKE4PdrX4s8JH7Xw8PnejnRje3bAnxM+auHhJ1PlhxF/TviohYcfLF3x6bZs3p8TPmoG7/H9Y8ViIZfx54SPGnf1oggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiCC+K8KIIL4rwoggvivCiwsOvWWRO+KiFh0/2vXfBOeGjZhD+8y9srltgTvioGYR3rfte+sbqeXPCR80ivHNdPzn1ij8nfNRswjvX+HF/TviohYe/d5E54aPG1/GirMJ3J+effnagbPy3NptRE1zxoggvKjx8JlcoTo/2tfhzwkctPHy+tyPd2J4d8OeEj1p4+MlU+WHEnxM+auHhB0tXfLotm/fnhI+awXt8/1ixWMhl/Dnho8ZdvSjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLIrwowosivCjCiyK8KMKLCg/fduCGm4annlnrzwkftfDwL97dfHz7ii89588JHzWTHyP+nxWlB39O+KiFhz/46If37lhx51F/TviohYdv3nN8KvnH/tX+nPBR465eVIXh1838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" title="plot of chunk plot-labels" alt="plot of chunk plot-labels" class="plot" /></div>

<p></div></div></p>

<p>Look at the labels on the axes! How did R know that the variable on the x axis was called <code>x</code> and the variable on the y axis was called <code>sinx</code>? In most programming languages, you can only access values of the arguments provided to functions, but in R you can also access the expression used to computing them. Combined with R&#39;s lazy evaluation mechanism this gives function authors considerable power to both access the underlying expression and do special things with it.</p>

<p>Techniques based on these tools are generally called &quot;computing on the language&quot;, and in R provide a set of tools with power equivalent to functional and object oriented programming.  This chapter will introduce you to the basic ideas of special evaluation, show you how they are used in base R, and how you can use them to create your own functions that save typing for interactive analysis. These tools are very useful for developing convenient user-facing functions because they can dramatically reduce the amount of typing required to specify an action.  </p>

<p>Computing on the language is an extremely powerful tool, but it can also create code that is hard for others to understand and is substantially harder to program with. Before you use it, make sure that you have exhausted all other possibilities. You&#39;ll also learn about the downsides: because these tools work with expressions rather than values this increases ambiguity in the function call, and makes the function difficult to call from another function.</p>

<p>The following chapters [[expressions]] and [[special-environments]], expand on these ideas, discussing the underlying data structures and how you can understand and manipulate them to create new tools.</p>

<p>In this chapter you&#39;ll learn:</p>

<ul>
<li><p>how many functions such as <code>plot()</code> and <code>data.frame()</code> capture the names of the variable supplied to them, and the downsides of this technique.</p></li>
<li><p>Manipulate a data frame by referring to the variables:  <code>subset()</code>, <code>transform()</code>, <code>plyr::mutate()</code>, <code>plyr::arrange()</code>, <code>plyr::summarise()</code>, <code>with()</code></p></li>
<li><p>Work around non-standard evaluation with (like lattice functions) <code>substitute</code>.</p></li>
<li><p>Capture an expression for later evaluation: ggplot2 and plyr</p></li>
<li><p>Use formulas to describe computations: <code>lm()</code> and the lattice package</p></li>
</ul>

<h2>Capturing expressions</h2>

<p>The tool that makes non-standard evaluation possible in R is <code>substitute()</code>. It looks at a function argument, and instead of seeing the value, it looks to see how the value was computed:</p>

<div class="chunk" id="unnamed-chunk-377"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) {
  substitute(x)
}
f(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## 1:10
</pre></div>

<div class="source"><pre class="knitr r">f(x)
</pre></div>

<div class="output"><pre class="knitr r">## x
</pre></div>

<div class="source"><pre class="knitr r">f(x + y ^ 2 / z + exp(a * sin(b)))
</pre></div>

<div class="output"><pre class="knitr r">## x + y^2/z + exp(a * sin(b))
</pre></div>

<p></div></div></p>

<p>We won&#39;t worry yet about exactly what sort of object <code>substitute()</code> returns (that&#39;s the topic of the [[Expressions]] chapter), but we&#39;ll call it an expression.  (Note that it&#39;s not the same thing as returned by the <code>expression()</code> function: we&#39;ll call that an expression <em>object</em>.)</p>

<p><code>substitute()</code> works because function arguments in R are only evaluated when they are needed, not automatically when the function is called. This means that function arguments are not just a simple value, but instead store both the expression to compute the value and the environment in which to compute it. Together these two things are called a <strong>promise</strong>. Most of the time in R, you don&#39;t need to know anything about promises because the first time you access a promise it is seamlessly evaluated, returning its value.</p>

<p>We need one more function if we want to understand how <code>plot()</code> and <code>data.frame()</code> work: <code>deparse()</code>. This function takes an expression and converts it to a character vector.</p>

<div class="chunk" id="unnamed-chunk-378"><div class="rcode"><div class="source"><pre class="knitr r">g <- function(x) deparse(substitute(x))
g(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "1:10"
</pre></div>

<div class="source"><pre class="knitr r">g(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<div class="source"><pre class="knitr r">g(x + y ^ 2 / z + exp(a * sin(b)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x + y^2/z + exp(a * sin(b))"
</pre></div>

<p></div></div></p>

<p>There&#39;s one important caveat with <code>deparse()</code>: it can return a multiple strings if the input is long:</p>

<div class="chunk" id="unnamed-chunk-379"><div class="rcode"><div class="source"><pre class="knitr r">g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z)
</pre></div>

<p></div></div></p>

<p>If you need a single string, you can work around this by using the <code>width.cutoff</code> argument (which has a maximum value of 500), or by joining the lines back together again with <code>paste()</code>.</p>

<p>You might wonder why we couldn&#39;t use our original <code>f()</code> to compute <code>g()</code>.  Let&#39;s try it:</p>

<div class="chunk" id="unnamed-chunk-380"><div class="rcode"><div class="source"><pre class="knitr r">g <- function(x) deparse(f(x))
g(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<div class="source"><pre class="knitr r">g(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<div class="source"><pre class="knitr r">g(x + y ^ 2 / z + exp(a * sin(b)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<p></div></div></p>

<p>This is one of the downsides of functions that use <code>substitute()</code>: because they use the expression, not the value, of an argument, it becomes harder to call them from other functions.  We&#39;ll talk more about this problem and some remedies later on.</p>

<p>There are a lots of function in base R that use these ideas. Some use them to avoid quotes:</p>

<div class="chunk" id="unnamed-chunk-381"><div class="rcode"><div class="source"><pre class="knitr r">library(ggplot2) 
library("ggplot2")
</pre></div>

<p></div></div></p>

<p>Others use them to provide default labels. For example, <code>plot.default()</code> has code that basically does (the real code is more complicated because of the way base plotting methods work, but it&#39;s effectively the same):</p>

<div class="chunk" id="unnamed-chunk-382"><div class="rcode"><div class="source"><pre class="knitr r">plot.default <- function(x, y = NULL, xlabel = NULL, ylabel = NULL, ...) {
    ...
    xlab <- if (is.null(xlabel) && !missing(x)) deparse(substitute(x))
    ylab <- if (is.null(xlabel) && !missing(y)) deparse(substitute(y))
    ...
}
</pre></div>

<p></div></div></p>

<p>If a label is not set and the variable is present, then the expression used to generate the value of <code>x</code> is used as a default value for the label on the x axis.</p>

<p><code>data.frame()</code> does a similar thing.  It automatically labels variables with the expression used to compute them:</p>

<div class="chunk" id="unnamed-chunk-383"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1:4
y <- letters[1:4]
names(data.frame(x, y))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x" "y"
</pre></div>

<p></div></div></p>

<p>This wouldn&#39;t be possible in most programming langauges because functions usually only see values (e.g. <code>1:4</code> and <code>c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</code>), not the expressions that created them (<code>x</code> and <code>y</code>).</p>

<h2>Non-standard evaluation in subset</h2>

<p>Just printing out the expression used to generate an argument value is useful, but we can do even more with the unevaluated function.  For example, take <code>subset()</code>. It&#39;s a useful interactive shortcut for subsetting data frames: instead of repeating the data frame you&#39;re working with again and again, you can save some typing:</p>

<div class="chunk" id="unnamed-chunk-384"><div class="rcode"><div class="source"><pre class="knitr r">subset(mtcars, cyl == 4)
# equivalent to:
# mtcars[mtcars$cyl == 4, ]

subset(mtcars, vs == am)
# equivalent to:
# mtcars[mtcars$vs == mtcars$am, ]
</pre></div>

<p></div></div></p>

<p>Subset is special because <code>vs == am</code> or <code>cyl == 4</code> aren&#39;t evaluated in the global environment: instead they&#39;re evaluated in the data frame. In other words, <code>subset()</code> implements different [[scoping|Scoping]] rules so instead of looking for those variables in the current environment, <code>subset()</code> looks in the specified data frame. This is called <strong>non-standard evaluation</strong>: you are deliberately breaking R&#39;s usual rules in order to do something special.</p>

<p>How does <code>subset()</code> work?  We&#39;ve already seen how to capture the expression that represents an argument, rather than its value, so we just need to figure out how to evaluate that expression in the right context: i.e. <code>cyl</code> should be interpreted as <code>mtcars$cyl</code>. To do this we need <code>eval()</code>, which takes an expression and evaluates it in the specified environment.</p>

<p>But before we can do that, we need to learn one more useful function: <code>quote()</code>. It&#39;s similar to <code>substitute()</code> but it always gives you back exactly the expression you entered. This makes it useful for interactive experimentation.</p>

<div class="chunk" id="unnamed-chunk-385"><div class="rcode"><div class="source"><pre class="knitr r">quote(1:10)
</pre></div>

<div class="output"><pre class="knitr r">## 1:10
</pre></div>

<div class="source"><pre class="knitr r">quote(x)
</pre></div>

<div class="output"><pre class="knitr r">## x
</pre></div>

<div class="source"><pre class="knitr r">quote(x + y ^ 2 / z + exp(a * sin(b)))
</pre></div>

<div class="output"><pre class="knitr r">## x + y^2/z + exp(a * sin(b))
</pre></div>

<p></div></div></p>

<p>Now let&#39;s experiment with <code>eval()</code>.  If you only provide one argument, it evaluates the expression in the current environment.  This makes <code>eval(quote(x))</code> exactly equivalent to typing <code>x</code>, regardless of what <code>x</code> is: </p>

<div class="chunk" id="unnamed-chunk-386"><div class="rcode"><div class="source"><pre class="knitr r">eval(quote(x <- 1))
eval(quote(x))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.1653
</pre></div>

<div class="source"><pre class="knitr r">
eval(quote(cyl))
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'cyl' not found
</pre></div>

<p></div></div></p>

<p>Note that <code>quote()</code> and <code>eval()</code> are basically opposites. In the example below, each <code>eval()</code> peels off one layer of quoting.</p>

<div class="chunk" id="unnamed-chunk-387"><div class="rcode"><div class="source"><pre class="knitr r">quote(2 + 2)
</pre></div>

<div class="output"><pre class="knitr r">## 2 + 2
</pre></div>

<div class="source"><pre class="knitr r">eval(quote(2 + 2))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<div class="source"><pre class="knitr r">
quote(quote(2 + 2))
</pre></div>

<div class="output"><pre class="knitr r">## quote(2 + 2)
</pre></div>

<div class="source"><pre class="knitr r">eval(quote(quote(2 + 2)))
</pre></div>

<div class="output"><pre class="knitr r">## 2 + 2
</pre></div>

<div class="source"><pre class="knitr r">eval(eval(quote(quote(2 + 2))))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<p></div></div></p>

<p>What will this code return?</p>

<div class="chunk" id="unnamed-chunk-388"><div class="rcode"><div class="source"><pre class="knitr r">eval(quote(eval(quote(eval(quote(2 + 2))))))
</pre></div>

<p></div></div></p>

<p>The second argument to <code>eval()</code> controls which environment the code is evaluated in:</p>

<div class="chunk" id="unnamed-chunk-389"><div class="rcode"><div class="source"><pre class="knitr r">x <- 10
eval(quote(x))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.1953
</pre></div>

<div class="source"><pre class="knitr r">
e <- new.env()
e$x <- 20
eval(quote(x), e)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 20
</pre></div>

<p></div></div></p>

<p>Instead of an environment, the second argument can also be a list or a data frame.  This works because an environment is basically a set of mappings between names and values, in the same way as a list or data frame.</p>

<div class="chunk" id="unnamed-chunk-390"><div class="rcode"><div class="source"><pre class="knitr r">eval(quote(x), list(x = 30))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 30
</pre></div>

<div class="source"><pre class="knitr r">eval(quote(x), data.frame(x = 40))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 40
</pre></div>

<p></div></div></p>

<p>This is basically what we want for <code>subset()</code>:</p>

<div class="chunk" id="unnamed-chunk-391"><div class="rcode"><div class="source"><pre class="knitr r">eval(quote(cyl == 4), mtcars)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
</pre></div>

<div class="source"><pre class="knitr r">eval(quote(vs == am), mtcars)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
## [24] NA NA NA NA NA NA NA NA NA
</pre></div>

<p></div></div></p>

<p>We can combine <code>eval()</code> and <code>substitute()</code> together to write <code>subset()</code>: we can capture the call representing the condition, evaluate it in the context of the data frame, and then use the result for subsetting:</p>

<div class="chunk" id="unnamed-chunk-392"><div class="rcode"><div class="source"><pre class="knitr r">subset2 <- function(x, condition) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, x)
  x[r, ]
}
subset2(mtcars, cyl == 6)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<p></div></div></p>

<p>When you first start using <code>eval()</code> it&#39;s easy to make mistakes.  Here&#39;s a common one: forgetting to quote the input:</p>

<div class="chunk" id="unnamed-chunk-393"><div class="rcode"><div class="source"><pre class="knitr r">eval(cyl, mtcars)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'cyl' not found
</pre></div>

<div class="source"><pre class="knitr r"># Carefully look at the difference to this error
eval(quote(cyl), mtcars)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 0.9697 0.9697 0.6465 0.9697 1.2929 0.9697 1.2929 0.6465 0.6465 0.9697
## [11] 0.9697 1.2929 1.2929 1.2929 1.2929 1.2929 1.2929 0.6465 0.6465 0.6465
## [21] 0.6465 1.2929 1.2929 1.2929 1.2929 0.6465 0.6465 0.6465 1.2929 0.9697
## [31] 1.2929 0.6465
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>The real subset function (<code>subset.data.frame()</code>) does two other things to the result. What are they?</p></li>
<li><p>The other component of the real subset function is variable selection. It allows you to work with variable names like they are positions, so you can do things like <code>subset(mtcars, , -cyl)</code> to drop the cylinder variable, or <code>subset(mtcars, , disp:drat)</code> to select all the variables between <code>disp</code> and <code>drat</code>.   How does select work? I&#39;ve made it easier to understand by extracting it out into its own function:</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-394"><div class="rcode"><div class="source"><pre class="knitr r">select <- function(df, vars) {
  vars <- substitute(vars)
  var_pos <- setNames(as.list(seq_along(df)), names(df))
  pos <- eval(vars, var_pos)
  df[, pos, drop = FALSE]
}
select(mtcars, -cyl)
</pre></div>

<div class="output"><pre class="knitr r">##                        mpg     disp     hp   drat     wt   qsec    vs   am
## Mazda RX4           1.0453 0.011364 0.7499 1.0844 0.8144 0.9222 0.000 <NA>
## Mazda RX4 Wag       1.0453 0.011364 0.7499 1.0844 0.8936 0.9536 0.000 <NA>
## Datsun 710          1.1349 0.007671 0.6340 1.0705 0.7211 1.0427 2.286 <NA>
## Hornet 4 Drive      1.0652 0.018325 0.7499 0.8564 0.9993 1.0892 2.286 <NA>
## Hornet Sportabout   0.9308 0.025569 1.1930 0.8758 1.0692 0.9536 0.000 <NA>
## Valiant             0.9009 0.015981 0.7158 0.7674 1.0755 1.1329 2.286 <NA>
## Duster 360          0.7118 0.025569 1.6702 0.8925 1.1096 0.8875 0.000 <NA>
## Merc 240D           1.2145 0.010419 0.4227 1.0260 0.9915 1.1205 2.286 <NA>
## Merc 230            1.1349 0.010000 0.6476 1.0899 0.9791 1.2830 2.286 <NA>
## Merc 280            0.9557 0.011904 0.8385 1.0899 1.0692 1.0253 2.286 <NA>
## Merc 280C           0.8860 0.011904 0.8385 1.0899 1.0692 1.0589 2.286 <NA>
## Merc 450SE          0.8163 0.019589 1.2271 0.8536 1.2651 0.9749 0.000 <NA>
## Merc 450SL          0.8611 0.019589 1.2271 0.8536 1.1594 0.9861 0.000 <NA>
## Merc 450SLC         0.7566 0.019589 1.2271 0.8536 1.1749 1.0085 0.000 <NA>
## Cadillac Fleetwood  0.5177 0.033524 1.3975 0.8147 1.6318 1.0074 0.000 <NA>
## Lincoln Continental 0.5177 0.032672 1.4657 0.8341 1.6859 0.9984 0.000 <NA>
## Chrysler Imperial   0.7317 0.031251 1.5680 0.8981 1.6614 0.9760 0.000 <NA>
## Fiat 128            1.6127 0.005590 0.4499 1.1344 0.6838 1.0908 2.286 <NA>
## Honda Civic         1.5131 0.005377 0.3545 1.3708 0.5020 1.0376 2.286 <NA>
## Toyota Corolla      1.6874 0.005050 0.4431 1.1733 0.5704 1.1149 2.286 <NA>
## Toyota Corona       1.0702 0.008530 0.6613 1.0288 0.7662 1.1211 2.286 <NA>
## Dodge Challenger    0.7715 0.022586 1.0226 0.7674 1.0941 0.9452 0.000 <NA>
## AMC Javelin         0.7566 0.021592 1.0226 0.8758 1.0677 0.9693 0.000 <NA>
## Camaro Z28          0.6620 0.024859 1.6702 1.0371 1.1936 0.8634 0.000 <NA>
## Pontiac Firebird    0.9557 0.028410 1.1930 0.8564 1.1951 0.9552 0.000 <NA>
## Fiat X1-9           1.3588 0.005611 0.4499 1.1344 0.6014 1.0589 2.286 <NA>
## Porsche 914-2       1.2941 0.008544 0.6204 1.2317 0.6652 0.9356 0.000 <NA>
## Lotus Europa        1.5131 0.006755 0.7703 1.0482 0.4703 0.9468 2.286 <NA>
## Ford Pantera L      0.7864 0.024930 1.7997 1.1733 0.9853 0.8124 0.000 <NA>
## Ferrari Dino        0.9806 0.010299 1.1930 1.0065 0.8610 0.8684 0.000 <NA>
## Maserati Bora       0.7466 0.021379 2.2838 0.9843 1.1096 0.8180 0.000 <NA>
## Volvo 142E          1.0652 0.008594 0.7431 1.1428 0.8641 1.0421 2.286 <NA>
##                       gear   carb
## Mazda RX4           1.0847 1.4222
## Mazda RX4 Wag       1.0847 1.4222
## Datsun 710          1.0847 0.3556
## Hornet 4 Drive      0.8136 0.3556
## Hornet Sportabout   0.8136 0.7111
## Valiant             0.8136 0.3556
## Duster 360          0.8136 1.4222
## Merc 240D           1.0847 0.7111
## Merc 230            1.0847 0.7111
## Merc 280            1.0847 1.4222
## Merc 280C           1.0847 1.4222
## Merc 450SE          0.8136 1.0667
## Merc 450SL          0.8136 1.0667
## Merc 450SLC         0.8136 1.0667
## Cadillac Fleetwood  0.8136 1.4222
## Lincoln Continental 0.8136 1.4222
## Chrysler Imperial   0.8136 1.4222
## Fiat 128            1.0847 0.3556
## Honda Civic         1.0847 0.7111
## Toyota Corolla      1.0847 0.3556
## Toyota Corona       0.8136 0.3556
## Dodge Challenger    0.8136 0.7111
## AMC Javelin         0.8136 0.7111
## Camaro Z28          0.8136 1.4222
## Pontiac Firebird    0.8136 0.7111
## Fiat X1-9           1.0847 0.3556
## Porsche 914-2       1.3559 0.7111
## Lotus Europa        1.3559 0.7111
## Ford Pantera L      1.3559 1.4222
## Ferrari Dino        1.3559 2.1333
## Maserati Bora       1.3559 2.8444
## Volvo 142E          1.0847 0.7111
</pre></div>

<p></div></div></p>

<ul>
<li>What does <code>evalq()</code> do? Use it to reduce the amount of typing for the examples above that use both <code>eval()</code> and <code>quote()</code></li>
</ul>

<h2>Scoping issues</h2>

<p>While it certainly looks like our <code>subset2()</code> function works, whenever we&#39;re working with expressions instead of values, we need to test a little more carefully. For example, you might expect that the following uses of <code>subset2()</code> should all return the same value because each variable refers to the same value:</p>

<div class="chunk" id="unnamed-chunk-395"><div class="rcode"><div class="source"><pre class="knitr r">y <- 4
x <- 4
condition <- 4
condition_call <- 4

subset2(mtcars, cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<div class="source"><pre class="knitr r">subset2(mtcars, cyl == y)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<div class="source"><pre class="knitr r">subset2(mtcars, cyl == x)
</pre></div>

<div class="output"><pre class="knitr r">##       mpg cyl disp hp drat wt qsec vs   am gear carb
## NA     NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.1   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.2   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.3   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.4   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.5   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.6   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.7   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.8   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.9   NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.10  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.11  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.12  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.13  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.14  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.15  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.16  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.17  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.18  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.19  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.20  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.21  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.22  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.23  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.24  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.25  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.26  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.27  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.28  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.29  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.30  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.31  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.32  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.33  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.34  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.35  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.36  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.37  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.38  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.39  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.40  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.41  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.42  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.43  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.44  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.45  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.46  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.47  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.48  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.49  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.50  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.51  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.52  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.53  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.54  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.55  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.56  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.57  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.58  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.59  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.60  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.61  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.62  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
## NA.63  NA  NA   NA NA   NA NA   NA NA <NA>   NA   NA
</pre></div>

<div class="source"><pre class="knitr r">subset2(mtcars, cyl == condition)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'cyl' not found
</pre></div>

<div class="source"><pre class="knitr r">subset2(mtcars, cyl == condition_call)
</pre></div>

<div class="warning"><pre class="knitr r">## Warning: longer object length is not a multiple of shorter object length
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<p></div></div></p>

<p>What&#39;s going wrong? You can get a hint from the variable names I&#39;ve chosen: they are all variables defined inside <code>subset2()</code>. It seems like if <code>eval()</code> can&#39;t find the variable instead of the data frame (it&#39;s second argument), it&#39;s looking in the function environment.  That&#39;s obviously not what we want, so we need some way to tell <code>eval()</code> to look somewhere else if it can&#39;t find the variables in the data frame.</p>

<p>The key is the third argument: <code>enclos</code>. This allows us to specify the parent (or enclosing) environment for objects that don&#39;t have one like lists and data frames (<code>enclos</code> is ignored if we pass in a real environment). The <code>enclos</code>ing environment is where any objects that aren&#39;t found in the data frame will be looked for. By default it uses the environment of the current function, which is not what we want.</p>

<p>We want to look for <code>x</code> in the environment in which <code>subset</code> was called. In R terminology this is called the <strong>parent frame</strong> and is accessed with <code>parent.frame()</code>. This is an example of <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29#Dynamic_scoping">dynamic scope</a>. With this modification our function works:</p>

<div class="chunk" id="unnamed-chunk-396"><div class="rcode"><div class="source"><pre class="knitr r">subset2 <- function(x, condition) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, x, parent.frame())
  x[r, ]
}

x <- 4
subset2(mtcars, cyl == x)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<p></div></div></p>

<p>Using <code>enclos</code> is just a short cut for converting a list or data frame to an environment with the desired parent yourself. We can use the <code>list2env()</code> to turn a list into an environment and explicitly set the parent ourselves:</p>

<div class="chunk" id="unnamed-chunk-397"><div class="rcode"><div class="source"><pre class="knitr r">subset2 <- function(x, condition) {
  condition_call <- substitute(condition)
  env <- list2env(x, parent = parent.frame())
  r <- eval(condition_call, env)
  x[r, ]
}

x <- 4
subset2(mtcars, cyl == x)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<p></div></div></p>

<p>When evaluating code in a non-standard way, it&#39;s also a good idea to test your code works when run outside of the global environment:</p>

<div class="chunk" id="unnamed-chunk-398"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() {
  x <- 6
  subset(mtcars, cyl == x)
}
f()
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<p></div></div></p>

<p>And indeed it now works.</p>

<h3>Exercises</h3>

<ul>
<li><p><code>plyr::arrange()</code> works similarly to <code>subset()</code>, but instead of selecting rows, it reorders them. How does it work?  What does <code>substitute(order(...))</code> do?</p></li>
<li><p>What does <code>transform()</code> do? (Hint: read the documentation). How does it work? (Hint: read the source code for <code>transform.data.frame</code>) What does <code>substitute(list(...))</code> do? (Hint: create a function that does only that and experiment with it).</p></li>
<li><p><code>plyr::mutate()</code> is similar to <code>transform()</code> but it applies the transformations sequentially so that transformation can refer to columns that were just created:</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-399"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1:5)
transform(df, x2 = x * x, x3 = x2 * x)
plyr::mutate(df, x2 = x * x, x3 = x2 * x)
</pre></div>

<p></div></div></p>

<p>How does mutate work? What&#39;s the key difference between mutate and transform?</p>

<ul>
<li><p>What does <code>with()</code> do? How does it work? (Read the source code for <code>with.default()</code>)</p></li>
<li><p>What does <code>within()</code> do? How does it work? (Read the source code for <code>within.data.frame()</code>). What makes the code so much more complicated than <code>with()</code>?</p></li>
</ul>

<h2>Calling from another function</h2>

<p>Typically, computing on the language is most useful for functions called directly by the user, not by other functions. While <code>subset</code> saves typing, it has one big disadvantage: it&#39;s now difficult to use non-interactively, e.g. from another function. For example, you might try using <code>subset()</code> from within a function that is given the name of a variable and it&#39;s desired value:</p>

<div class="chunk" id="unnamed-chunk-400"><div class="rcode"><div class="source"><pre class="knitr r">colname <- "cyl"
val <- 6

subset(mtcars, colname == val)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
## <0 rows> (or 0-length row.names)
</pre></div>

<div class="source"><pre class="knitr r"># Zero rows because "cyl" != 6
</pre></div>

<p></div></div></p>

<p>Or imagine we want to create a function that randomly reorders a subset of the data. A nice way to write that function would be to write a function for random reordering and a function for subsetting (that we already have!) and combine the two together. Let&#39;s try that:</p>

<div class="chunk" id="unnamed-chunk-401"><div class="rcode"><div class="source"><pre class="knitr r">scramble <- function(x) x[sample(nrow(x)), ]

subscramble <- function(x, condition) {
  scramble(subset(x, condition))
}
</pre></div>

<p></div></div></p>

<p>But when we run that we get:</p>

<div class="chunk" id="unnamed-chunk-402"><div class="rcode"><div class="source"><pre class="knitr r">subscramble(mtcars, cyl == 4)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'cyl' not found
</pre></div>

<div class="source"><pre class="knitr r"># Error in eval(expr, envir, enclos) : object 'cyl' not found
traceback()
</pre></div>

<div class="output"><pre class="knitr r">## No traceback available
</pre></div>

<div class="source"><pre class="knitr r"># 5: eval(expr, envir, enclos)
# 4: eval(condition_call, x)
# 3: subset(x, condition)
# 2: scramble(subset(x, condition))
# 1: subscramble(mtcars, cyl == 4)
</pre></div>

<p></div></div></p>

<p>What&#39;s gone wrong? To figure it out, lets <code>debug()</code> subset and work through the code line-by-line:</p>

<div class="chunk" id="unnamed-chunk-403"><div class="rcode"><div class="source"><pre class="knitr r">> debugonce(subset)
> subscramble(mtcars, cyl == 4)
debugging in: subset(x, condition)
debug: {
    condition_call <- substitute(condition)
    r <- eval(condition_call, x)
    x[r, ]
}
Browse[2]> n
debug: condition_call <- substitute(condition)
Browse[2]> n
debug: r <- eval(condition_call, x)
Browse[2]> condition_call
condition
Browse[2]> eval(condition_call, x)
Error in eval(expr, envir, enclos) : object 'cyl' not found
Browse[2]> condition
Error: object 'cyl' not found
In addition: Warning messages:
1: restarting interrupted promise evaluation 
2: restarting interrupted promise evaluation
</pre></div>

<p></div></div></p>

<p>Can you see what the problem is? <code>condition_call</code> contains the expression <code>condition</code> so when we try to evaluate that it evaluates <code>condition</code> which has the value <code>cyl == 4</code>. This can&#39;t be computed in the parent environment because it doesn&#39;t contain an object called <code>cyl</code>. If <code>cyl</code> is set in the global environment, far more confusing things can happen:</p>

<div class="chunk" id="unnamed-chunk-404"><div class="rcode"><div class="source"><pre class="knitr r">cyl <- 4
subscramble(mtcars, cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">##                        mpg    cyl     disp     hp   drat     wt   qsec
## Ferrari Dino        0.9806 0.9697 0.010299 1.1930 1.0065 0.8610 0.8684
## Toyota Corona       1.0702 0.6465 0.008530 0.6613 1.0288 0.7662 1.1211
## AMC Javelin         0.7566 1.2929 0.021592 1.0226 0.8758 1.0677 0.9693
## Cadillac Fleetwood  0.5177 1.2929 0.033524 1.3975 0.8147 1.6318 1.0074
## Fiat 128            1.6127 0.6465 0.005590 0.4499 1.1344 0.6838 1.0908
## Camaro Z28          0.6620 1.2929 0.024859 1.6702 1.0371 1.1936 0.8634
## Ford Pantera L      0.7864 1.2929 0.024930 1.7997 1.1733 0.9853 0.8124
## Toyota Corolla      1.6874 0.6465 0.005050 0.4431 1.1733 0.5704 1.1149
## Volvo 142E          1.0652 0.6465 0.008594 0.7431 1.1428 0.8641 1.0421
## Chrysler Imperial   0.7317 1.2929 0.031251 1.5680 0.8981 1.6614 0.9760
## Lincoln Continental 0.5177 1.2929 0.032672 1.4657 0.8341 1.6859 0.9984
## Mazda RX4           1.0453 0.9697 0.011364 0.7499 1.0844 0.8144 0.9222
## Merc 280            0.9557 0.9697 0.011904 0.8385 1.0899 1.0692 1.0253
## Hornet Sportabout   0.9308 1.2929 0.025569 1.1930 0.8758 1.0692 0.9536
## Valiant             0.9009 0.9697 0.015981 0.7158 0.7674 1.0755 1.1329
## Merc 230            1.1349 0.6465 0.010000 0.6476 1.0899 0.9791 1.2830
## Porsche 914-2       1.2941 0.6465 0.008544 0.6204 1.2317 0.6652 0.9356
## Merc 240D           1.2145 0.6465 0.010419 0.4227 1.0260 0.9915 1.1205
## Merc 280C           0.8860 0.9697 0.011904 0.8385 1.0899 1.0692 1.0589
## Merc 450SL          0.8611 1.2929 0.019589 1.2271 0.8536 1.1594 0.9861
## Fiat X1-9           1.3588 0.6465 0.005611 0.4499 1.1344 0.6014 1.0589
## Pontiac Firebird    0.9557 1.2929 0.028410 1.1930 0.8564 1.1951 0.9552
## Lotus Europa        1.5131 0.6465 0.006755 0.7703 1.0482 0.4703 0.9468
## Merc 450SE          0.8163 1.2929 0.019589 1.2271 0.8536 1.2651 0.9749
## Datsun 710          1.1349 0.6465 0.007671 0.6340 1.0705 0.7211 1.0427
## Merc 450SLC         0.7566 1.2929 0.019589 1.2271 0.8536 1.1749 1.0085
## Duster 360          0.7118 1.2929 0.025569 1.6702 0.8925 1.1096 0.8875
## Hornet 4 Drive      1.0652 0.9697 0.018325 0.7499 0.8564 0.9993 1.0892
## Dodge Challenger    0.7715 1.2929 0.022586 1.0226 0.7674 1.0941 0.9452
## Mazda RX4 Wag       1.0453 0.9697 0.011364 0.7499 1.0844 0.8936 0.9536
## Maserati Bora       0.7466 1.2929 0.021379 2.2838 0.9843 1.1096 0.8180
## Honda Civic         1.5131 0.6465 0.005377 0.3545 1.3708 0.5020 1.0376
##                        vs   am   gear   carb
## Ferrari Dino        0.000 <NA> 1.3559 2.1333
## Toyota Corona       2.286 <NA> 0.8136 0.3556
## AMC Javelin         0.000 <NA> 0.8136 0.7111
## Cadillac Fleetwood  0.000 <NA> 0.8136 1.4222
## Fiat 128            2.286 <NA> 1.0847 0.3556
## Camaro Z28          0.000 <NA> 0.8136 1.4222
## Ford Pantera L      0.000 <NA> 1.3559 1.4222
## Toyota Corolla      2.286 <NA> 1.0847 0.3556
## Volvo 142E          2.286 <NA> 1.0847 0.7111
## Chrysler Imperial   0.000 <NA> 0.8136 1.4222
## Lincoln Continental 0.000 <NA> 0.8136 1.4222
## Mazda RX4           0.000 <NA> 1.0847 1.4222
## Merc 280            2.286 <NA> 1.0847 1.4222
## Hornet Sportabout   0.000 <NA> 0.8136 0.7111
## Valiant             2.286 <NA> 0.8136 0.3556
## Merc 230            2.286 <NA> 1.0847 0.7111
## Porsche 914-2       0.000 <NA> 1.3559 0.7111
## Merc 240D           2.286 <NA> 1.0847 0.7111
## Merc 280C           2.286 <NA> 1.0847 1.4222
## Merc 450SL          0.000 <NA> 0.8136 1.0667
## Fiat X1-9           2.286 <NA> 1.0847 0.3556
## Pontiac Firebird    0.000 <NA> 0.8136 0.7111
## Lotus Europa        2.286 <NA> 1.3559 0.7111
## Merc 450SE          0.000 <NA> 0.8136 1.0667
## Datsun 710          2.286 <NA> 1.0847 0.3556
## Merc 450SLC         0.000 <NA> 0.8136 1.0667
## Duster 360          0.000 <NA> 0.8136 1.4222
## Hornet 4 Drive      2.286 <NA> 0.8136 0.3556
## Dodge Challenger    0.000 <NA> 0.8136 0.7111
## Mazda RX4 Wag       0.000 <NA> 1.0847 1.4222
## Maserati Bora       0.000 <NA> 1.3559 2.8444
## Honda Civic         2.286 <NA> 1.0847 0.7111
</pre></div>

<div class="source"><pre class="knitr r">
cyl <- sample(10, 100, rep = T)
subscramble(mtcars, cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">##            mpg    cyl disp     hp drat     wt  qsec    vs   am  gear
## NA.3        NA     NA   NA     NA   NA     NA    NA    NA <NA>    NA
## NA.1        NA     NA   NA     NA   NA     NA    NA    NA <NA>    NA
## NA.2        NA     NA   NA     NA   NA     NA    NA    NA <NA>    NA
## Merc 230 1.135 0.6465 0.01 0.6476 1.09 0.9791 1.283 2.286 <NA> 1.085
## NA          NA     NA   NA     NA   NA     NA    NA    NA <NA>    NA
##            carb
## NA.3         NA
## NA.1         NA
## NA.2         NA
## Merc 230 0.7111
## NA           NA
</pre></div>

<p></div></div></p>

<p>This is an example of the general tension between functions that are designed for interactive use, and functions that are safe to program with. A function that uses <code>substitute()</code> might save typing, but it&#39;s difficult to call from another function. As a developer you should also provide an alternative version that works when passed a quoted expression. For example, we could rewrite:</p>

<div class="chunk" id="unnamed-chunk-405"><div class="rcode"><div class="source"><pre class="knitr r">subset2_q <- function(x, condition) {
  r <- eval(condition, x, parent.frame())
  x[r, ]
}

subset2 <- function(x, condition) {
  subset2_q(x, substitute(condition))
}

subscramble <- function(x, condition) {
  condition <- substitute(condition)
  scramble(subset2_q(x, condition))
}
</pre></div>

<p></div></div></p>

<p>I usually suffix these functions with <code>q</code> to indicate that they take a quoted call.  Most users won&#39;t need them so the name can be a little longer.</p>

<p>You might wonder why the function couldn&#39;t do this automatically:</p>

<div class="chunk" id="unnamed-chunk-406"><div class="rcode"><div class="source"><pre class="knitr r">subset <- function(x, condition) {
  if (!is.call(condition)) {
    condition <- substitute(condition)
  }
  r <- eval(condition, x)
  x[r, ]
}
subset(mtcars, quote(cyl == 4))
subset(mtcars, cyl == 4)
</pre></div>

<p></div></div></p>

<p>But hopefully a little thought, or maybe some experimentation, will show why this doesn&#39;t work.</p>

<h2>Substitute</h2>

<p>Following the examples above, whenever you write your own functions that use non-standard evaluation, you should always provide alternatives that others can use. But what happens if you want to call a function that uses non-standard evaluation and doesn&#39;t have form that takes expressions? For example, imagine you want to create a lattice graphic given the names of two variables:</p>

<div class="chunk" id="unnamed-chunk-407"><div class="rcode"><div class="source"><pre class="knitr r">library(lattice)
xyplot(mpg ~ displ, data = mtcars)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'displ' not found
</pre></div>

<div class="source"><pre class="knitr r">
x <- quote(mpg)
y <- quote(displ)
xyplot(x ~ y, data = mtcars)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object of type 'symbol' is not subsettable
</pre></div>

<p></div></div></p>

<p>Again, we can turn to substitute and use it for another purpose:  modifying expressions.  So far we&#39;ve just used <code>substitute()</code> to capture the unevaluated expression associated with arguments, but it can actually do much much more, and is a very useful for manipulating expressions in general.</p>

<p>Unfortunately <code>substitute()</code> has a &quot;feature&quot; that makes experimenting with it interactively a bit of a pain: it never does substitutions when run from the global environment, and just behaves like <code>quote()</code>:</p>

<div class="chunk" id="unnamed-chunk-408"><div class="rcode"><div class="source"><pre class="knitr r">a <- 1
b <- 2
substitute(a + b + x)
</pre></div>

<div class="output"><pre class="knitr r">## a + b + x
</pre></div>

<p></div></div></p>

<p>But if we run it inside a function, <code>substitute()</code> substitutes what it can and leaves everything else the same:</p>

<div class="chunk" id="unnamed-chunk-409"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() { 
  a <- 1
  b <- 2
  substitute(a + b + x)
}
f()
</pre></div>

<div class="output"><pre class="knitr r">## 1 + 2 + x
</pre></div>

<p></div></div></p>

<p>To make it easier to experiment with <code>substitute()</code>, <code>pryr</code> provides the <code>subs()</code> function.  It works exactly the same way as <code>substitute()</code> except it has a shorter name and if the second argument is the global environment it turns it into a list. Together, this makes it much easier to experiment with substitution:</p>

<div class="chunk" id="unnamed-chunk-410"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
subs(a + b + x)
</pre></div>

<div class="output"><pre class="knitr r">## 1 + 2 + function (value) 
## runif(1)
</pre></div>

<p></div></div></p>

<p>The second argument (to both <code>sub()</code> and <code>substitute()</code>) can override the use of the current environment, and provide an alternative list of name-value pairs to use. The following example uses that technique to show some variations on substituting a string, variable name or function call:</p>

<div class="chunk" id="unnamed-chunk-411"><div class="rcode"><div class="source"><pre class="knitr r">subs(a + b, list(a = "y"))
</pre></div>

<div class="output"><pre class="knitr r">## "y" + b
</pre></div>

<div class="source"><pre class="knitr r">subs(a + b, list(a = quote(y)))
</pre></div>

<div class="output"><pre class="knitr r">## y + b
</pre></div>

<div class="source"><pre class="knitr r">subs(a + b, list(a = quote(y())))
</pre></div>

<div class="output"><pre class="knitr r">## y() + b
</pre></div>

<p></div></div></p>

<p>Remember that every action in R is a function call, so we can also replace <code>+</code> with another function:</p>

<div class="chunk" id="unnamed-chunk-412"><div class="rcode"><div class="source"><pre class="knitr r">subs(a + b, list("+" = quote(f)))
</pre></div>

<div class="output"><pre class="knitr r">## f(a, b)
</pre></div>

<div class="source"><pre class="knitr r">subs(a + b, list("+" = quote(`*`)))
</pre></div>

<div class="output"><pre class="knitr r">## a * b
</pre></div>

<p></div></div></p>

<p>Note that it&#39;s quite possible to make nonsense commands with <code>substitute</code>:</p>

<div class="chunk" id="unnamed-chunk-413"><div class="rcode"><div class="source"><pre class="knitr r">subs(y <- y + 1, list(y = 1))
</pre></div>

<div class="output"><pre class="knitr r">## 1 <- 1 + 1
</pre></div>

<p></div></div></p>

<p>And you can use substitute to insert any arbitrary object into an expression. This is technically ok, but often results in surprisingly and undesirable behaviour.  In the example below, the expression we create doesn&#39;t print correctly, but it returns the correct result when we evaluate it:</p>

<div class="chunk" id="unnamed-chunk-414"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(x = 1)
(x <- subs(class(df)))
</pre></div>

<div class="output"><pre class="knitr r">## class(list(x = 1))
</pre></div>

<div class="source"><pre class="knitr r">eval(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.8897
</pre></div>

<p></div></div></p>

<p>Formally, substitution takes place by examining each name in the expression. If the name refers to:</p>

<ul>
<li><p>an ordinary variable, it&#39;s replaced by the value of the variable.</p></li>
<li><p>a promise, it&#39;s replaced by the expression associated with the promise. </p></li>
<li><p><code>...</code>, it&#39;s replaced by the contents of <code>...</code> (only if the substitution occurs in a function)</p></li>
</ul>

<p>Otherwise the name is left as is. </p>

<p>We can use this to create the right call to <code>xyplot</code>:</p>

<div class="chunk" id="unnamed-chunk-415"><div class="rcode"><div class="source"><pre class="knitr r">x <- quote(mpg)
y <- quote(displ)
subs(xyplot(x ~ y, data = mtcars))
</pre></div>

<div class="output"><pre class="knitr r">## xyplot(function (value) 
## runif(1) ~ displ, data = list(mpg = c(1.04526364909006, 1.04526364909006, 
## 1.13485767615492, 1.06517343288225, 0.930782392284959, 0.900917716596671, 
## 0.711774770570851, 1.21449681132369, 1.13485767615492, 0.955669622025198, 
## 0.885985378752528, 0.816301135479857, 0.861098149012288, 0.756571784103282, 
## 0.517654378596982, 0.517654378596982, 0.731684554363042, 1.61269248716752, 
## 1.51314356820656, 1.68735417638824, 1.0701508788303, 0.771504121947426, 
## 0.756571784103282, 0.662000311090372, 0.955669622025198, 1.35884274381708, 
## 1.29413594649246, 1.51314356820656, 0.78643645979157, 0.980556851765438, 
## 0.746616892207186, 1.06517343288225), cyl = c(0.96969696969697, 
## 0.96969696969697, 0.646464646464647, 0.96969696969697, 1.29292929292929, 
## 0.96969696969697, 1.29292929292929, 0.646464646464647, 0.646464646464647, 
## 0.96969696969697, 0.96969696969697, 1.29292929292929, 1.29292929292929, 
## 1.29292929292929, 1.29292929292929, 1.29292929292929, 1.29292929292929, 
## 0.646464646464647, 0.646464646464647, 0.646464646464647, 0.646464646464647, 
## 1.29292929292929, 1.29292929292929, 1.29292929292929, 1.29292929292929, 
## 0.646464646464647, 0.646464646464647, 0.646464646464647, 1.29292929292929, 
## 0.96969696969697, 1.29292929292929, 0.646464646464647), disp = c(0.0113640546653845, 
## 0.0113640546653845, 0.00767073689913451, 0.0183245381479324, 
## 0.025569122997115, 0.0159807018731969, 0.025569122997115, 0.0104194176213244, 
## 0.0100003681055383, 0.0119038472619902, 0.0119038472619902, 0.0195887892294565, 
## 0.0195887892294565, 0.0195887892294565, 0.0335239612628842, 0.0326716571629803, 
## 0.0312511503298073, 0.00558969438853598, 0.00537661836356002, 
## 0.00504990179193022, 0.00853014353320421, 0.0225860586474516, 
## 0.0215917038642305, 0.0248588695805285, 0.0284101366634611, 0.00561100199103358, 
## 0.00854434860153594, 0.00675450999173789, 0.0249298949221872, 
## 0.0102986745405047, 0.0213786278392545, 0.008594066340697), hp = c(0.749893481039625, 
## 0.749893481039625, 0.634000852151683, 0.749893481039625, 1.1930123561994, 
## 0.715807413719642, 1.67021729867916, 0.422667234767789, 0.647635279079676, 
## 0.838517256071581, 0.838517256071581, 1.22709842351939, 1.22709842351939, 
## 1.22709842351939, 1.3975287601193, 1.46570089475927, 1.56795909671922, 
## 0.449936088623775, 0.354495100127823, 0.443118875159778, 0.661269706007669, 
## 1.02258201959949, 1.02258201959949, 1.67021729867916, 1.1930123561994, 
## 0.449936088623775, 0.62036642522369, 0.770345121431615, 1.7997443544951, 
## 1.1930123561994, 2.28376651043886, 0.743076267575629), drat = c(1.08436875488748, 
## 1.08436875488748, 1.07046659136328, 0.856373273090625, 0.875836302024502, 
## 0.767399426535755, 0.892518898253541, 1.02597966808585, 1.08992962029716, 
## 1.08992962029716, 1.08992962029716, 0.853592840385785, 0.853592840385785, 
## 0.853592840385785, 0.814666782518029, 0.834129811451907, 0.89807976366322, 
## 1.13441654357459, 1.37075332348597, 1.17334260144235, 1.02876010079069, 
## 0.767399426535755, 0.875836302024502, 1.0371013989052, 0.856373273090625, 
## 1.13441654357459, 1.23173168824398, 1.04822312972456, 1.17334260144235, 
## 1.00651663915197, 0.98427317751325, 1.14275784168911), wt = c(0.814360090139094, 
## 0.893620327919807, 0.721112751573549, 0.999300644960758, 1.06923614888492, 
## 1.07545263812262, 1.10964332892999, 0.99153003341363, 0.979097054938224, 
## 1.06923614888492, 1.06923614888492, 1.26505555987256, 1.15937524283161, 
## 1.17491646592587, 1.63182842489704, 1.68591188126506, 1.66135674877613, 
## 0.683813816147331, 0.501981505944518, 0.570362887559251, 0.766182298546896, 
## 1.09410210583573, 1.06768202657549, 1.19356593363898, 1.1951200559484, 
## 0.601445333747766, 0.665164348434222, 0.470277410832232, 0.985313544175927, 
## 0.860983759421867, 1.10964332892999, 0.864092004040718), qsec = c(0.922193430912529, 
## 0.95356817704321, 1.0426500455214, 1.08915190139366, 0.95356817704321, 
## 1.1328524406471, 0.887457104839275, 1.12052664752434, 1.28300301141537, 
## 1.02528188248477, 1.0588976819105, 0.974858183346173, 0.986063449821416, 
## 1.0084739827719, 1.00735345612438, 0.998389242944184, 0.975978709993697, 
## 1.09083269136494, 1.03760767560754, 1.11492401428671, 1.1210869108481, 
## 0.945164227186778, 0.969255550108551, 0.863365781917501, 0.955248967014497, 
## 1.0588976819105, 0.935639750682821, 0.946845017158064, 0.812381819455144, 
## 0.868408151831361, 0.817984452692766, 1.04208978219763), vs = c(0, 
## 0, 2.28571428571429, 2.28571428571429, 0, 2.28571428571429, 0, 
## 2.28571428571429, 2.28571428571429, 2.28571428571429, 2.28571428571429, 
## 0, 0, 0, 0, 0, 0, 2.28571428571429, 2.28571428571429, 2.28571428571429, 
## 2.28571428571429, 0, 0, 0, 0, 2.28571428571429, 0, 2.28571428571429, 
## 0, 0, 0, 2.28571428571429), am = c(NA_integer_, NA_integer_, 
## NA_integer_, NA_integer_, NA_integer_, NA_integer_, NA_integer_, 
## NA_integer_, NA_integer_, NA_integer_, NA_integer_, NA_integer_, 
## NA_integer_, NA_integer_, NA_integer_, NA_integer_, NA_integer_, 
## NA_integer_, NA_integer_, NA_integer_, NA_integer_, NA_integer_, 
## NA_integer_, NA_integer_, NA_integer_, NA_integer_, NA_integer_, 
## NA_integer_, NA_integer_, NA_integer_, NA_integer_, NA_integer_
## ), gear = c(1.08474576271186, 1.08474576271186, 1.08474576271186, 
## 0.813559322033898, 0.813559322033898, 0.813559322033898, 0.813559322033898, 
## 1.08474576271186, 1.08474576271186, 1.08474576271186, 1.08474576271186, 
## 0.813559322033898, 0.813559322033898, 0.813559322033898, 0.813559322033898, 
## 0.813559322033898, 0.813559322033898, 1.08474576271186, 1.08474576271186, 
## 1.08474576271186, 0.813559322033898, 0.813559322033898, 0.813559322033898, 
## 0.813559322033898, 0.813559322033898, 1.08474576271186, 1.35593220338983, 
## 1.35593220338983, 1.35593220338983, 1.35593220338983, 1.35593220338983, 
## 1.08474576271186), carb = c(1.42222222222222, 1.42222222222222, 
## 0.355555555555556, 0.355555555555556, 0.711111111111111, 0.355555555555556, 
## 1.42222222222222, 0.711111111111111, 0.711111111111111, 1.42222222222222, 
## 1.42222222222222, 1.06666666666667, 1.06666666666667, 1.06666666666667, 
## 1.42222222222222, 1.42222222222222, 1.42222222222222, 0.355555555555556, 
## 0.711111111111111, 0.355555555555556, 0.355555555555556, 0.711111111111111, 
## 0.711111111111111, 1.42222222222222, 0.711111111111111, 0.355555555555556, 
## 0.711111111111111, 0.711111111111111, 1.42222222222222, 2.13333333333333, 
## 2.84444444444444, 0.711111111111111)))
</pre></div>

<p></div></div></p>

<p>It&#39;s even simpler inside a function, because we don&#39;t need to explicitly quote the x and y variables. Following the rules above, <code>substitute()</code> replaces named arguments with their expressions, not their values:</p>

<div class="chunk" id="unnamed-chunk-416"><div class="rcode"><div class="source"><pre class="knitr r">xyplot2 <- function(x, y, data = data) {
  substitute(xyplot(x ~ y, data = data))
}
xyplot2(mpg, displ, data = mtcars)
</pre></div>

<div class="output"><pre class="knitr r">## xyplot(mpg ~ displ, data = mtcars)
</pre></div>

<p></div></div></p>

<p>If we include <code>...</code> in the call to substitute, we can add additional arguments to the call:</p>

<div class="chunk" id="unnamed-chunk-417"><div class="rcode"><div class="source"><pre class="knitr r">xyplot3 <- function(x, y, ...) {
  substitute(xyplot(x ~ y, ...))
}
xyplot3(mpg, displ, data = mtcars, col = "red", aspect = "xy")
</pre></div>

<div class="output"><pre class="knitr r">## xyplot(mpg ~ displ, data = mtcars, col = "red", aspect = "xy")
</pre></div>

<p></div></div></p>

<h3>Non-standard evaluation in substitute</h3>

<p>One application of this idea is to make a version of <code>substitute</code> that evaluates its first argument (i.e. a version that uses standard evaluation). Note the following example:</p>

<div class="chunk" id="unnamed-chunk-418"><div class="rcode"><div class="source"><pre class="knitr r">x <- quote(a + b)
substitute(x, list(a = 1, b = 2))
</pre></div>

<div class="output"><pre class="knitr r">## x
</pre></div>

<p></div></div></p>

<p>Instead we can use <code>pryr::substitute2</code>:</p>

<div class="chunk" id="unnamed-chunk-419"><div class="rcode"><div class="source"><pre class="knitr r">x <- quote(a + b)
substitute2(x, list(a = 1, b = 2))
</pre></div>

<div class="error"><pre class="knitr r">## Error: is.language(x) is not TRUE
</pre></div>

<p></div></div></p>

<p>The implementation of <code>substitute2</code> is short, but deep:</p>

<div class="chunk" id="unnamed-chunk-420"><div class="rcode"><div class="source"><pre class="knitr r">substitute2 <- function(x, env) {
  call <- substitute(substitute(y, env), list(y = x))
  eval(call)
}
</pre></div>

<p></div></div></p>

<p>Let&#39;s work through the example above: <code>substitute2(x, list(a = 1, b = 2))</code>.  It&#39;s a little tricky because of <code>substitute()</code>&#39;s non-standard evaluation rules, we can&#39;t use the usual technique of working through the parentheses inside-out.</p>

<ol>
<li><p>First <code>substitute(substitute(y, env), list(y = x))</code> is evaluated. The first argument is specially evaluated in the environment containing only one item, the value of <code>x</code> with the name <code>y</code>. Because we&#39;ve put <code>x</code> inside a list, it will be evaluated and the rules of substitute will replace <code>y</code> with it&#39;s value. This yields the expression <code>substitute(a + b, env)</code></p></li>
<li><p>Next we evaluate that expression inside the current function. <code>substitute()</code> specially evaluates its first argument, and looks for name value pairs in <code>env</code>, which evaluates to <code>list(a = 1, b = 2)</code>. Those are both values (not promises) so the result will be <code>a + b</code></p></li>
</ol>

<h3>Capturing unevaluated ...</h3>

<p>Another frequently useful technique is to capture all of the unevaluated expressions in <code>...</code>.  Base R functions do this in many ways, but there&#39;s one technique that works well in a wide variety of situations:</p>

<div class="chunk" id="unnamed-chunk-421"><div class="rcode"><div class="source"><pre class="knitr r">dots <- function(...) {
  eval(substitute(alist(...)))
}
</pre></div>

<p></div></div></p>

<p>This uses the <code>alist()</code> function which simply captures all its arguments.  This function is the same as <code>pryr::dots()</code>, and pryr also provides <code>pryr::named_dots()</code>, which ensures all arguments are named, using the deparsed expressions as default names.</p>

<h2>The downsides of non-standard evaluation</h2>

<p>There are usually two principles you can follow when modelling the evaluation of R code:</p>

<ul>
<li>If the underlying values are the same, the results will the same. i.e. the three results will all be the same:</li>
</ul>

<div class="chunk" id="unnamed-chunk-422"><div class="rcode"><div class="source"><pre class="knitr r">x <- 10; y <- 10
f(10); f(x); f(y)
</pre></div>

<div class="error"><pre class="knitr r">## Error: unused argument (10)
</pre></div>

<p></div></div></p>

<ul>
<li>You can model evaluation by working from the innermost parentheses to the outermost.</li>
</ul>

<p>Non-standard evaluation can break both principles.  This makes the mental model needed to correctly predict the output much more complicated, so it&#39;s only worthwhile to do so if there is significant gain. </p>

<p>For example, <code>library()</code> and <code>require()</code> allow you to call them either with or without quotes, because internally they use <code>deparse(substitute(x))</code> plus a couple of tricks. That means that these two lines do exactly the same thing:</p>

<div class="chunk" id="unnamed-chunk-423"><div class="rcode"><div class="source"><pre class="knitr r">library(ggplot2)
library("ggplot2")
</pre></div>

<p></div></div></p>

<p>However, things start to get complicated if the variable has a value.. What do you think the following lines of code will do?</p>

<div class="chunk" id="unnamed-chunk-424"><div class="rcode"><div class="source"><pre class="knitr r">ggplot2 <- "plyr"
library(ggplot2)
</pre></div>

<p></div></div></p>

<p>It loads ggplot2, not plyr.  If you want to load plyr (the value of the ggplot2 variable), you need to use an additional argument:</p>

<div class="chunk" id="unnamed-chunk-425"><div class="rcode"><div class="source"><pre class="knitr r">library(ggplot2, character.only = TRUE)
</pre></div>

<p></div></div></p>

<p>Using an argument to change the behaviour of another argument is not a great idea because it means you must completely and carefully read all of the function arguments to understand what one function argument means. You can&#39;t understand the effect of each argument in isolation, and hence it&#39;s harder to reason about the results of a function call.</p>

<p>There are a number of other R functions that use <code>substitute()</code> and <code>deparse()</code> in this way: <code>ls()</code>, <code>rm()</code>, <code>data()</code>, <code>demo()</code>, <code>example()</code>, <code>vignette()</code>. These all use non-standard evaluation and then have a special ways of enforcing the usual rules. To me, eliminating two quotes is not worth the cognitive cost of non-standard evaluation, and I don&#39;t recommend you use <code>substitute()</code> for this purpose.</p>

<p>One situtation where non-standard evaluation is more useful is <code>data.frame()</code>, which uses the input expressions to automatically name the output variables if not otherwise provided:</p>

<div class="chunk" id="unnamed-chunk-426"><div class="rcode"><div class="source"><pre class="knitr r">x <- 10
y <- "a"
df <- data.frame(x, y)
names(df)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x" "y"
</pre></div>

<p></div></div></p>

<p>I think it is worthwhile in <code>data.frame()</code> because it eliminates a lot of redundancy in the common scenario when you&#39;re creating a data frame from existing variables, and importantly, it&#39;s easy to override this behaviour by supplying names for each variable. </p>

<p>The code for <code>data.frame()</code> is rather complicated, but we can create our own simple version for lists to see how a function that does this might work. The key is <code>pryr::named_dots()</code>, a function which returns the unevaluated ... arguments, with default names. Then it&#39;s just a matter of arranging the evaluated results in a list:</p>

<div class="chunk" id="unnamed-chunk-427"><div class="rcode"><div class="source"><pre class="knitr r">list2 <- function(...) {
  dots <- named_dots(...)
  lapply(dots, eval, parent.frame())
}
x <- 1; y <- 2
list2(x, y)
</pre></div>

<div class="output"><pre class="knitr r">## $x
## [1] 0.6467
## 
## $y
## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">list2(x, z = y)
</pre></div>

<div class="output"><pre class="knitr r">## $x
## [1] 0.5841
## 
## $z
## [1] 2
</pre></div>

<p></div></div></p>

<h2>Applications</h2>

<p>To show how I&#39;ve used some of these ideas in practice, the following two sections show applications of non-standard evaluation to plyr and ggplot2.</p>

<h3><code>plyr::.</code> and <code>ggplot2::aes</code></h3>

<p>Both plyr and ggplot2 have ways of capturing what you want to do, and then performing that action later. ggplot2 uses the <code>aes()</code> to define a set of mappings between variables in your data and visual properties on your graphic. plyr uses the <code>.</code> function to capture the names (or more complicated expressions) of variables used to split a data frame into pieces. Let&#39;s look at the code:</p>

<div class="chunk" id="unnamed-chunk-428"><div class="rcode"><div class="source"><pre class="knitr r">. <- function (..., .env = parent.frame()) {
  structure(
    as.list(match.call()[-1]), 
    env = .env, 
    class = "quoted"
  )
}

aes <- function (x = NULL, y = NULL, ...) {
  aes <- structure(
    as.list(match.call()[-1]), 
    class = "uneval")
  class(aes) <- "uneval"
  ggplot2:::rename_aes(aes)
}
</pre></div>

<p></div></div></p>

<p>Both functions were written when I didn&#39;t know so much about non-standard evaluation, and if I was to write them today, I&#39;d use the <code>dots()</code> helper function I showed previously.  I&#39;d also think more about the environment in which the results of <code>aes()</code> should be evaluated, and how that integrates with ggplot2&#39;s rules for aesthetic mapping inheritance. That&#39;s a bit murky at the moment and leads to confusion when creating complex graphics across multiple functions.</p>

<p>ggplot2 and plyr provide slightly different ways to use standard evaluation so that you can refer to variables by reference. ggplot2 provides <code>aes_string()</code> which allows you to specify variables by the string representation of their name, and plyr uses S3 methods so that you can either supply an object of class quoted (as created with <code>.()</code>), or a regular character vector.</p>

<h3>Plyr: summarise, mutate and arrange</h3>

<p>The plyr package also uses non-standard evaluation to complete the set of tools provided by the base <code>subset()</code> and <code>transform()</code> functions with <code>mutate()</code>, <code>summarise()</code> and <code>arrange()</code>. Each of these functions has the same interface: the first argument is a data frame and the subsequent arguments are evaluated in the context of that data frame (i.e. they look there first for variables, and then in the current environment) and they return a data frame.</p>

<p>The following code shows the essence of how these four functions work: </p>

<div class="chunk" id="unnamed-chunk-429"><div class="rcode"><div class="source"><pre class="knitr r">subset2 <- function(.data, subset) {
  sub <- eval(substitute(subset), .data, parent.frame())
  sub <- sub & !is.na(sub)

  .data[r, , drop = FALSE]
}
arrange2 <- function (.data, ...) {
  ord <- eval(substitute(order(...)), .data, parent.frame())
  .data[ord, , drop = FALSE]
}

mutate2 <- function(.data, ...) {
  cols <- named_dots(...)
  data_env <- eval_df(.data, parent.frame(), cols)

  out_cols <- union(names(.data), names(cols))
  quickdf(mget(out_cols, data_env))
}
summarise2 <- function (.data, ...) {
  cols <- named_dots(...)
  data_env <- eval_df(.data, parent.frame(), cols)

  quickdf(mget(names(cols), env))
}
eval_df <- function(data, env, expr) {
  data_env <- list2env(data, parent = env)

  for(nm in names(exprs)) {
    data_env[[nm]] <- eval(data_env[[nm]], env)
  }
  data_env
}
</pre></div>

<p></div></div></p>

<p>You might be surprised to see the for loops in <code>eval_df</code>, but they are necessary because the computation of one variable might depend on the results of previous variables (this is the key difference between <code>mutate()</code> and <code>transform()</code>).</p>

<p>Combined with a by operator (e.g. <code>ddply()</code>) these four functions allow you to express the majority of data manipulation operations. Then when you have a new problem, solving it becomes a matter of thinking about which operations you need to apply and in what order. The realm of possible actions has been shrunk to a manageable number.</p>

<h2>Conclusion</h2>

<p>Now that you understand how our version of subset works, go back and read the source code for <code>subset.data.frame</code>, the base R version which does a little more. Other functions that work similarly are <code>with.default</code>, <code>within.data.frame</code>, <code>transform.data.frame</code>, and in the plyr package <code>.</code>, <code>arrange</code>, and <code>summarise</code>. Look at the source code for these functions and see if you can figure out how they work.</p>

<h1>Expressions</h1>

<p>In [[computing on the language]], you learned the basics of accessing the expressions underlying computation in R, and evaluating them in new ways. In this chapter, you&#39;ll learn more about the underlying structure of expressions, and how you can compute on them directly.</p>

<ul>
<li><p>The structure of expressions (a tree made up of constants, names and calls) and how you can create and modify them directly</p></li>
<li><p>How to flexibly convert expressions between their tree form and their text form, and learn how <code>source()</code> works.</p></li>
<li><p>Create functions by hand as an alternative instead of using a closure, so that viewing the source of the function shows something meaningful</p></li>
<li><p>Walk the code tree using recursive functions to understand how many of the functions in the codetools package work, and to you write your own functions that detect if a function uses logical abbreviations, list all assignments inside a function and understand how <code>bquote()</code> works.</p></li>
</ul>

<p>It&#39;s generally a bad idea to create code by operating on its string representation: there is no guarantee that you&#39;ll create valid code.  Don&#39;t get me wrong: pasting strings together will often allow you to solve your problem in the least amount of time, but it may create subtle bugs that will take your users hours to track down. Learning more about the structure of the R language and the tools that allow you to modify it is an investment that will pay off by allowing you to make more robust code.</p>

<p>Thoroughout this chapter we&#39;re going to use tools from the <code>pryr</code> package to help see what&#39;s going on.  If you don&#39;t already have it, install it by running <code>devtools::install_github(&quot;pryr&quot;)</code></p>

<h2>Structure of expressions</h2>

<p>To compute on the language, we first need to be understand the structure of the language. That&#39;s going to require some new vocabulary, some new tools and some new ways of thinking about R code. The first thing you need to understand is the distinction between an operation and its result:</p>

<div class="chunk" id="unnamed-chunk-432"><div class="rcode"><div class="source"><pre class="knitr r">x <- 4
y <- x * 10
y
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5.423
</pre></div>

<p></div></div></p>

<p>We want to distinguish between the action of multiplying x by 10 and assigning the results to <code>y</code> versus the actual result (40).  In R, we can capture the action with <code>quote()</code>:</p>

<div class="chunk" id="unnamed-chunk-433"><div class="rcode"><div class="source"><pre class="knitr r">z <- quote(y <- x * 10)
z
</pre></div>

<div class="output"><pre class="knitr r">## y <- x * 10
</pre></div>

<p></div></div></p>

<p><code>quote()</code> gives us back an <strong>expression</strong>, an object that represents an action that can be performed by R. (Confusingly the <code>expression()</code> function produces expression lists, but since you&#39;ll never need to use that function we can safely ignore it).</p>

<p>An expression is also called an abstract syntax tree (AST) because it represents the abstract structure of the code in a tree form. We can use <code>pryr::call_tree()</code> to see the hierarchy more clearly:</p>

<div class="chunk" id="unnamed-chunk-434"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
call_tree(z)
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31m<-()[0m
##   \- [0;34m`y[0m
##   \- [0;31m*()[0m
##     \- [0;34m`x[0m
##     \- [0;30m10[0m
</pre></div>

<p></div></div></p>

<p>There are three basic things you&#39;ll commonly see in a call tree: constants, names and calls.</p>

<ul>
<li><strong>constants</strong> are atomic vectors, like <code>&quot;a&quot;</code> or <code>10</code>. These appear as is. </li>
</ul>

<div class="chunk" id="unnamed-chunk-435"><div class="rcode"><div class="source"><pre class="knitr r">call_tree(quote("a"))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;30m"a"[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(1))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;30m1[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(1L))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;30m1L[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(TRUE))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;30mTRUE[0m
</pre></div>

<p></div></div></p>

<ul>
<li><strong>names</strong> which represent the name of a variable, not its value. (Names are also sometimes called symbols). These are prefixed with <code>&#39;</code></li>
</ul>

<div class="chunk" id="unnamed-chunk-436"><div class="rcode"><div class="source"><pre class="knitr r">call_tree(quote(x))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;34m`x[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(mean))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;34m`mean[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(`an unusual name`))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;34m`an unusual name[0m
</pre></div>

<p></div></div></p>

<ul>
<li><strong>calls</strong> represent the action of calling a function, not its result. These are suffixed with <code>()</code>.  The arguments to the function are listed below it, and can be constants, names or other calls.</li>
</ul>

<div class="chunk" id="unnamed-chunk-437"><div class="rcode"><div class="source"><pre class="knitr r">call_tree(quote(f()))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mf()[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(f(1, 2)))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mf()[0m
##   \- [0;30m1[0m
##   \- [0;30m2[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(f(a, b)))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mf()[0m
##   \- [0;34m`a[0m
##   \- [0;34m`b[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(f(g(), h(1, a))))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mf()[0m
##   \- [0;31mg()[0m
##   \- [0;31mh()[0m
##     \- [0;30m1[0m
##     \- [0;34m`a[0m
</pre></div>

<p></div></div></p>

<pre><code>As mentioned in [Functions](Functions.html), even things that don&#39;t look like function calls still follow this same hierarchical structure:
</code></pre>

<div class="chunk" id="unnamed-chunk-438"><div class="rcode"><div class="source"><pre class="knitr r">call_tree(quote(a + b))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31m+()[0m
##   \- [0;34m`a[0m
##   \- [0;34m`b[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(if (x > 1) x else 1/x))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mif()[0m
##   \- [0;31m>()[0m
##     \- [0;34m`x[0m
##     \- [0;30m1[0m
##   \- [0;34m`x[0m
##   \- [0;31m/()[0m
##     \- [0;30m1[0m
##     \- [0;34m`x[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(quote(function(x, y) {x * y}))
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mfunction()[0m
##   \- [0;30mlist(x = , y = )[0m
##   \- [0;31m{()[0m
##     \- [0;31m*()[0m
##       \- [0;34m`x[0m
##       \- [0;34m`y[0m
##   \- [0;30mstructure(c(3L, 17L, 3L, 38L, 17L, 38L, 3L, 3L), srcfile = <environ...[0m
</pre></div>

<p></div></div></p>

<p>(In general, it&#39;s possible for any type of R object to live in a call tree, but these are the only three types you&#39;ll get from parsing R code. It&#39;s possible to put anything else inside an expression using the tools described below, but while technically correct, support is often patchy.)</p>

<p>Together, names and calls are sometimes called language objects, and can be tested for with <code>is.language()</code>. Note that <code>str()</code> is somewhat inconsistent with respect to this naming convention, describing names as symbols, and calls as a language objects:</p>

<div class="chunk" id="unnamed-chunk-439"><div class="rcode"><div class="source"><pre class="knitr r">str(quote(a))
</pre></div>

<div class="output"><pre class="knitr r">##  symbol a
</pre></div>

<div class="source"><pre class="knitr r">str(quote(a + b))
</pre></div>

<div class="output"><pre class="knitr r">##  language a + b
</pre></div>

<p></div></div></p>

<p>Together, constants, names and calls define the structure of all R code. The following section provides more detail about each in turn.</p>

<h3>Constants</h3>

<p>Quoting a single atomic vector gives it back to you:</p>

<div class="chunk" id="unnamed-chunk-440"><div class="rcode"><div class="source"><pre class="knitr r">is.atomic(quote(1))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">identical(1, quote(1))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">is.atomic(quote("test"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">identical("test", quote("test"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>But quoting a vector of values gives you something different because you always use a function to create a vector:</p>

<div class="chunk" id="unnamed-chunk-441"><div class="rcode"><div class="source"><pre class="knitr r">identical(1:3, quote(1:3))
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">identical(c(FALSE, TRUE), quote(c(FALSE, TRUE)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<p>It&#39;s possible to use <code>substitute()</code> to directly insert a vector into a call tree, but use this with caution as you are creating a call that is not be generated during the normal operation of R.</p>

<div class="chunk" id="unnamed-chunk-442"><div class="rcode"><div class="source"><pre class="knitr r">y <- substitute(f(x), list(x = 1:3))
is.atomic(y)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<h3>Names</h3>

<p>As well as capturing names with <code>quote()</code>, it&#39;s also possible to convert strings to names. This is mostly useful when your function receives strings as input, as it&#39;s more typing than using <code>quote()</code>:</p>

<div class="chunk" id="unnamed-chunk-443"><div class="rcode"><div class="source"><pre class="knitr r">as.name("name")
</pre></div>

<div class="output"><pre class="knitr r">## name
</pre></div>

<div class="source"><pre class="knitr r">identical(quote(name), as.name("name"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">
as.name("a b")
</pre></div>

<div class="output"><pre class="knitr r">## `a b`
</pre></div>

<p></div></div></p>

<p>Note that the second example produces the name <code></code>a b<code></code>: the backticks are the standard way of escape non-standard names in R. (And are explained more in <a href="Functions.html">Functions</a>)</p>

<p>There&#39;s one special name that needs a little extra discussion: the name that represents missing values. You can get this from the formals of a function, or with <code>alist()</code>:</p>

<div class="chunk" id="unnamed-chunk-444"><div class="rcode"><div class="source"><pre class="knitr r">formals(plot)$x
</pre></div>

<div class="source"><pre class="knitr r">alist(x =)[[1]]
</pre></div>

<p></div></div></p>

<p>It is basically a special name, that you can create by using <code>quote()</code> in a slightly unusual way:</p>

<div class="chunk" id="unnamed-chunk-445"><div class="rcode"><div class="source"><pre class="knitr r">quote(expr =)
</pre></div>

<p></div></div></p>

<p>Note that this object is behaves strangely, and is rarely useful, except when (as we&#39;ll see later) you want to try a function with arguments that don&#39;t have defaults.</p>

<div class="chunk" id="unnamed-chunk-446"><div class="rcode"><div class="source"><pre class="knitr r">x <- quote(expr =)
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.2724
</pre></div>

<p></div></div></p>

<h3>Calls</h3>

<p>As well as capturing complete calls using <code>quote()</code>, modifying existing calls using <code>substitute()</code> you can also create calls from their constituent pieces using using <code>as.call()</code> or <code>call()</code>.  </p>

<p>The first argument to <code>call()</code> is a string giving a function name, and the other arguments should be expressions that are used as the arguments to the call.</p>

<div class="chunk" id="unnamed-chunk-447"><div class="rcode"><div class="source"><pre class="knitr r">call(":", 1, 10)
</pre></div>

<div class="output"><pre class="knitr r">## 1:10
</pre></div>

<div class="source"><pre class="knitr r">call("mean", 1:10, na.rm = TRUE)
</pre></div>

<div class="output"><pre class="knitr r">## mean(1:10, na.rm = TRUE)
</pre></div>

<p></div></div></p>

<p><code>as.call()</code> is a minor variation that takes a list where the first argument is the <em>name</em> of a function (not a string), and the subsequent values are the arguments. </p>

<div class="chunk" id="unnamed-chunk-448"><div class="rcode"><div class="source"><pre class="knitr r">x_call <- quote(1:10)
mean_call <- as.call(list(quote(mean), x_call))
identical(mean_call, quote(mean(1:10)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<p>Note that the following two calls look the same, but are actually different:</p>

<div class="chunk" id="unnamed-chunk-449"><div class="rcode"><div class="source"><pre class="knitr r">(a <- call("mean", 1:10))
</pre></div>

<div class="output"><pre class="knitr r">## mean(1:10)
</pre></div>

<div class="source"><pre class="knitr r">(b <- call("mean", quote(1:10)))
</pre></div>

<div class="output"><pre class="knitr r">## mean(1:10)
</pre></div>

<div class="source"><pre class="knitr r">identical(a, b)
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">call_tree(a)
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mmean()[0m
##   \- [0;30m1:10[0m
</pre></div>

<div class="source"><pre class="knitr r">call_tree(b)
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31mmean()[0m
##   \- [0;31m:()[0m
##     \- [0;30m1[0m
##     \- [0;30m10[0m
</pre></div>

<p></div></div></p>

<p>In <code>a</code>, the first argument to mean is an integer vector containing the numbers 1 to 10, and in <code>b</code> the first argument is a call to <code>:</code>.  You can put any R object into an expression, but the printing of expression objects will not always show the difference.  </p>

<p>The key difference is where/when evaluation occurs:</p>

<div class="chunk" id="unnamed-chunk-450"><div class="rcode"><div class="source"><pre class="knitr r">a <- call("print", Sys.time())
b <- call("print", quote(Sys.time()))
eval(a); Sys.sleep(1); eval(a)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "2013-08-27 08:57:09 EDT"
## [1] "2013-08-27 08:57:09 EDT"
</pre></div>

<div class="source"><pre class="knitr r">eval(b); Sys.sleep(1); eval(b)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "2013-08-27 08:57:10 EDT"
## [1] "2013-08-27 08:57:11 EDT"
</pre></div>

<p></div></div></p>

<p>The first element of a call doesn&#39;t have to be the name of a function, and instead can be a call that generates a function:</p>

<div class="chunk" id="unnamed-chunk-451"><div class="rcode"><div class="source"><pre class="knitr r">(function(x) x + 1)(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 11
</pre></div>

<div class="source"><pre class="knitr r">add <- function(y) function(x) x + y
add(1)(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 11
</pre></div>

<div class="source"><pre class="knitr r">
# Note that you can't create this sort of call with call
call("add(1)", 10)
</pre></div>

<div class="output"><pre class="knitr r">## `add(1)`(10)
</pre></div>

<div class="source"><pre class="knitr r"># But you can with as.call
as.call(list(quote(add(1)), 10))
</pre></div>

<div class="output"><pre class="knitr r">## add(1)(10)
</pre></div>

<p></div></div></p>

<h4>An interesting use of <code>call()</code></h4>

<p>One interesting use of call lies inside the <code>mode&lt;-</code> function which is an alternative way to change the mode of a vector. The important part of the function is extracted in the <code>mode2&lt;-</code> function below.</p>

<div class="chunk" id="unnamed-chunk-452"><div class="rcode"><div class="source"><pre class="knitr r">`mode2<-` <- function (x, value) {
  mde <- paste0("as.", value)
  eval(call(mde, x), parent.frame())
}
x <- 1:10
mode2(x) <- "character"
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.1706
</pre></div>

<p></div></div></p>

<p>Another way to achieve the same goal would be find the function and then call it:</p>

<div class="chunk" id="unnamed-chunk-453"><div class="rcode"><div class="source"><pre class="knitr r">`mode3<-` <- function(x, value) {
  mde <- match.fun(paste0("as.", value))
  mde(x)
}
x <- 1:10
mode3(x) <- "character"
x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.6207
</pre></div>

<p></div></div></p>

<p>Generally, I&#39;d prefer <code>mode3&lt;-</code> over <code>mode2&lt;-</code> because it uses concepts familiar to more R programmers, and generally it&#39;s a good idea to use the simplest and most commonly understand techniques that solve a given problem. </p>

<h4>Extracting elements of a call</h4>

<p>When it comes to modifying calls, they behave almost exactly like lists: a call has <code>length</code>, <code>&#39;[[</code> and <code>[</code> methods. The length of a call minus 1 gives the number of arguments:</p>

<div class="chunk" id="unnamed-chunk-454"><div class="rcode"><div class="source"><pre class="knitr r">x <- quote(read.csv("important.csv", row.names = FALSE))
length(x) - 1
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0
</pre></div>

<p></div></div></p>

<p>The first element of the call is the <em>name</em> of the function:</p>

<div class="chunk" id="unnamed-chunk-455"><div class="rcode"><div class="source"><pre class="knitr r">x[[1]]
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.7667
</pre></div>

<div class="source"><pre class="knitr r"># read.csv
</pre></div>

<p></div></div></p>

<p>The remaining elements are the arguments to the function, which can be extracted by name or by position.</p>

<div class="chunk" id="unnamed-chunk-456"><div class="rcode"><div class="source"><pre class="knitr r">x$row.names
</pre></div>

<div class="error"><pre class="knitr r">## Error: $ operator is invalid for atomic vectors
</pre></div>

<div class="source"><pre class="knitr r">x[[3]]
</pre></div>

<div class="error"><pre class="knitr r">## Error: subscript out of bounds
</pre></div>

<div class="source"><pre class="knitr r">
names(x)
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<p></div></div></p>

<h4>Standardising function calls</h4>

<p>Generally, extracting arguments by position is dangerous, because R&#39;s function calling semantics are so flexible. It&#39;s better to match by name, but all arguments might not be named. The solution to this problem is to use <code>match.call()</code>, which takes a function and a call as arguments:</p>

<div class="chunk" id="unnamed-chunk-457"><div class="rcode"><div class="source"><pre class="knitr r">y <- match.call(read.csv, x)
</pre></div>

<div class="error"><pre class="knitr r">## Error: invalid 'call' argument
</pre></div>

<div class="source"><pre class="knitr r">names(y)
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<div class="source"><pre class="knitr r">
# Or if you don't know in advance what the function is
match.call(eval(x[[1]]), x)
</pre></div>

<div class="error"><pre class="knitr r">## Error: invalid 'call' argument
</pre></div>

<p></div></div></p>

<p>This will be an important tool when we start manipulating existing function calls. If we don&#39;t use <code>match.call</code> we&#39;ll need a lot of extra code to deal with all the possible ways to call a function.</p>

<p>We can wrap this up into a function. To figure out the definition of the associated function we evaluate the first component of the call, the name of the function. We need to specify an environment here, because the function might be different in different places. Whenever we provide an environment parameter, <code>parent.frame()</code> is usually a good default. </p>

<p>Note the check for primitive functions: they don&#39;t have <code>formals()</code> and handle argument matching specially, so there&#39;s nothing we can do.</p>

<div class="chunk" id="unnamed-chunk-458"><div class="rcode"><div class="source"><pre class="knitr r">standardise_call <- function(call, env = parent.frame()) {
  stopifnot(is.call(call))
  f <- eval(call[[1]], env)
  if (is.primitive(f)) return(call)

  match.call(f, call)
}

standardise_call(y)
</pre></div>

<div class="error"><pre class="knitr r">## Error: unused argument (1:3)
</pre></div>

<div class="source"><pre class="knitr r">standardise_call(quote(standardise_call(y)))
</pre></div>

<div class="output"><pre class="knitr r">## standardise_call(call = y)
</pre></div>

<p></div></div></p>

<h4>Modifying a call</h4>

<p>You can add, modify and delete elements of the call with the standard replacement operators, <code>$&lt;-</code> and <code>[[&lt;-</code>:</p>

<div class="chunk" id="unnamed-chunk-459"><div class="rcode"><div class="source"><pre class="knitr r">y$row.names <- TRUE
y$col.names <- FALSE
y
</pre></div>

<div class="output"><pre class="knitr r">## f(1:3, row.names = TRUE, col.names = FALSE)
</pre></div>

<div class="source"><pre class="knitr r">
y[[2]] <- "less-important.csv"
y[[4]] <- NULL
y
</pre></div>

<div class="output"><pre class="knitr r">## f("less-important.csv", row.names = TRUE)
</pre></div>

<div class="source"><pre class="knitr r">
y$file <- quote(paste0(filename, ".csv"))
y
</pre></div>

<div class="output"><pre class="knitr r">## f("less-important.csv", row.names = TRUE, file = paste0(filename, 
##     ".csv"))
</pre></div>

<p></div></div></p>

<p>Calls also support the <code>[</code> method, but use it with care: since the first element is the function to call, removing it is unlikely to create a call that will evaluate without error.</p>

<div class="chunk" id="unnamed-chunk-460"><div class="rcode"><div class="source"><pre class="knitr r">x[-3] # remove the second argument
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.8686
</pre></div>

<div class="source"><pre class="knitr r">x[-1] # remove the function name - but it's still a call!
</pre></div>

<div class="output"><pre class="knitr r">## numeric(0)
</pre></div>

<div class="source"><pre class="knitr r">x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 0.9225
</pre></div>

<p></div></div></p>

<p>If you want to get a list of the unevaluated arguments, explicitly convert it to a list:</p>

<div class="chunk" id="unnamed-chunk-461"><div class="rcode"><div class="source"><pre class="knitr r"># A list of the unevaluated arguments
as.list(x[-1])
</pre></div>

<div class="output"><pre class="knitr r">## list()
</pre></div>

<p></div></div></p>

<p>We can use these ideas to create an easy way modify a call given a list. </p>

<div class="chunk" id="unnamed-chunk-462"><div class="rcode"><div class="source"><pre class="knitr r">modify_call <- function(call, new_args) {
  call <- standardise_call(call)
  nms <- names(new_args) %||% rep("", length(new_args))

  if (any(nms == "")) {
    stop("All new arguments must be named", call. = FALSE)
  }

  for(nm in nms) {
    call[[nm]] <- new_args[[nm]]
  }
  call
}
modify_call(quote(mean(x, na.rm = TRUE)), list(na.rm = NULL))
</pre></div>

<div class="output"><pre class="knitr r">## mean(x = x)
</pre></div>

<div class="source"><pre class="knitr r">modify_call(quote(mean(x, na.rm = TRUE)), list(na.rm = FALSE))
</pre></div>

<div class="output"><pre class="knitr r">## mean(x = x, na.rm = FALSE)
</pre></div>

<div class="source"><pre class="knitr r">modify_call(quote(mean(x, na.rm = TRUE)), list(x = quote(y)))
</pre></div>

<div class="output"><pre class="knitr r">## mean(x = y, na.rm = TRUE)
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li>If you create a functional, you may want it to accept the name of a function as a string or the name of a function. Use <code>substitute()</code> and what you know about expressions to create a function that returns a list containing the name of the function (where you can determine it) and the function itself. </li>
</ul>

<div class="chunk" id="unnamed-chunk-463"><div class="rcode"><div class="source"><pre class="knitr r">fname(mean)
list(name = "mean", f = mean)
fname("mean")
list(name = "mean", f = mean)
fname(function(x) sum(x) / length(x))
list(name = "<anonymous>", f = function(x) sum(x) / length(x))
</pre></div>

<p></div></div></p>

<p>Create a version that uses standard evaluation suitable for calling from another function (Hint: it should have two arguments: an expression and an environment).</p>

<h2>Parsing and deparsing</h2>

<p>You can convert quoted calls back and forth between text with <code>parse()</code> and <code>deparse()</code>. You&#39;ve seen <code>deparse()</code> already it: takes an expression and returns a character vector. <code>parse()</code> does the opposite: it takes a character vector and returns a list of expressions, also known as an expression object or expression list.</p>

<p>Note that because the primary use of <code>parse()</code> is parsing files of code on disk, the first argument is a file path, and if you have the code in a character vector, you need to use the <code>text</code> argument.</p>

<div class="chunk" id="unnamed-chunk-464"><div class="rcode"><div class="source"><pre class="knitr r">z <- quote(y <- x * 10)
deparse(z)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "y <- x * 10"
</pre></div>

<div class="source"><pre class="knitr r">
parse(text = deparse(z))
</pre></div>

<div class="output"><pre class="knitr r">## expression(y <- x * 10)
</pre></div>

<p></div></div></p>

<p><code>deparse()</code> returns a character vector with an entry for each line, and by default it will try to make lines that are around 60 characters long. If you want a single string be sure to <code>paste()</code> it back together, and read the other options in the documentation. </p>

<p><code>parse()</code> can&#39;t return just a single expression, because there might be many top-level calls in an file. So instead it returns expression objects, or expression lists. You should never need to create expression objects yourself, and all you need to know about them is that they&#39;re a list of calls:</p>

<div class="chunk" id="unnamed-chunk-465"><div class="rcode"><div class="source"><pre class="knitr r">exp <- parse(text = c("x <- 4\ny <- x * 10"))
length(exp)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">exp[[1]]
</pre></div>

<div class="output"><pre class="knitr r">## x <- 4
</pre></div>

<div class="source"><pre class="knitr r">is.call(exp[[1]])
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">call_tree(exp)
</pre></div>

<div class="output"><pre class="knitr r">## \- [0;31m<-()[0m
##   \- [0;34m`x[0m
##   \- [0;30m4[0m
## 
## \- [0;31m<-()[0m
##   \- [0;34m`y[0m
##   \- [0;31m*()[0m
##     \- [0;34m`x[0m
##     \- [0;30m10[0m
</pre></div>

<p></div></div></p>

<p>It&#39;s not possible for <code>parse()</code> and <code>deparse()</code> be completely symmetric. See the help for <code>deparse()</code> for more details.</p>

<h3>Sourcing files from disk</h3>

<p>With <code>parse()</code> and <code>eval()</code> you can write your own simple version of <code>source()</code>. We read in the file on disk, <code>parse()</code> it and then <code>eval()</code> each component in the specified environment. This version defaults to a new environment, so it doesn&#39;t affect existing objects. <code>source()</code> invisibly returns the result of the last expression in the file, so <code>simple_source()</code> does the same.</p>

<div class="chunk" id="unnamed-chunk-466"><div class="rcode"><div class="source"><pre class="knitr r">simple_source <- function(file, envir = new.env()) {
  stopifnot(file.exists(file))
  stopifnot(is.environment(envir))

  lines <- readLines(file, warn = FALSE)
  exprs <- parse(text = lines, n = -1)

  n <- length(exprs)
  if (n == 0L) return(invisible())

  for (i in seq_len(n - 1)) {
    eval(exprs[i], envir)
  }
  invisible(eval(exprs[n], envir))
}
</pre></div>

<p></div></div></p>

<p>The real <code>source()</code> is considerably more complicated because it preserves the underlying source code, can <code>echo</code> input and output, and has many additional settings to control behaviour.</p>

<h3>Exercises</h3>

<h2>Capturing the current call</h2>

<p>You may want to capture the expression that caused the current function to be run. There are two ways to do this: </p>

<ul>
<li><p><code>sys.call()</code> captures exactly what the user typed</p></li>
<li><p><code>match.call()</code> uses R&#39;s regular argument matching rules and converts everything to full name matching. This is usually easier to work with because you know that the call will always have the same structure.</p></li>
</ul>

<p>The following example illustrates the difference:</p>

<div class="chunk" id="unnamed-chunk-467"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(abc = 1, def = 2, ghi = 3, ...) {
  list(sys = sys.call(), match = match.call())
}
f(d = 2, 2)
</pre></div>

<div class="output"><pre class="knitr r">## $sys
## f(d = 2, 2)
## 
## $match
## f(abc = 2, def = 2)
</pre></div>

<p></div></div></p>

<h4>A cautionary tale: <code>write.csv</code></h4>

<p><code>write.csv()</code> is a base R function where call manipulation is used in a suboptimal manner. It captures the call to <code>write.csv()</code> and mangles it to instead call <code>write.table()</code>:</p>

<div class="chunk" id="unnamed-chunk-468"><div class="rcode"><div class="source"><pre class="knitr r">write.csv <- function (...) {
  Call <- match.call(expand.dots = TRUE)
  for (argname in c("append", "col.names", "sep", "dec", "qmethod")) {
    if (!is.null(Call[[argname]])) {
      warning(gettextf("attempt to set '%s' ignored", argname), domain = NA)
    }
  }
  rn <- eval.parent(Call$row.names)
  Call$append <- NULL
  Call$col.names <- if (is.logical(rn) && !rn) TRUE else NA
  Call$sep <- ","
  Call$dec <- "."
  Call$qmethod <- "double"
  Call[[1L]] <- as.name("write.table")
  eval.parent(Call)
}
</pre></div>

<p></div></div></p>

<p>We could write a function that behaves identically using regular function call semantics:</p>

<div class="chunk" id="unnamed-chunk-469"><div class="rcode"><div class="source"><pre class="knitr r">write.csv <- function(x, file = "", sep = ",", qmethod = "double", ...) {
  write.table(x = x, file = file, sep = sep, qmethod = qmethod, ...)
}
</pre></div>

<p></div></div></p>

<p>This makes the function much easier to understand: it&#39;s just calling <code>write.table</code> with different defaults.  This also fixes a subtle bug in the original <code>write.csv</code>: <code>write.csv(mtcars, row = FALSE)</code> raises an error, but <code>write.csv(mtcars, row.names = FALSE)</code> does not. There&#39;s also no reason that <code>write.csv</code> shouldn&#39;t accept the <code>append</code> argument. Generally, you always want to use the simplest tool that will solve a problem - that makes it more likely that others will understand your code. Again, there&#39;s no point in using non-standard evaluation unless there&#39;s a big win: non-standard evaluation will make your function behave much less predictably.</p>

<h3>Other uses of call capturing</h3>

<p>Many modelling functions use <code>match.call()</code> to capture the call used to create the model. (This is one reason that creating lists of models using a function doesn&#39;t give the greatest output). This makes it possible to <code>update()</code> a model, modifying only a few components of the original model (but note that it doesn&#39;t preserve any of the computation, even if possible). Here&#39;s a quick example of <code>update()</code> in case you haven&#39;t used it before:</p>

<div class="chunk" id="unnamed-chunk-470"><div class="rcode"><div class="source"><pre class="knitr r">mod <- lm(mpg ~ wt, data = mtcars)
update(mod, formula = . ~ . + cyl)
</pre></div>

<div class="output"><pre class="knitr r">## 
## Call:
## lm(formula = mpg ~ wt + cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl  
##       1.975       -0.511       -0.464
</pre></div>

<div class="source"><pre class="knitr r">update(mod, subset = cyl == 4)
</pre></div>

<div class="error"><pre class="knitr r">## Error: 0 (non-NA) cases
</pre></div>

<p></div></div></p>

<p>How does <code>update()</code> work?  We can rewrite it using some of the tools (<code>dots()</code> and <code>modify_call()</code>) we&#39;ve developed in this chapter to make it easier to see exactly what&#39;s going on.  Once you&#39;ve figured out what&#39;s going on here, you might want to read the source code for <code>update.default()</code> and see if you can how each component corresponds between the two versions.</p>

<div class="chunk" id="unnamed-chunk-471"><div class="rcode"><div class="source"><pre class="knitr r">update_call <- function (object, formula., ...) {
  call <- object$call
  
  # Use a update.formula to deal with formulas like . ~ .
  if (!missing(formula.)) {
    call$formula <- update.formula(formula(object), formula.)
  }

  modify_call(call, dots(...))   
}
update2 <- function(object, formula., ...) {
  call <- update_call(object, formula., ...)
  eval(call, parent.frame())
}
update_call(mod, formula = . ~ . + cyl)
</pre></div>

<div class="output"><pre class="knitr r">## lm(formula = mpg ~ wt + cyl, data = mtcars)
</pre></div>

<div class="source"><pre class="knitr r">update_call(mod, subset = cyl == 4)
</pre></div>

<div class="output"><pre class="knitr r">## lm(formula = mpg ~ wt, data = mtcars, subset = cyl == 4)
</pre></div>

<p></div></div></p>

<p>The original <code>update()</code> has an <code>evaluate</code> argument that controls whether the function returns a call or the result, but I think it&#39;s good principle for a function to only return one type of object (not different types depending on the arguments) so I split it into two.</p>

<p>This rewrite also allows us to fix a small bug in update: it evaluates the call in the global environment, when really we want to re-evaluate it in the environment where the model was originally fit. This happens to be stored in the formula (called terms) so we can easily extract it.</p>

<div class="chunk" id="unnamed-chunk-472"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() {
  n <- 3
  lm(mpg ~ poly(wt, n), data = mtcars)
}
mod <- f()
update(mod, data = mtcars)
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'n' not found
</pre></div>

<div class="source"><pre class="knitr r">
update2 <- function(object, formula., ...) {
  call <- update_call(object, formula., ...)
  eval(call, environment(object$terms))
}
update2(mod, data = mtcars)
</pre></div>

<div class="output"><pre class="knitr r">## 
## Call:
## lm(formula = mpg ~ poly(wt, n), data = mtcars)
## 
## Coefficients:
##  (Intercept)  poly(wt, n)1  poly(wt, n)2  poly(wt, n)3  
##       1.0000       -1.4492        0.4298        0.0137
</pre></div>

<p></div></div></p>

<p>This is a good principle to remember: if you want to later replay the code you&#39;ve captured using <code>match.call()</code> you really also need to capture the environment in which the code was evaluated.</p>

<p>There is a big potential downside: because you&#39;ve captured that environment and saved it in an object, that environment will hang around and any objects in the environment will also hang around. That can have big implications for memory use.  For example, in the following code, the big <code>x</code> and <code>y</code> objects will be captured in memory.</p>

<div class="chunk" id="unnamed-chunk-473"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() {
  x <- runif(1e7)
  y <- runif(1e7)

  lm(mpg ~ wt, data = mtcars)
}
mod <- f()
object.size(environment(mod$terms)$x)
</pre></div>

<div class="output"><pre class="knitr r">## 80000040 bytes
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li>Create a version of lm that doesn&#39;t do any special evaluation: all arguments should be quoted expressions, and it should construct a call to <code>lm</code> that preserves all information.</li>
</ul>

<h2>Creating a function</h2>

<p>There&#39;s one function call that&#39;s so special it&#39;s worth devoting a little extra attention to: the <code>function</code> function that creates functions. This is one place we&#39;ll see pairlists (the object type that predated lists in R&#39;s history).  The arguments of a function are stored as a pairlist: for our purposes we can treat a pairlist like a list, but we need to remember to cast arguments with <code>as.pairlist()</code>.</p>

<div class="chunk" id="unnamed-chunk-474"><div class="rcode"><div class="source"><pre class="knitr r">str(quote(function(x, y = 1) x + y)[[2]])
</pre></div>

<div class="output"><pre class="knitr r">## Dotted pair list of 2
##  $ x: symbol 
##  $ y: num 1
</pre></div>

<p></div></div></p>

<p>Building up a function by hand is also useful when you can&#39;t use a closure because you don&#39;t know in advance what the arguments will be. We&#39;ll use <code>pryr::make_function</code> to build up a function from its component pieces: an argument list, a quoted body (the code to run) and the environment in which it is defined (which defaults to the.current environment). The function itself is fairly simple: it creates a call to <code>function</code> with the args and body as arguments, and then evaluates that in the correct environment so that the function has the right scope.</p>

<div class="chunk" id="unnamed-chunk-475"><div class="rcode"><div class="source"><pre class="knitr r">make_function <- function(args, body, env = parent.frame()) {
  args <- as.pairlist(args)

  eval(call("function", args, body), env)
}
</pre></div>

<p></div></div></p>

<p>(<code>pryr::make_function()</code> includes a little more error checking but is otherwise identical.)</p>

<p>Let&#39;s see a simple example</p>

<div class="chunk" id="unnamed-chunk-476"><div class="rcode"><div class="source"><pre class="knitr r">add <- make_function(alist(a = 1, b = 2), quote(a + b))
add(1)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<div class="source"><pre class="knitr r">add(1, 2)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 3
</pre></div>

<p></div></div></p>

<p>Note our use of the <code>alist()</code> (<strong>a</strong>rgument list) function.  We used this earlier when capturing unevaluated <code>...</code>, and we use it again here. Note that <code>alist()</code> doesn&#39;t evaluate its arguments and supports arguments with and without defaults (although if you don&#39;t want a default you need to be explicit). There&#39;s one small trick if you want to have <code>...</code> in the argument list: you need to use it on the left-hand side of an equals sign.</p>

<div class="chunk" id="unnamed-chunk-477"><div class="rcode"><div class="source"><pre class="knitr r">make_function(alist(a = , b = a), quote(a + b))
</pre></div>

<div class="output"><pre class="knitr r">## function (a, b = a) 
## a + b
</pre></div>

<div class="source"><pre class="knitr r">make_function(alist(a = , b = ), quote(a + b))
</pre></div>

<div class="output"><pre class="knitr r">## function (a, b) 
## a + b
</pre></div>

<div class="source"><pre class="knitr r">make_function(alist(a = , b = , ... =), quote(a + b))
</pre></div>

<div class="output"><pre class="knitr r">## function (a, b, ...) 
## a + b
</pre></div>

<p></div></div></p>

<p>If you want to mix evaluated and unevaluated arguments, it might be easier to make the list by hand:</p>

<div class="chunk" id="unnamed-chunk-478"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1
args <- list()
args$a <- x
args$b <- quote(expr = )

make_function(args, quote(a + b))
</pre></div>

<div class="output"><pre class="knitr r">## function (a = 0.153161255875602, b) 
## a + b
</pre></div>

<p></div></div></p>

<h3>Unenclose</h3>

<p>Most of the time it&#39;s simpler to use closures to create new functions, but <code>make_function()</code> is useful if we want to make it obvious to the user what the function does (printing out a closure isn&#39;t usually that helpful because all the variables are present by name, not by value).</p>

<p>We could use <code>make_function()</code> to create an <code>unenclose()</code> function that takes a closure and modifies it so when you look at the source you can see what&#39;s going on: </p>

<div class="chunk" id="unnamed-chunk-479"><div class="rcode"><div class="source"><pre class="knitr r">unenclose <- function(f) {
  env <- environment(f)
  new_body <- substitute2(body(f), env)
  make_function(formals(f), new_body, parent.env(env))
}

f <- function(x) {
  function(y) x + y
}
f(1)
</pre></div>

<div class="output"><pre class="knitr r">## function(y) x + y
## <environment: 0x1de608f8>
</pre></div>

<div class="source"><pre class="knitr r">unenclose(f(1))
</pre></div>

<div class="output"><pre class="knitr r">## function (y) 
## 1 + y
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>Why does <code>unenclose()</code> use <code>substitute2()</code>, not <code>substitute()</code>?</p></li>
<li><p>Modify <code>unenclose</code> so it only substitutes in atomic vectors, not more complicated objects. (Hint: think about what the parent environment should be.)</p></li>
<li><p>Read the documentation and source for <code>pryr::partial()</code> - what does it do? How does it work?</p></li>
</ul>

<h2>Walking the call tree with recursive functions</h2>

<p>We&#39;ve seen a couple of examples modifying a single call using <code>substitute()</code> or <code>modify_call()</code>. What if we want to do something more complicated, drilling down into a nested set of function calls and either extracting useful information or modifying the calls.  The <code>codetools</code> package, included in the base distribution, provides some built-in tools for automated code inspection that use these ideas:</p>

<ul>
<li><p><code>findGlobals()</code>: locates all global variables used by a function.
This can be useful if you want to check that your functions don&#39;t inadvertently rely on variables defined in their parent 
environment.</p></li>
<li><p><code>checkUsage()</code>: checks for a range of common problems including 
unused local variables, unused parameters and use of partial 
argument matching.</p></li>
</ul>

<p>In this section you&#39;ll learn how to write functions that do things like that.</p>

<p>Because code is a tree, we&#39;re going to need recursive functions to work with it. You now have basic understanding of how code in R is put together internally, and so we can now start to write some useful functions. The key to any function that works with the parse tree right is getting the recursion right, which means making sure that you know what the base case is (the leaves of the tree) and figuring out how to combine the results from the recursive case. The nodes of a tree are always calls (except in the rare case of function arguments, which are pairlists), and the leaves are names, single argument calls or constants. R provides a helpful function to distinguish whether an object is a node or a leaf: <code>is.recursive()</code>.</p>

<h3>Finding F and T</h3>

<p>We&#39;ll start with a function that returns a single logical value, indicating whether or not a function uses the logical abbreviations <code>T</code> and <code>F</code>.  Using <code>T</code> and <code>F</code> is generally considered to be poor coding practice, and it&#39;s something that <code>R CMD check</code> will warn about.</p>

<p>When writing a recursive function, it&#39;s useful to first think about the simplest case: how do we tell if a leaf is a <code>T</code> or a <code>F</code>?  This is very simple since the set of possibilities is small enough to enumerate explicitly:</p>

<div class="chunk" id="unnamed-chunk-480"><div class="rcode"><div class="source"><pre class="knitr r">is_logical_abbr <- function(x) {
  identical(x, quote(T)) || identical(x, quote(F))
}
is_logical_abbr(quote(T))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">is_logical_abbr(quote(TRUE))
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">is_logical_abbr(quote(true))
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<div class="source"><pre class="knitr r">is_logical_abbr(quote(10))
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<p>Next we write the recursive function. The base case is simple: if the object isn&#39;t recursive, then we just return the value of <code>is_logical_abbr()</code> applied to the object. If the object is not a node, then we work through each of the elements of the node in turn, recursively calling <code>logical_abbr()</code>. We need a special case for functions because we can&#39;t iterate through their components, instead we need to explicitly operate on the body and formals separately.</p>

<div class="chunk" id="unnamed-chunk-481"><div class="rcode"><div class="source"><pre class="knitr r">logical_abbr <- function(x) {
  # Base case
  if (!is.recursive(x)) return(is_logical_abbr(x))

  # Recursive cases
  if (is.function(x)) {
    if (logical_abbr(body(x))) return(TRUE)
    if (logical_abbr(formals(x))) return(TRUE)
  } else {
    for (i in seq_along(x)) {
      if (logical_abbr(x[[i]])) return(TRUE)
    }
  }

  FALSE
}

logical_abbr(quote(T))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">logical_abbr(quote(mean(x, na.rm = T)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">
f <- function(x = TRUE) {
  g(x + T)
}
logical_abbr(f)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<p></div></div></p>

<h3>Finding all variables created by assignment</h3>

<p>In this section, we will write a function that figures out all variables that are created by assignment in an expression. We&#39;ll start simply, and make the function progressively more rigorous. One reason to start with this function is because the recursion is a little bit simpler - we never need to go all the way down to the leaves because we are looking for assignment, a call to <code>&lt;-</code>.  </p>

<p>This means that our base case is simple: if we&#39;re at a leaf, we&#39;ve gone too far and can immediately return. We have two other cases: we have hit a call, in which case we should check if it&#39;s <code>&lt;-</code>, otherwise it&#39;s some other recursive structure and we should call the function recursively on each element. Note the use of <code>identical()</code> to compare the call to the name of the assignment function, and recall that the second element of a call object is the first argument, which for <code>&lt;-</code> is the left hand side: the object being assigned to.</p>

<div class="chunk" id="unnamed-chunk-482"><div class="rcode"><div class="source"><pre class="knitr r">is_call_to <- function(x, name) {
  is.call(x) && identical(x[[1]], as.name(name))
}

find_assign <- function(obj) {
  # Base case
  if (!is.recursive(obj)) return()

  if (is_call_to(obj, "<-")) {
    obj[[2]]
  } else {
    lapply(obj, find_assign)
  }
}
find_assign(quote(a <- 1))
</pre></div>

<div class="output"><pre class="knitr r">## a
</pre></div>

<div class="source"><pre class="knitr r">find_assign(quote({
  a <- 1
  b <- 2
}))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## NULL
## 
## [[2]]
## a
## 
## [[3]]
## b
</pre></div>

<p></div></div></p>

<p>This function seems to work for these simple cases, but the output is rather verbose. Instead of returning a list, let&#39;s keep it simple and stick with a character vector. We&#39;ll also test it with two slightly more complicated examples:</p>

<div class="chunk" id="unnamed-chunk-483"><div class="rcode"><div class="source"><pre class="knitr r">find_assign <- function(obj) {
  # Base case
  if (!is.recursive(obj)) return(character())

  if (is_call_to(obj, "<-")) {
    as.character(obj[[2]])
  } else {
    unlist(lapply(obj, find_assign))
  }
}
find_assign(quote({
  a <- 1
  b <- 2
  a <- 3
}))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b" "a"
</pre></div>

<div class="source"><pre class="knitr r">
find_assign(quote({
  system.time(x <- print(y <- 5))
}))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<p></div></div></p>

<p>This is better, but we have two problems: repeated names, and we miss assignments inside function calls. The fix for the first problem is easy: we need to wrap <code>unique()</code> around the recursive case to remove duplicate assignments. The second problem is a bit more subtle: it&#39;s possible to do assignment within the arguments to a call, but we&#39;re failing to recurse down in to this case. </p>

<div class="chunk" id="unnamed-chunk-484"><div class="rcode"><div class="source"><pre class="knitr r">find_assign <- function(obj) {
  # Base case
  if (!is.recursive(obj)) return(character())

  if (is_call_to(obj, "<-")) {
    call <- as.character(obj[[2]])
    c(call, unlist(lapply(obj[[3]], find_assign)))
  } else {
    unique(unlist(lapply(obj, find_assign)))
  }
}
find_assign(quote({
  a <- 1
  b <- 2
  a <- 3
}))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b"
</pre></div>

<div class="source"><pre class="knitr r">
find_assign(quote({
  system.time(x <- print(y <- 5))
}))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x" "y"
</pre></div>

<p></div></div></p>

<p>There&#39;s one more case we need to test:</p>

<div class="chunk" id="unnamed-chunk-485"><div class="rcode"><div class="source"><pre class="knitr r">find_assign(quote({
  ls <- list()
  ls$a <- 5
  names(ls) <- "b"
}))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "ls"    "$"     "a"     "names"
</pre></div>

<div class="source"><pre class="knitr r">
draw_tree(quote({
  ls <- list()
  ls$a <- 5
  names(ls) <- "b"
}))
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "draw_tree"
</pre></div>

<p></div></div></p>

<p>This behaviour might be ok, but we probably just want assignment into whole objects, not assignment that modifies some property of the object. Drawing the tree for that quoted object helps us see what condition we should test for - we want the object on the left hand side of assignment to be a name.  This gives the final version of the <code>find_assign</code> function.</p>

<div class="chunk" id="unnamed-chunk-486"><div class="rcode"><div class="source"><pre class="knitr r">find_assign <- function(obj) {
  # Base case
  if (!is.recursive(obj)) return(character())

  if (is_call_to(obj, "<-")) {
    call <- if (is.name(obj[[2]])) as.character(obj[[2]])
    c(call, unlist(lapply(obj[[3]], find_assign)))
  } else {
    unique(unlist(lapply(obj, find_assign)))
  }
}
find_assign(quote({
  ls <- list()
  ls$a <- 5
  names(ls) <- "b"
}))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "ls"
</pre></div>

<p></div></div></p>

<p>Making this function work absolutely correct requires quite a lot more work, because we need to figure out all the other ways that assignment might happen: with <code>=</code>, <code>assign()</code>, or <code>delayedAssign()</code>. But a static tool can never be perfect: the best you can hope for is a set of heuristics that catches the most common 90% of cases. </p>

<h3>Modifying the call tree</h3>

<p>Instead of returning vectors computed from the contents of an expression, you can also return a modified expression, such as base R&#39;s <code>bquote()</code>. <code>bquote()</code> is a slightly more flexible form of quote: it allows you to optionally quote and unquote some parts of an expression (it&#39;s similar to the backtick operator in lisp).  Everything is quoted, <em>unless</em> it&#39;s encapsulated in <code>.()</code> in which case it&#39;s evaluated and the result is inserted.</p>

<div class="chunk" id="unnamed-chunk-487"><div class="rcode"><div class="source"><pre class="knitr r">a <- 1
b <- 3
bquote(a + b)
</pre></div>

<div class="output"><pre class="knitr r">## a + b
</pre></div>

<div class="source"><pre class="knitr r">bquote(a + .(b))
</pre></div>

<div class="output"><pre class="knitr r">## a + 3
</pre></div>

<div class="source"><pre class="knitr r">bquote(.(a) + .(b))
</pre></div>

<div class="output"><pre class="knitr r">## 1 + 3
</pre></div>

<div class="source"><pre class="knitr r">bquote(.(a + b))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<p></div></div></p>

<p>This provides a fairly easy way to control what gets evaluated when you call <code>bquote()</code>, and what gets evaluated when the expression is evaluated. How does <code>bquote()</code> work? Below, I&#39;ve rewritten <code>bquote()</code> to use the same style as our other functions: it expects input to be quoted already, and makes the base and recursive cases more explicit:</p>

<div class="chunk" id="unnamed-chunk-488"><div class="rcode"><div class="source"><pre class="knitr r">bquote2 <- function (x, where = parent.frame()) {
  # Base case
  if (!is.recursive(x)) return(x)

  if (is.call(x)) {
    if (identical(x[[1]], quote(.))) {
      # Call to .(), so evaluate
      eval(x[[2]], where)
    } else {
      as.call(lapply(x, bquote2, where = where))
    }
  } else if (is.pairlist(x)) {
    as.pairlist(lapply(x, bquote2, where = where))
  } else {
    stop("Unknown case")
  }
}
x <- 1
bquote2(quote(x == .(x)))
</pre></div>

<div class="output"><pre class="knitr r">## x == 0.273047293536365
</pre></div>

<div class="source"><pre class="knitr r">y <- 2
bquote2(quote(function(x = .(x)) {
  x + .(y)
}))
</pre></div>

<div class="output"><pre class="knitr r">## function(x = 0.582059757318348) {
##     x + 2
## }
</pre></div>

<p></div></div></p>

<p>Note that functions that modify the source tree are most useful for creating expressions that are used at run-time, not saved back into the original source file.  That&#39;s because all non-code information is lost:</p>

<div class="chunk" id="unnamed-chunk-489"><div class="rcode"><div class="source"><pre class="knitr r">bquote2(quote(function(x = .(x)) {
  # This is a comment
  x +  # funky spacing
    .(y)
}))
</pre></div>

<div class="output"><pre class="knitr r">## function(x = 0.0720272283069789) {
##     x + 2
## }
</pre></div>

<p></div></div></p>

<p>It is possible to work around this problem using <code>srcrefs</code> and <code>getParseData</code>, but neither solution naturally fits this hierarchical framework. You effectively end up having to recreate huge chunks of R&#39;s internal code in order to handle the majority of R code.  So the above approach can be useful in simple cases (particularly when you don&#39;t care what the output code looks like), but it&#39;s very hard to automatically transform R code, and is beyond the scope of this book.</p>

<p><code>bquote()</code> is rather like a macro from a languages like LISP. But unlike macros the modifications occur at runtime, not compile time (which doesn&#39;t have any meaning in R). And unlike a macro there is no restriction to return an expression: a macro-like function in R can return anything. More like <code>fexprs</code>. a fexpr is like a function where the arguments aren&#39;t evaluated by default; or a macro where the result is a value, not code. </p>

<p><a href="http://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf#page=11">Programmer’s Niche: Macros in R</a> by Thomas Lumley.</p>

<h3>Exercises</h3>

<ul>
<li>Write a function that extracts all calls to a function. Compare your function to <code>pryr::fun_calls()</code>.</li>
</ul>

<h2>Formulas</h2>

<!-- 
methods(class = "formula")
-->

<p>There is one other important tool of non-standard evaluation: the formula. The formula operator, <code>~</code>, is used extensively by modelling functions, but also by some graphics functions (e.g. lattice and <code>plot</code>) and a few data manipulation functions (e.g. <code>xtabs()</code> and <code>aggregate()</code>).</p>

<h2>Formula as a quoting function</h2>

<p>There are two advantages for using <code>~</code> over <code>quote()</code>:</p>

<ul>
<li>It is shorter</li>
<li>It captures both the expression and the environment in which it was evaluated</li>
</ul>

<p>The disadvantage of using <code>~</code> is that most people are used to its role in models, and may be surprised in the semantics you imply from it are substantially different from standard modelling formulas.   </p>

<p>The formula object is a call that knows in which environment it was evaluated. You can use <code>length()</code> to determine if it is one-sided or two-sided, and <code>[[</code> to extract the various pieces.</p>

<pre><code class="R">f1 &lt;- ~ a + b
length(f1)
f1[[1]]
f1[[2]]

f2 &lt;- y ~ a + b
length(f2)
f2[[1]]
f2[[2]]
f2[[3]]
</code></pre>

<p>You can extract the environment of a formula with <code>environment()</code>, as demonstrated with this implementation of <code>subset()</code>:</p>

<pre><code class="R">subset_f &lt;- function(x, f) {
  stopifnot(inherits(f, &quot;formula&quot;), length(f) == 2)
  r &lt;- eval(f[[2]], x, environment(f))
  x[r, ]
}
subset_f(mtcars, ~ cyl == 4)
</code></pre>

<p>Note that because the code is evaluated in the environment associated with the formula, the semantics are a little different if you&#39;re creating the formula in a function:</p>

<pre><code class="R">f &lt;- function(x) ~ cyl == x
subset_f(mtcars, f(4))
</code></pre>

<h3><code>xtabs()</code></h3>

<p>Is a pretty horrible example because of it&#39;s combination of call mangling and tangles with sparse matrices.</p>

<h2>Formulas for modelling</h2>

<p>Keep it brief: focus on main concepts (possibly showing complete lm implmentation using Rcpp), and pointing to documentation where necessary.  Need to discuss specials (e.g. offset/Error) and how splines work?</p>

<p>White book.</p>

<p>Patsy: <a href="http://patsy.readthedocs.org/en/latest/R-comparison.html">http://patsy.readthedocs.org/en/latest/R-comparison.html</a></p>

<p>Formula package (<a href="http://cran.r-project.org/web/packages/Formula/vignettes/Formula.pdf">http://cran.r-project.org/web/packages/Formula/vignettes/Formula.pdf</a>)</p>

<p>Models use two steps: first converting the formula into matrices, and then manipulating using matrix algebra.</p>

<ul>
<li><p>RcppEigen:::fastLm.formula</p></li>
<li><p><a href="http://developer.r-project.org/model-fitting-functions.txt">http://developer.r-project.org/model-fitting-functions.txt</a></p></li>
<li><p>terms, terms.object, terms.formula</p></li>
<li><p>model.response, model.weights</p></li>
<li><p>model.matrix, model.frame</p></li>
<li><p>lm.fit</p></li>
</ul>

<h1>Special contexts</h1>

<p>R&#39;s lexical scoping rules, lazy argument evaluation and first-class environments make it an excellent environment for designing special environments that allow you to create domain specific languages (DSLs). This chapter shows how you can use these ideas to evaluate code in special contexts that pervert the usual behaviour of R.  We&#39;ll start with simple modifications then work our way up to evaluations that completely redefine ordinary function semantics in R.</p>

<p>This chapter uses ideas from the breadth of the book including non-standard evaluation, environment manipulation, active bindings, ...</p>

<ul>
<li><p>Evaluate code in a special context: <code>local</code>, <code>capture.output</code>, <code>with_*</code></p></li>
<li><p>Supply an expression instead of a function: <code>curve</code> </p></li>
<li><p>Combine evaluation with extra processing: <code>test_that</code>, <code>assert_that</code></p></li>
<li><p>Create a full-blown DSL: <code>html</code>, <code>plotmath</code>, <code>deriv</code>, <code>parseNamespace</code>, <code>sql</code></p></li>
</ul>

<h2>Evaluate code in a special context</h2>

<p>It&#39;s often useful to evaluate a chunk of code in a special context</p>

<ul>
<li><p>Temporarily modifying global state, like the working directory, environment variables, plot options or locale.</p></li>
<li><p>Capture side-effects of a function, like the text it prints, or the warnings it emits</p></li>
<li><p>Evaluate code in a new environment</p></li>
</ul>

<h3><code>with_something</code></h3>

<p>There are a number of parameters in R that have global state (e.g. <code>option()</code>, environmental variables, <code>par()</code>, ...) and it&#39;s useful to be able to run code temporarily in a different context.  For example, it&#39;s often useful to be able to run code with the working directory temporarily set to a new location:</p>

<pre><code class="R">in_dir &lt;- function(dir, code) {
  old &lt;- setwd(dir)
  on.exit(setwd(old))

  force(code)
}
getwd()
in_dir(&quot;~&quot;, getwd())
</code></pre>

<p>The basic pattern is simple:</p>

<ul>
<li><p>We first set the directory to a new location, capturing the current location from the output of <code>setwd</code>.</p></li>
<li><p>We then use <code>on.exit()</code> to ensure that the working directory is returned to the previous value regardless of how the function exits.</p></li>
<li><p>Finally, we explicitly force evaluation of the code. (We don&#39;t actually need <code>force()</code> here, but it makes it clear to readers what we&#39;re doing)</p></li>
</ul>

<p>We could use similar code to temporarily set global options:</p>

<pre><code class="R">with_options &lt;- function(opts, code) {
  old &lt;- options(opts)
  on.exit(options(old))

  force(code)
}
x &lt;- 0.123456
print(x)
with_options(list(digits = 3), print(x))
with_options(list(digits = 1), print(x))
</code></pre>

<p>You might notice that there&#39;s a lot of similarity between these two functions. We could extract out that commonality with a function operator that takes the setter function as an input:</p>

<pre><code class="R">with_something &lt;- function(set) {
  function(new, code) {
    old &lt;- set(new)
    on.exit(set(old))
    force(code)
  }
}
</code></pre>

<p>Then we can easily generate a whole set of with functions:</p>

<pre><code class="R">in_dir &lt;- with_something(setwd)
with_options &lt;- with_something(options)
with_par &lt;- with_something(par)
</code></pre>

<p>However, many of the setter functions that affect global state in R don&#39;t return the previous values in a way that can easily be passed back in.  In that case, like for <code>.libPaths()</code>, which controls where R looks for packages to load, we first create a wrapper that enforces the behaviour we want, and then use <code>with_something()</code>: </p>

<pre><code class="R">set_libpaths &lt;- function(paths) {
  libpath &lt;- normalizePath(paths, mustWork = TRUE)

  old &lt;- .libPaths()
  .libPaths(paths)
  invisible(old)
}
with_libpaths &lt;- with_something(set_libpaths)
</code></pre>

<p>These functions (and a few others) are provided by the devtools package. See <code>?with_something</code> for more details.</p>

<h3><code>capture.output</code></h3>

<p><code>capture.output()</code> is a useful function when the output you really want from a function is printed to the console. It also allows you to work around badly written functions that have no way to suppress output to the console.  For example, it&#39;s difficult to capture the output of <code>str()</code>:</p>

<pre><code class="R">y &lt;- 1:10
y_str &lt;- str(y)
y_str

y_str &lt;- capture.output(str(y))
y_str
</code></pre>

<p>To work its magic, <code>capture.output()</code> uses <code>sink()</code>, which allows you to redirect the output stream to an arbitrary connection. We&#39;ll first write a helper function that allows us to execute code in the context of a <code>sink()</code>, automatically un-<code>sink()</code>ing when the function finishes:</p>

<pre><code>with_sink &lt;- function(connection, code, ...) {
  sink(connection, ...)
  on.exit(sink())

  code
}
with_sink(&quot;temp.txt&quot;, print(&quot;Hello&quot;))
readLines(&quot;temp.txt&quot;)
</code></pre>

<p>With this in hand, we just need to add a little extra wrapping to our <code>capture.output2()</code> to write to a temporary file, read from it and clean up after ourselves:</p>

<pre><code class="R">capture.output2 &lt;- function(code) {
  temp &lt;- tempfile()
  on.exit(file.remove(temp))

  with_sink(temp, force(code))
  readLines(temp)
}
capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\n&quot;))
</code></pre>

<p>The real <code>capture.output()</code> is a bit more complicated: it uses a local <code>textConnection</code> to capture the data sent to sink, and it allows you to supply multiple expressions which are evaluated in turn. Using <code>with_sink()</code> this looks like <code>capture.output3()</code></p>

<pre><code class="R">capture.output3 &lt;- function(..., env = parent.frame()) {
  txtcon &lt;- textConnection(&quot;rval&quot;, &quot;w&quot;, local = TRUE)

  with_sink(txtcon, {
    args &lt;- dots(...)
    for(i in seq_along(args)) {
      out &lt;- withVisible(eval(args[[i]], env))
      if (out$visible) print(out$value)
    }
  })

  rval
}
</code></pre>

<p>You might want to compare this function to the real <code>capture.output()</code> and think about the simplifications I&#39;ve made. Is the code easier to understand or harder? Have I removed important functionality? </p>

<p>If you want to capture more types of output (like messages and warnings), you may find the <code>evaluate</code> package helpful. It powers <code>knitr</code>, and does it&#39;s best to ensure high fidelity between its output and what you&#39;d see if you copy and pasted the code at the console.</p>

<h3>Evaluating code in a new environment</h3>

<p>In the process of performing a data analysis, you may create variables that are necessarily because they help break a complicated sequence of steps down in to easily digestible chunks, but are not needed afterwards. For example, in the following example, we might only want to keep the value of c:</p>

<pre><code class="R">a &lt;- 10
b &lt;- 30
c &lt;- a + b
</code></pre>

<p>It&#39;s useful to be able to store only the final result, preventing the intermediate results from cluttering your workspace.  We already know one way of doing this, using a function:</p>

<pre><code class="R">c &lt;- (function() {
  a &lt;- 10
  b &lt;- 30
  a + b
})()
</code></pre>

<p>(In javascript this is called the immediately invoked function expression (IIFE), and is used extensively in modern javascript to encapsulate different javascript libraries)</p>

<p>R provides another tool that&#39;s a little less verbose, the <code>local()</code> function:</p>

<pre><code class="R">c &lt;- local({
  a &lt;- 10
  b &lt;- 30
  a + b
})
</code></pre>

<p>The idea of local is to create a new environment (inheriting from the current environment) and run the code in that.  The essence of <code>local()</code> is captured in this code:</p>

<pre><code class="R">local2 &lt;- function(expr) {
  envir &lt;- new.env(parent = parent.frame())
  eval(substitute(expr), envir)  
}
</code></pre>

<p>The real <code>local()</code> code is considerably more complicated because it adds a second environment parameter. I don&#39;t think this is necessary because if you have an explicit environment parameter, then you can already evaluate code in that environment with <code>evalq()</code>. The original code is also hard to understand because it is very concise and uses some sutble features of evaluation (including non-standard evaluation of both arguments). If you have read [[computing-on-the-language]], you might be able to puzzle it out, but to make it a bit easier I have rewritten it in a simpler style below. </p>

<pre><code class="R">local2 &lt;- function(expr, envir = new.env()) {
  env &lt;- parent.frame()
  call &lt;- substitute(eval(quote(expr), envir))

  eval(call, env)
}
a &lt;- 100
local2({
  b &lt;- a + sample(10, 1)
  my_get &lt;&lt;- function() b
})
my_get()
</code></pre>

<p>You might wonder we can&#39;t simplify to this:</p>

<pre><code class="R">local3 &lt;- function(expr, envir = new.env()) {
  eval(substitute(expr), envir)
}
</code></pre>

<p>But it&#39;s because of how the arguments are evaluated - default arguments are evalauted in the scope of the function so that <code>local(x)</code> would not the same as <code>local(x, new.env())</code> without special effort. </p>

<h3>Exercises</h3>

<ul>
<li><p>Compare <code>capture.output()</code> to <code>capture.output2()</code> and <code>local()</code> to <code>local2()</code>. How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas to be easier to understand?</p></li>
<li><p>How does the <code>chdir</code> parameter of <code>source()</code> compare to <code>in_dir()</code>? Why might you prefer one approach to the other?</p></li>
</ul>

<h2>Anaphoric functions</h2>

<p>Another variant along these lines is an &quot;<a href="http://en.wikipedia.org/wiki/Anaphora_(linguistics">anaphoric</a>) function&quot;, or a function that uses a pronoun. This is easiest to understand with an example using an interesting anaphoric function in base R: <code>curve()</code>.<code>curve()</code> draws a plot of the specified function, but interestingly you don&#39;t need to use a function, you just supply an expression that uses <code>x</code>:</p>

<pre><code class="R">curve(x ^ 2)
curve(sin(x), to = 3 * pi)
curve(sin(exp(4 * x)), n = 1000)
</code></pre>

<p>Here <code>x</code> plays a role like a pronoun in an English sentence: it doesn&#39;t represent a single concrete value, but instead is a place holder that varies over the range of the plot. Note that it doesn&#39;t matter what the value of <code>x</code> outside of <code>curve()</code> is: the expression is evaluated in a special environment where <code>x</code> has a special meaning:</p>

<pre><code class="R">x &lt;- 1
curve(sin(exp(4 * x)), n = 1000)
</code></pre>

<p><code>curve()</code> works by evaluating the expression in a special environment in which the appropriate <code>x</code> exists. The essence of <code>curve()</code>, omitting many useful but incidental details like plot labelling, looks like this:</p>

<pre><code class="R">curve2 &lt;- function(expr, xlim = c(0, 1), n = 100, env = parent.frame()) {
  env2 &lt;- new.env(parent = env)
  env$x &lt;- seq(xlim[1], xlim[2], length = n)

  y &lt;- eval(expr, env2)
  plot(x, y, type = &quot;l&quot;, ylab = deparse(substitute(expr)))
}
curve2(sin(exp(4 * x)), n = 1000)
</code></pre>

<p>Creating a new environment containing the pronoun is the key technique for implementing anaphoric functions.</p>

<p>Another way to solve the problem would be to turn the expression into a function using <code>make_function()</code>:</p>

<pre><code class="R">curve3 &lt;- function(expr, xlim, n = 100, env = parent.frame()) {
  f &lt;- make_function(alist(x = ), substitute(expr), env)

  x &lt;- seq(xlim[1], xlim[2], length = n)
  y &lt;- f(x)

  plot(x, y, type = &quot;l&quot;, ylab = deparse(substitute(expr)))
}
curve3(sin(exp(4 * x)), n = 1000)
</code></pre>

<p>The approaches take about as much code, and require knowledge of  the same number of fundamental R concepts. I would have a slight preference for the second because it would be easier to reuse the part of the <code>curve3()</code> that turns an expression into a function. All anaphoric functions need careful documentation so that the user knows that some variable will have special properties inside the anaphoric function and must otherwise be avoided. </p>

<p>If you&#39;re interesting in learning more, there are some good resources for anaphoric functions in  <a href="http://www.arcfn.com/doc/anaphoric.html">arc</a> (a list like language), <a href="http://www.perlmonks.org/index.pl?node_id=666047">perl</a> and <a href="http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit">clojure</a></p>

<h3>With connection</h3>

<p>We could use this idea to create a function that allows you to use a connection, automatically openning and closing it if needed. This is a common technique in ruby, which uses its block syntax whenever you deal with resources that need to be closed after you&#39;re done with them.  We can&#39;t use the same implementation as the with functions above because an implementation like that below gives no way for the code to refer to the connection:</p>

<pre><code class="R">with_conn &lt;- function(conn, code) {
  open(conn)
  on.exit(close(conn))

  force(code)
}
</code></pre>

<p>We can work around this problem by using an anaphoric function, referring to the connection as <code>.it</code>. We&#39;d need to clearly document that convention so the user knew what to call it.</p>

<pre><code class="R">with_conn &lt;- function(conn, code, env = parent.frame()) {
  if (!isOpen(conn)) {
    open(conn)
    on.exit(close(conn))
  }

  env2 &lt;- new.env(parent = env)
  env$.it &lt;- conn

  eval(substitute(code), env)
}

# Create a new file, and then read it in in pieces of length 6
with_conn(file(&quot;test.txt&quot;, &quot;w+&quot;), {
  writeLines(&quot;This is a test&quot;, .it)
  x &lt;- readChar(.it, 6)

  while(length(x) &gt; 0) {
    print(x)
    x &lt;- readChar(.it, 6)
  }
})
</code></pre>

<p>The construction of this function also has the appealing side-effect that the scope of the connection is clearly shown with indenting.</p>

<h2>Special environments for run-time checking</h2>

<p>We can take the idea of special evaluation contexts and use the idea to implement run-time checks, by executing code in a special environment that warns or errors when the user does something that we think is a bad idea.</p>

<ul>
<li>Checking for logical abbreviations</li>
</ul>

<h3>Logical abbreviations</h3>

<p>One of the checks that <code>R CMD check</code> runs ensures that you don&#39;t use the logical abbreviations <code>T</code> and <code>F</code>. It&#39;s a useful check, but a bit frustrating to use because it terminates on the first <code>F</code> or <code>T</code> it finds, so you need to run it many times, but <code>R CMD check</code> is slow. Instead, we can take the idea that underlies the check and run it ourselves, which makes it faster to iterate.</p>

<p>The basic idea is to use an active binding so that whenever code tries to access <code>F</code> or <code>T</code> it throws an error.  This is a very similar technique to anaphoric functions:</p>

<pre><code class="R">check_logical_abbr &lt;- function(code, env = parent.frame()) {
  new_env &lt;- new.env(parent = env)
  delayedAssign(&quot;T&quot;, stop(&quot;Use TRUE not T&quot;), assign.env = new_env)
  delayedAssign(&quot;F&quot;, stop(&quot;Use FALSE not F&quot;), assign.env = new_env)

  eval(substitute(code), new_env)
}

check_logical_abbr(c(FALSE, T, FALSE))
</code></pre>

<p>Note that functions look in the environment in which they were defined so to test large bodies of code, you&#39;ll need to run <code>check_logical_abbr()</code> as far as out as possible:</p>

<pre><code class="R">f &lt;- function(x) {
  mean(x, na.rm = T)
}
check_logical_abbr(f(1:10))

check_logical_abbr({
  f &lt;- function(x) {
    mean(x, na.rm = T)
  }
  f(1:10)
})
</code></pre>

<p>This will be typically easiest to do as a wrapper around the code you use to load your code into R:</p>

<pre><code class="R">check_logical_abbr(source(&quot;my-file.r&quot;))
check_logical_abbr(load_all())
</code></pre>

<h3>Test that</h3>

<p>Manage global state accessible from functions. Use special environment.</p>

<p>Create with function that uses <code>on.exit()</code> to push and pop from stack.</p>

<pre><code class="R">testthat_env &lt;- new.env()
testthat_env$reporter &lt;- StopReporter$new()

set_reporter &lt;&lt;- function(value) {
  old &lt;- testthat_env$reporter
  testthat_env$reporter &lt;- value
  old
}
get_reporter &lt;&lt;- function() {
  testthat_env$reporter
}
</code></pre>

<pre><code class="R">with_reporter &lt;- function(reporter, code) {
  reporter &lt;- find_reporter(reporter)

  old &lt;- set_reporter(reporter)
  on.exit(set_reporter(old))

  reporter$start_reporter()
  res &lt;- force(code)
  reporter$end_reporter()

  res
}
</code></pre>

<h1>Domain specific languages</h1>

<p>The combination of first class environments and lexical scoping gives us a powerful toolkit for creating embedded domain specific languages (DSLs) in R. Embedded DSLs take advantage of a host language&#39;s parsing and execution framework, but adjust the semantics somewhat to make them more suitable for a specific task. </p>

<p>R already has a simple and popular DSL built in: the formula specification, which offers a succinct way of describing the relationship between predictors and the response. Other examples of DSLs include ggplot2 (for visualisation), and plyr (for data manipulation). Another package that makes extensive use of these ideas is dplyr, which provides <code>to_sql()</code> to converts R expressions into SQL:</p>

<div class="chunk" id="unnamed-chunk-490"><div class="rcode"><div class="source"><pre class="knitr r">library(dplyr)
to_sql(sin(x) + tan(y))
</pre></div>

<div class="output"><pre class="knitr r">## <SQL> SIN(x) + TAN(y)
</pre></div>

<div class="source"><pre class="knitr r">to_sql(x < 5 & !(y >= 5))
</pre></div>

<div class="output"><pre class="knitr r">## <SQL> x < 5.0 AND NOT((y >= 5.0))
</pre></div>

<div class="source"><pre class="knitr r">to_sql(first %like% "Had*")
</pre></div>

<div class="output"><pre class="knitr r">## <SQL> first LIKE 'Had*'
</pre></div>

<div class="source"><pre class="knitr r">to_sql(first %in% c("John", "Roger", "Robert"))
</pre></div>

<div class="output"><pre class="knitr r">## <SQL> first IN ('John', 'Roger', 'Robert')
</pre></div>

<div class="source"><pre class="knitr r">to_sql(like == 7)
</pre></div>

<div class="output"><pre class="knitr r">## <SQL> "like" = 7.0
</pre></div>

<p></div></div></p>

<p>Once you have read this chapter, you might want to study the source code for dplyr. An important part of the overall structure of the package is <code>partial_eval()</code> which helps manage expressions where some of the components refer to variables in the database and some refer to local R objects. You could use very similar ideas if you needed to translate small R expressions into other languages, like javascript or python. Converting complete R programs would be extremely difficult, but often being able to communicate a simple description of computation between languages is very useful.</p>

<p>R is well suited for hosting DSLs because the combination of a small amount of computing on the language and constructing special evaluation environments is very powerful. Creating new DSLs in R uses many techniques that you&#39;ve learned about elsewhere in the book, including:</p>

<ul>
<li>scoping rules</li>
<li>creating and manipulating functions</li>
<li>computing on the language</li>
<li>S3 basics</li>
</ul>

<p>This chapter will develop two simple, but useful, DSLs, one for generating HTML, and one for turning R mathematical expressions into a form suitable for inclusion in latex. </p>

<p>DSLs are a very large topic, and this chapter will only scratch the surface, focussing on important techniques and not so much on how you might come up with the language in the first place. If you&#39;re interested in learning more, I highly recommend <a href="http://amzn.com/0321712943?tag=devtools-20">Domain Specific Languages</a> by Martin Fowler: it discusses many options for creating a DSL and provides many examples of different languages.</p>

<h2>HTML</h2>

<p>HTML is the language that underlies the majority of the web. It is a special case of SGML, and similar (but not identical) to XML. HTML looks like this:</p>

<pre><code class="html">&lt;body&gt;
  &lt;h1 id=&#39;first&#39;&gt;A heading&lt;/h1&gt;
  &lt;p&gt;Some text &amp;amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;
  &lt;img src=&#39;myimg.png&#39; width=&#39;100&#39; height=&#39;100&#39; /&gt;
&lt;/body&gt;
</code></pre>

<p>Even if you&#39;ve never seen HTML before, hopefully you can see the key component of the structure: HTML is composed of tags that look like <code>&lt;tag&gt;&lt;/tag&gt;</code>. Tags can be contained inside other tags and intermingled with text. Generally, HTML ignores whitespace: an sequence of whitespace is equivalent to a single space. You could put the previous example all on online and it would still display the same in the browser:</p>

<pre><code class="html">&lt;body&gt;&lt;h1 id=&#39;first&#39;&gt;A heading&lt;/h1&gt;&lt;p&gt;Some text &amp;amp; &lt;b&gt;some bold
text.&lt;/b&gt;&lt;/p&gt;&lt;img src=&#39;myimg.png&#39; width=&#39;100&#39; height=&#39;100&#39; /&gt;
&lt;/body&gt;
</code></pre>

<p>However, like R code, you usually want to indent HTML to make it more obvious to see the structure.</p>

<p>There are over 100 HTML tags, but to illustrate HTML we&#39;re going to focus on just a few:</p>

<ul>
<li><code>&lt;body&gt;</code>: the top-level tag that all content is enclosed within</li>
<li><code>&lt;h1&gt;</code>: creates a heading-1, the top level heading</li>
<li><code>&lt;p&gt;</code>: creates a paragraph</li>
<li><code>&lt;b&gt;</code>: emboldens text</li>
<li><code>&lt;img&gt;</code>: embeds an image</li>
</ul>

<p>(you probably guessed what these did already!)</p>

<p>Tags can also have named attributes that look like <code>&lt;tag a=&quot;a&quot; b=&quot;b&quot;&gt;&lt;/tags&gt;</code>. Tag values should always be enclosed in either single or double quotes. Two important attributes used on just about every tag are <code>id</code> and <code>class</code>. These are used in conjunction with CSS (cascading style sheets) in order to control the style of the document.</p>

<p>Some tags, like <code>&lt;img&gt;</code>, can&#39;t have any content. These are called <strong>void tags</strong> and have a slightly different syntax: instead of writing <code>&lt;img&gt;&lt;/img&gt;</code> you write <code>&lt;img /&gt;</code>. Since they have no content, attributes are more imporant, and <code>img</code> has three that are used for almost every image: <code>src</code> (where the image lives), <code>width</code> and <code>height</code>.</p>

<p>Because <code>&lt;</code> and <code>&gt;</code> have special meanings in HTML, you can&#39;t write them directly. Instead you have to use the HTML escapes <code>&amp;gt;</code> and <code>&amp;lt;</code>. And since those escapes use <code>&amp;</code>, you also have to escape it with <code>&amp;amp;</code> if you want a literal ampersand.</p>

<h3>Goal</h3>

<p>Our goal is to make it easy to generate HTML from R. To give a concrete example, we want to generate the following HTML:</p>

<pre><code class="html">&lt;body&gt;
  &lt;h1 id=&#39;first&#39;&gt;A heading&lt;/h1&gt;
  &lt;p&gt;Some text &amp;amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;
  &lt;img src=&#39;myimg.png&#39; width=&#39;100&#39; height=&#39;100&#39; /&gt;
&lt;/body&gt;
</code></pre>

<p>using code that looks as similar to the HTML as possible. We will work our way up to the following DSL:</p>

<div class="chunk" id="unnamed-chunk-491"><div class="rcode"><div class="source"><pre class="knitr r">with_html(body(
  h1("A heading", id = "first"),
  p("Some text &", b("some bold text.")),
  img(src = "myimg.png", width = 100, height = 100)
))
</pre></div>

<p></div></div></p>

<p>Note that the nesting of function calls is the same as the nesting of tags, unnamed arguments become the content of the tag, and named arguments become the attributes. Because tags and text are clearly distinct in this API, we can automatically escape <code>&amp;</code> and other special characters.</p>

<h3>Escaping</h3>

<p>Escaping is so fundamental we&#39;re going to start with it. We first start by creating a way of escaping the characters that have special meaning for HTML, while making sure we don&#39;t end up double-escaping at any point. The easiest way to do this is to create an S3 class that allows us to distinguish between regular text (that needs escaping) and HTML (that doesn&#39;t).</p>

<p>We then write an escape method that leaves HTML unchanged and escapes the special characters (<code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>) in ordinary text. We also add a method for lists for convenience</p>

<div class="chunk" id="unnamed-chunk-492"><div class="rcode"><div class="source"><pre class="knitr r">html <- function(x) structure(x, class = "html")
print.html <- function(x, ...) cat("<HTML> ", x, "\n", sep = "")
escape <- function(x) UseMethod("escape")
escape.html <- function(x) x
escape.character <- function(x) {
  x <- gsub("&", "&amp;", x)
  x <- gsub("<", "&lt;", x)
  x <- gsub(">", "&gt;", x)
  
  html(x)
}
escape.list <- function(x) {
  lapply(x, escape)
}

# Now we check that it works
escape("This is some text.")
</pre></div>

<div class="output"><pre class="knitr r">## <HTML> This is some text.
</pre></div>

<div class="source"><pre class="knitr r">escape("x > 1 & y < 2")
</pre></div>

<div class="output"><pre class="knitr r">## <HTML> x &gt; 1 &amp; y &lt; 2
</pre></div>

<div class="source"><pre class="knitr r">
# Double escaping is not a problem
escape(escape("This is some text. 1 > 2"))
</pre></div>

<div class="output"><pre class="knitr r">## <HTML> This is some text. 1 &gt; 2
</pre></div>

<div class="source"><pre class="knitr r">
# And text we know is HTML doesn't get escaped.
escape(html("<hr />"))
</pre></div>

<div class="output"><pre class="knitr r">## <HTML> <hr />
</pre></div>

<p></div></div></p>

<p>Escaping is an important component for any DSL.</p>

<h3>Basic tag functions</h3>

<p>Next we&#39;ll write a few simple tag functions and then figure out how to generalise for all possible HTML tags. Let&#39;s start with <code>&lt;p&gt;</code>. HTML tags can have both attributes (e.g. id, or class) and children (like <code>&lt;b&gt;</code> or <code>&lt;i&gt;</code>). We need some way of separating these in the function call: since attributes are named values and children don&#39;t have names, it seems natural to separate using named vs. unnamed arguments. Then a call to <code>p()</code> might look like:</p>

<div class="chunk" id="unnamed-chunk-493"><div class="rcode"><div class="source"><pre class="knitr r">p("Some text.", b("some bold text"), class = "mypara")
</pre></div>

<p></div></div></p>

<p>We could list all the possible attributes of the p tag in the function definition, but that&#39;s hard because there are so many, and it&#39;s possible to use <a href="http://html5doctor.com/html5-custom-data-attributes/">custom attributes</a> Instead we&#39;ll just use ... and separate the components based on whether or they are named. To do this correctly, we need to be aware of a &quot;feature&quot; of <code>names()</code>:</p>

<div class="chunk" id="unnamed-chunk-494"><div class="rcode"><div class="source"><pre class="knitr r">names(c(a = 1, b = 2))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b"
</pre></div>

<div class="source"><pre class="knitr r">names(c(a = 1, 2))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" ""
</pre></div>

<div class="source"><pre class="knitr r">names(c(1, 2))
</pre></div>

<div class="output"><pre class="knitr r">## NULL
</pre></div>

<p></div></div></p>

<p>With this in mind we create two helper functions to extract the named and unnamed components of a vector:</p>

<div class="chunk" id="unnamed-chunk-495"><div class="rcode"><div class="source"><pre class="knitr r">named <- function(x) {
  if (is.null(names(x))) return(NULL)
  x[names(x) != ""]
}
unnamed <- function(x) {
  if (is.null(names(x))) return(x)
  x[names(x) == ""]
}
</pre></div>

<p></div></div></p>

<p>We can now create our <code>p()</code> function. There&#39;s one new function here: <code>html_attributes()</code>. This takes a list of name-value pairs and creates the correct HTML attributes specification from them. It&#39;s a little complicated (to deal with some idiosyncracies of HTML that I haven&#39;t mentioned), not that important and doesn&#39;t introduce any  new ideas, so I won&#39;t discuss it here, but it&#39;s included at the end of the chapter.</p>

<div class="chunk" id="unnamed-chunk-496"><div class="rcode"><div class="source"><pre class="knitr r">source("code/html-attributes.r")
</pre></div>

<div class="warning"><pre class="knitr r">## Warning: cannot open file 'code/html-attributes.r': No such file or
## directory
</pre></div>

<div class="error"><pre class="knitr r">## Error: cannot open the connection
</pre></div>

<div class="source"><pre class="knitr r">p <- function(...) {
  args <- list(...)
  attribs <- html_attributes(named(args))
  children <- unlist(escape(unnamed(args)))
  
  html(paste0(
    "<p", attribs, ">", 
    paste(children, collapse = ""), 
    "</p>"
  ))
}

p("Some text")
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<div class="source"><pre class="knitr r">p("Some text", id = "myid")
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<div class="source"><pre class="knitr r">p("Some text", image = NULL)
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<div class="source"><pre class="knitr r">p("Some text", class = "important", "data-value" = 10)
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<p></div></div></p>

<h3>Tag functions</h3>

<p>With this definition of <code>p()</code> it&#39;s pretty easy to see what will change for different tags: we just need to replace <code>&quot;p&quot;</code> with a variable.  We&#39;ll use a closure to make it easy to generate a tag function given a tag name:</p>

<div class="chunk" id="unnamed-chunk-497"><div class="rcode"><div class="source"><pre class="knitr r">tag <- function(tag) {
  force(tag)
  function(...) {
    args <- list(...)
    attribs <- html_attributes(named(args))
    children <- unlist(escape(unnamed(args)))
    
    html(paste0(
      "<", tag, attribs, ">", 
      paste(children, collapse = ""), 
      "</", tag, ">"
    ))
  }
}
</pre></div>

<p></div></div></p>

<p>(We&#39;re forcing the evaluation <code>tag</code> with the expectation we&#39;ll be calling this function from a loop later on - that avoids potential bugs caused by lazy evaluation.)</p>

<p>Now we can run our earlier example:</p>

<div class="chunk" id="unnamed-chunk-498"><div class="rcode"><div class="source"><pre class="knitr r">p <- tag("p")
b <- tag("b")
i <- tag("i")
p("Some text.", b("Some bold text"), i("Some italic text"), 
  class = "mypara")
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<p></div></div></p>

<p>Before we continue to generate functions for every possible HTML tag, we need a variant of <code>tag()</code> for void tags. It can be very similar to <code>tag()</code>, but needs to throw an error if there are any unnamed tags, and the tag itself looks slightly different:</p>

<div class="chunk" id="unnamed-chunk-499"><div class="rcode"><div class="source"><pre class="knitr r">void_tag <- function(tag) {
  force(tag)
  function(...) {
    args <- list(...)
    if (length(unnamed(args)) > 0) {
      stop("Tag ", tag, " can not have children", call. = FALSE)
    }
    attribs <- html_attributes(named(args))
    
    html(paste0("<", tag, attribs, " />"))
  }
}

img <- void_tag("img")
img(src = "myimage.png", width = 100, height = 100)
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<p></div></div></p>

<h3>Processing all tags</h3>

<p>Next we need a list of all the HTML tags:</p>

<div class="chunk" id="unnamed-chunk-500"><div class="rcode"><div class="source"><pre class="knitr r">tags <- c("a", "abbr", "address", "article", "aside", "audio", "b", 
  "bdi", "bdo", "blockquote", "body", "button", "canvas", "caption", 
  "cite", "code", "colgroup", "data", "datalist", "dd", "del", 
  "details", "dfn", "div", "dl", "dt", "em", "eventsource", 
  "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", 
  "h3", "h4", "h5", "h6", "head", "header", "hgroup", "html", "i", 
  "iframe", "ins", "kbd", "label", "legend", "li", "mark", "map", 
  "menu", "meter", "nav", "noscript", "object", "ol", "optgroup", 
  "option", "output", "p", "pre", "progress", "q", "ruby", "rp", 
  "rt", "s", "samp", "script", "section", "select", "small", "span", 
  "strong", "style", "sub", "summary", "sup", "table", "tbody", 
  "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", 
  "u", "ul", "var", "video") 

void_tags <- c("area", "base", "br", "col", "command", "embed", 
  "hr", "img", "input", "keygen", "link", "meta", "param", "source", 
  "track", "wbr")
</pre></div>

<p></div></div></p>

<p>If you look at this list carefully, you&#39;ll see there are quite a few tags that have the same name as base R functions (<code>body</code>, <code>col</code>, <code>q</code>, <code>source</code>, <code>sub</code>, <code>summary</code>, <code>table</code>), and others that clash with popular packages (e.g. <code>map</code>). That implies we don&#39;t want to make all the functions available (in either the global environment or a package environment) by default. Instead, we&#39;ll put them in a list, and add some additional code to make it easy to use them when desired. First we make a named list:</p>

<div class="chunk" id="unnamed-chunk-501"><div class="rcode"><div class="source"><pre class="knitr r">tag_fs <- c(
  setNames(lapply(tags, tag), tags), 
  setNames(lapply(void_tags, void_tag), void_tags)
)
</pre></div>

<p></div></div></p>

<p>This gives us a way to call tag functions explicitly, but is a little
verbose:</p>

<div class="chunk" id="unnamed-chunk-502"><div class="rcode"><div class="source"><pre class="knitr r">tag_fs$p("Some text.", tag_fs$b("Some bold text"), 
  tag_fs$i("Some italic text"))
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<p></div></div></p>

<p>Then we finish off our HTML DSL by creating a function that allows us to evaluate code in the context of that list:</p>

<div class="chunk" id="unnamed-chunk-503"><div class="rcode"><div class="source"><pre class="knitr r">with_html <- function(code) {
  eval(substitute(code), tag_fs)
}
</pre></div>

<p></div></div></p>

<p>This gives us a succinct API which allows us to write HTML when we need it without cluttering up the namespace when we don&#39;t. Inside <code>with_html</code> if you want to access the R function overridden by an HTML tag of the same name, you can use the full <code>package::function</code> specification.</p>

<div class="chunk" id="unnamed-chunk-504"><div class="rcode"><div class="source"><pre class="knitr r">with_html(body(
  h1("A heading", id = "first"),
  p("Some text &", b("some bold text.")),
  img(src = "myimg.png", width = 100, height = 100)
))
</pre></div>

<div class="error"><pre class="knitr r">## Error: could not find function "html_attributes"
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>The escaping rules for <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags are different: you don&#39;t want to escape angle brackets or ampersands, but you do want to escape <code>&lt;/</code>.  Adapt the code above to follow these rules.</p></li>
<li><p>The use of ... for all functions has some big downsides: there&#39;s no input validation and there will be little information in the documentation or autocomplete about how to use the function. Create a new function that when given a named list of tags and their attribute names (like below), creates functions with those signatures.</p></li>
</ul>

<div class="chunk" id="unnamed-chunk-505"><div class="rcode"><div class="source"><pre class="knitr r">list(
  a = c("href"),
  img = c("src", "width", "height")
)
</pre></div>

<p></div></div></p>

<pre><code>All tags should get `class` and `id` attributes.
</code></pre>

<ul>
<li>Currently the html doesn&#39;t look terribly pretty, and it&#39;s hard to see the structure. How could you adapt <code>tag()</code> to do be indenting and formatting?</li>
</ul>

<h2>Latex</h2>

<p>The next DSL we&#39;re going to tackle will convert R expression into their latex math equivalents. (This is a bit like <code>?plotmath</code>, but for text instead of plots.) Latex is the lingua franca of mathematicians and statisticians: whenever you want to describe an equation in text (e.g. in an email) you write it as a latex equation. Many reports are produced from R using latex, so it might be useful to facilitate the automate conversion from mathematical expressions from one language to the other.</p>

<p>This math expression DSL will be more complicated than the HTML DSL, because not only do we need to convert functions, but we also need to convert symbols.  We&#39;ll also create a &quot;default&quot; conversion, so that functions we don&#39;t know how to convert get a standard fallback. Like the HTML DSL, we&#39;ll also write functionals to make it easier to generate the translators.</p>

<p>Before we begin, let&#39;s quickly cover how formulas are expressed in latex.</p>

<h3>Latex mathematics</h3>

<p>Latex mathematics are complex, and <a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics">well documented</a>. They have a fairly simple structure:</p>

<ul>
<li><p>Most simple mathematical equations are represented in the way you&#39;d type them into R: <code>x * y</code>, <code>z ^ 5</code>.  Subscripts are written using <code>_</code>, e.g. <code>x_1</code>.</p></li>
<li><p>Special characters start with a <code>\</code>: <code>\pi</code> = π, <code>\pm</code> = ±, and so on. There are a huge number of symbols available in latex. Googling for <code>latex math symbols</code> finds many <a href="http://www.sunilpatel.co.uk/latex-type/latex-math-symbols/">lists</a>, and there&#39;s even <a href="http://detexify.kirelabs.org/classify.html">a service</a> where you can sketch a symbol in the browser and it will look it up for you.</p></li>
<li><p>More complicated functions look like <code>\name{arg1}{arg2}</code>.  For example to represent a fraction you use <code>\frac{a}{b}</code>, and a sqrt looks like <code>\sqrt{a}</code>.</p></li>
<li><p>To group elements together use <code>{}</code>: i.e. <code>x ^ a + b</code> vs. <code>x ^ {a + b}</code>.</p></li>
<li><p>In good math typesetting, a distinction is made between variables and functions, but without extra information, latex doesn&#39;t know whether <code>f(a * b)</code> represents calling the function <code>f</code> with argument <code>a * b</code>, or is shorthand for <code>f * a * b</code>. If <code>f</code> is a function, you can tell latex to typeset it using an upright font with <code>\textrm{f}(a * b)</code></p></li>
</ul>

<h3>Goal</h3>

<p>Our goal is to use these rules to automatically convert from an R expression to a latex representation of that expression. We will tackle it in four stages:</p>

<ul>
<li>Convert known symbols: <code>pi</code> -&gt; <code>\pi</code></li>
<li>Leave other symbols unchanged: <code>x</code> -&gt; <code>x</code>, <code>y</code> -&gt; <code>y</code></li>
<li>Convert known functions: <code>x * pi</code> -&gt; <code>x * \pi</code>, <code>sqrt(frac(a, b))</code> -&gt; <code>\sqrt{\frac{a, b}}</code></li>
<li>Wrap unknown functions with <code>\textrm</code>: <code>f(a)</code> -&gt; <code>\textrm{f}(a)</code></li>
</ul>

<p>Compared to the HTML DSL, we&#39;ll work in the opposite direction: we&#39;ll start with the infrastructure and work our way down to generate all the functions we need</p>

<h3><code>to_math</code></h3>

<p>To begin, we need a wrapper function that we&#39;ll use to convert R expressions into latex math expressions. This works the same way as <code>to_html</code>: we capture the unevaluated expression and evaluate it in a special environment. However, the special environment is no longer fixed, and will vary depending on the expression. We need this in order to be able to deal with symbols and functions that we don&#39;t know about a priori.</p>

<div class="chunk" id="unnamed-chunk-506"><div class="rcode"><div class="source"><pre class="knitr r">to_math <- function(x) {
  expr <- substitute(x)
  eval(expr, latex_env(expr))
}
</pre></div>

<p></div></div></p>

<h3>Known symbols</h3>

<p>Our first step is to create an environment that allows us to convert the special latex symbols used for Greek, e.g. <code>pi</code> to <code>\pi</code>. This is the same basic trick used in <code>subset</code> to make it possible to select column ranges by name (<code>subset(mtcars, , cyl:wt)</code>): we just bind a name to a string in a special environment.</p>

<p>First we create than environment by creating a named vector, converting that vector into a list, and then turn that list into an environment.</p>

<div class="chunk" id="unnamed-chunk-507"><div class="rcode"><div class="source"><pre class="knitr r">greek <- c(
  "alpha", "theta", "tau", "beta", "vartheta", "pi", "upsilon", 
  "gamma", "gamma", "varpi", "phi", "delta", "kappa", "rho", 
  "varphi", "epsilon", "lambda", "varrho", "chi", "varepsilon", 
  "mu", "sigma", "psi", "zeta", "nu", "varsigma", "omega", "eta", 
  "xi", "Gamma", "Lambda", "Sigma", "Psi", "Delta", "Xi", "Upsilon", 
  "Omega", "Theta", "Pi", "Phi")
greek_list <- setNames(paste0("\\", greek), greek)
greek_env <- list2env(as.list(greek_list), parent = emptyenv())
</pre></div>

<p></div></div></p>

<p>We can then check it:</p>

<div class="chunk" id="unnamed-chunk-508"><div class="rcode"><div class="source"><pre class="knitr r">latex_env <- function(expr) {
  greek_env
}

to_math(pi)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "\\pi"
</pre></div>

<div class="source"><pre class="knitr r">to_math(beta)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "\\beta"
</pre></div>

<p></div></div></p>

<h3>Unknown symbols</h3>

<p>If a symbol isn&#39;t greek, we want to leave it as is. This is trickier because we don&#39;t know in advance what symbols will be used, and we can&#39;t possibly generate them all. So we&#39;ll use a little bit of computing on the language to find out what symbols are present in an expression. The <code>all_names</code> function takes an expression: if it&#39;s a name, it converts it to a string; if it&#39;s a call, it recurses down through its arguments.</p>

<div class="chunk" id="unnamed-chunk-509"><div class="rcode"><div class="source"><pre class="knitr r">all_names <- function(x) {
  # Base cases
  if (is.name(x)) return(as.character(x))
  if (!is.call(x)) return(NULL)

  # Recursive case
  children <- lapply(x[-1], all_names)
  unique(unlist(children))
}

all_names(quote(x + y + f(a, b, c, 10)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x" "y" "a" "b" "c"
</pre></div>

<div class="source"><pre class="knitr r"># [1] "x" "y" "a" "b" "c"
</pre></div>

<p></div></div></p>

<p>We now want to take that list of symbols, and convert it to an environment so that each symbol is mapped to a string representing itself (e.g. so <code>eval(quote(x), env)</code> yields <code>&quot;x&quot;</code>). We again use the pattern of converting a named character vector to a list, then an environment.</p>

<div class="chunk" id="unnamed-chunk-510"><div class="rcode"><div class="source"><pre class="knitr r">latex_env <- function(expr) {
  names <- all_names(expr)
  symbol_list <- setNames(as.list(names), names)
  symbol_env <- list2env(symbol_list)

  symbol_env
}

to_math(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<div class="source"><pre class="knitr r">to_math(longvariablename)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "longvariablename"
</pre></div>

<div class="source"><pre class="knitr r">to_math(pi)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "pi"
</pre></div>

<p></div></div></p>

<p>This works, but we need to combine it with the enviroment of the Greek symbols. Since we want to prefer Greek to the defaults (e.g. <code>to_math(pi)</code> should give <code>&quot;\\pi&quot;</code>, not <code>&quot;pi&quot;</code>), <code>symbol_env</code> needs to be the parent of <code>greek_env</code>, and thus we need to make a copy of <code>greek_env</code> with a new parent.  Strangely R doesn&#39;t come with a function for cloning environments, but we can easily create one by combining two existing functions:</p>

<div class="chunk" id="unnamed-chunk-511"><div class="rcode"><div class="source"><pre class="knitr r">clone_env <- function(env, parent = parent.env(env)) {
  list2env(as.list(env), parent = parent)
}
</pre></div>

<p></div></div></p>

<p>This gives us a function that can convert both known (Greek) and unknown symbols.</p>

<div class="chunk" id="unnamed-chunk-512"><div class="rcode"><div class="source"><pre class="knitr r">latex_env <- function(expr) {
  # Unknown symbols
  names <- all_names(expr)
  symbol_list <- setNames(as.list(names), names)
  symbol_env <- list2env(symbol_list)

  # Known symbols
  clone_env(greek_env, symbol_env)
}

to_math(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "x"
</pre></div>

<div class="source"><pre class="knitr r">to_math(longvariablename)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "longvariablename"
</pre></div>

<div class="source"><pre class="knitr r">to_math(pi)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "\\pi"
</pre></div>

<p></div></div></p>

<h3>Known functions</h3>

<p>Next we&#39;ll add functions to our DSL.  We&#39;ll start with a couple of helper closures that make it easy to add new unary and binary operators. These functions are very simple since they only have to assemble strings. (Again we use <code>force</code> to make sure the arguments are evaluated at the right time.)</p>

<div class="chunk" id="unnamed-chunk-513"><div class="rcode"><div class="source"><pre class="knitr r">unary_op <- function(left, right) {
  force(left)
  force(right)
  function(e1) {
    paste0(left, e1, right)
  }
}

binary_op <- function(sep) {
  force(sep)
  function(e1, e2) {
    paste0(e1, sep, e2)
  }
}
</pre></div>

<p></div></div></p>

<p>Using these helpers, we can map a few illustrative examples from R to latex. Note how the lexical scoping rules of R help us: we can easily provide new meanings for standard functions like <code>+</code>, <code>-</code> and <code>*</code>, and even <code>(</code> and <code>{</code>. </p>

<div class="chunk" id="unnamed-chunk-514"><div class="rcode"><div class="source"><pre class="knitr r"># Binary operators
f_env <- new.env(parent = emptyenv())
f_env$"+" <- binary_op(" + ")
f_env$"-" <- binary_op(" - ")
f_env$"*" <- binary_op(" * ")
f_env$"/" <- binary_op(" / ")
f_env$"^" <- binary_op("^")
f_env$"[" <- binary_op("_")

# Grouping
f_env$"{" <- unary_op("\\left{ ", " \\right}")
f_env$"(" <- unary_op("\\left( ", " \\right)")
f_env$paste <- paste

# Other math functions
f_env$sqrt <- unary_op("\\sqrt{", "}")
f_env$sin <- unary_op("\\sin(", ")")
f_env$log <- unary_op("\\log(", ")")
f_env$abs <- unary_op("\\left| ", "\\right| ")
f_env$frac <- function(a, b) {
  paste0("\\frac{", a, "}{", b, "}")
}

# Labelling
f_env$hat <- unary_op("\\hat{", "}")
f_env$tilde <- unary_op("\\tilde{", "}")
</pre></div>

<p></div></div></p>

<p>We again modify <code>latex_env()</code> to include this environment. It should be the last environment in which names are looked for, so that <code>sin(sin)</code> works. (because of R&#39;s matching rules wrt functions vs. other objects)</p>

<div class="chunk" id="unnamed-chunk-515"><div class="rcode"><div class="source"><pre class="knitr r">latex_env <- function(expr) {
  # Known functions
  f_env

  # Default symbols
  names <- all_names(expr)
  symbol_list <- setNames(as.list(names), names)
  symbol_env <- list2env(symbol_list, parent = fenv)

  # Known symbols
  greek_env <- clone_env(greek_env, parent = symbol_env)
}

to_math(sin(x + pi))
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'fenv' not found
</pre></div>

<div class="source"><pre class="knitr r">to_math(log(x_i ^ 2))
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'fenv' not found
</pre></div>

<div class="source"><pre class="knitr r">to_math(sin(sin))
</pre></div>

<div class="error"><pre class="knitr r">## Error: object 'fenv' not found
</pre></div>

<p></div></div></p>

<h3>Unknown functions</h3>

<p>Finally, we&#39;ll add a default for functions that we don&#39;t know about. Like the unknown names, we can&#39;t know in advance what these will be, so we again use a little computing on the language to figure them out:</p>

<div class="chunk" id="unnamed-chunk-516"><div class="rcode"><div class="source"><pre class="knitr r">all_calls <- function(x) {
  # Base name
  if (!is.call(x)) return(NULL)

  # Recursive case
  fname <- as.character(x[[1]])
  children <- lapply(x[-1], all_calls)
  unique(c(fname, unlist(children, use.names = FALSE)))
}

all_calls(quote(f(g + b, c, d(a))))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "f" "+" "d"
</pre></div>

<p></div></div></p>

<p>And we need a closure that will generate the functions for each unknown call</p>

<div class="chunk" id="unnamed-chunk-517"><div class="rcode"><div class="source"><pre class="knitr r">unknown_op <- function(op) {
  force(op)
  function(...) {
    contents <- paste(..., collapse = ", ")
    paste0("\\mathrm{", op, "}(", contents, ")")
  }
}
</pre></div>

<p></div></div></p>

<p>And again we update <code>latex_env()</code>:</p>

<div class="chunk" id="unnamed-chunk-518"><div class="rcode"><div class="source"><pre class="knitr r">latex_env <- function(expr) {
  calls <- all_calls(expr)
  call_list <- setNames(lapply(calls, unknown_op), calls)
  call_env <- list2env(call_list)

  # Known functions
  f_env <- clone_env(f_env, call_env)

  # Default symbols
  symbols <- all_names(expr)
  symbol_list <- setNames(as.list(symbols), symbols)
  symbol_env <- list2env(symbol_list, parent = f_env)

  # Known symbols
  greek_env <- clone_env(greek_env, parent = symbol_env)
}

to_math(f(a * b))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "\\mathrm{f}(a * b)"
</pre></div>

<p></div></div></p>

<h3>Exercises</h3>

<ul>
<li><p>Add automatic escaping. Special symbols that should be escaped by adding a backslash in front of them are <code>\</code>, <code>$</code> and <code>%</code>.  Like for sql, you&#39;ll need to make sure you don&#39;t end up double-escaping, so you&#39;ll need to create a small s3 class and then use that in function operators.  That will also allow you to embed arbitrary latex if needed.</p></li>
<li><p>Complete the DSL to support all the functions that <code>plotmath</code> supports</p></li>
<li><p>There&#39;s a repeating pattern in <code>latex_env()</code>: we take a character vector, do something to each piece, then convert it to a list, and then an environment. Write a function to automate this task, and then rewrite <code>latex_env()</code></p></li>
</ul>

<h1>Profiling and benchmarking</h1>

<p>&quot;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil&quot; --- Donald Knuth.</p>

<p>Your code should be correct, maintainable and fast. Notice that speed comes last - if your function is incorrect or unmaintainable (i.e. will eventually become incorrect) it doesn&#39;t matter if it&#39;s fast. As computers get faster and R is optimised, your code will get faster all by itself. Your code is never going to automatically become correct or elegant if it is not already.</p>

<p>That said, sometimes there are times where you need to make your code faster: spending several hours of your day might save days of computing time for others. The aim of this chapter is to give you the skills to figure out why your code is slow, what you can do to improve it, and ensure that you don&#39;t accidentally make it slow again in the future.  You may already be familiar with <code>system.time</code>, which tells you how long a block of code takes to run. This is a useful building block, but is a crude tool.</p>

<p>Making fast code is a four part process:</p>

<ol>
<li><p>Profiling helps you discover parts of your code are taking up the most time</p></li>
<li><p>Microbenchmarking lets you experiment with small parts of your code to find faster approaches.</p></li>
<li><p>Timing helps you check that the micro-optimisations have a macro effect, and helps experiment with larger changes (like totally rethinking your approach)</p></li>
<li><p>A performance testing tool makes sure your code stays fast in the future  (e.g. <a href="http://wesmckinney.com/blog/?p=373">Vbench</a>)</p></li>
</ol>

<p>Along the way, you&#39;ll also learn about the most common causes of poor performance in R, and how to address them. Sometimes there&#39;s no way to improve performance within R, and you&#39;ll need to use [[Rcpp]], the topic of the next chapter.</p>

<p>Having a good test suite is important when tuning the performance of your code: you don&#39;t want to make your code fast at the expense of making it incorrect. We won&#39;t discuss testing any further in this chapter, but we strongly recommend having a good set of test cases written before you begin optimisation.</p>

<p>Good exploration from Winston: <a href="http://rpubs.com/wch/3797">http://rpubs.com/wch/3797</a></p>

<h2>Performance profiling</h2>

<p>R provides a built in tool for profiling: <code>Rprof</code>. When active, this records the current call stack to disk very <code>interval</code> seconds. This provides a fine grained report showing how long each function takes. The function <code>summaryRprof</code> provides a way to turn this list of call stacks into useful information. But I don&#39;t think it&#39;s terribly useful, because it makes it hard to see the entire structure of the program at once. Instead, we&#39;ll use the <code>profr</code> package, which turns the call stack into a data.frame that is easier to manipulate and visualise.</p>

<p>Example showing how to use profr.</p>

<p>Sample pictures.</p>

<h3>Copy-on-modify semantics</h3>

<p>If much of your time is taken up by <code>[</code> or <code>[[</code> then you may be victim of the most common cause of performance problems in R: its copy on modify semantics.  In R, it&#39;s easy to think that you&#39;re modifying an object in place, but you&#39;re actually creating a new copy each time. </p>

<p>It&#39;s not that loops are slow, it&#39;s that if you&#39;re not careful every time you modify an object inside a list it makes a complete copy. C functions are usually faster not because the loop is written in C, but because C&#39;s default behaviour is to modify in place, not make a copy. This is less safe, but much more efficient. If you&#39;re modifying a data structure in a loop, you can often get big performance gains by switching to the vectorised equivalent.  When working with matrices and data frames, this often means creating a large object that you can combine with a single operation.</p>

<p>Take the following code that subtracts the median from each column of a large data.frame:</p>

<div class="chunk" id="unnamed-chunk-520"><div class="rcode"><div class="source"><pre class="knitr r">x <- data.frame(matrix(runif(100 * 1e4), ncol = 100))
medians <- vapply(x, median, numeric(1))

system.time({
  for(i in seq_along(medians)) {
    x[, i] <- x[, i] - medians[i]
  }
})
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##   1.267   0.165   1.434
</pre></div>

<p></div></div></p>

<p>It&#39;s rather slow - we only have 100 columns and 10,000 rows, but it&#39;s still taking over second. We can use <code>address()</code> to see what&#39;s going on. This function returns the memory address that the object occupies:</p>

<div class="chunk" id="unnamed-chunk-521"><div class="rcode"><div class="source"><pre class="knitr r">library(pryr)
track_x <- track_copy(x)
system.time({
  for(i in seq_along(medians)) {
    x[, i] <- x[, i] - medians[i]
    track_x()
  }
})
</pre></div>

<div class="error"><pre class="knitr r">## Error: incorrect number of dimensions
</pre></div>

<p></div></div></p>

<p>Each iteration of the loop prints a different memory address - the complete data frame is being modified and copied for each iteration.</p>

<p>We can make the function substantially more efficient by using a list which can modify in place:</p>

<div class="chunk" id="unnamed-chunk-522"><div class="rcode"><div class="source"><pre class="knitr r">y <- as.list(x)
track_y <- track_copy(y)
system.time({
  for(i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[i]
    track_y()
  }
})
</pre></div>

<div class="message"><pre class="knitr r">## y copied
</pre></div>

<div class="error"><pre class="knitr r">## Error: subscript out of bounds
</pre></div>

<div class="output"><pre class="knitr r">## Timing stopped at: 0.001 0 0.001
</pre></div>

<p></div></div></p>

<p>We can rewrite it to be much faster by eliminating all those copies, and instead relying on vectorised data frame subtraction: if you subtract a list from a data frame, the elements of the list are matched up with the elements of the data frame. That loop occurs at the C-level, which means the data frame is only copied once, not many many times.</p>

<div class="chunk" id="unnamed-chunk-523"><div class="rcode"><div class="source"><pre class="knitr r">z <- as.data.frame(x)
system.time({
  z <- z - as.list(medians)
})
</pre></div>

<div class="error"><pre class="knitr r">## Error: list of length 100 not meaningful
</pre></div>

<div class="output"><pre class="knitr r">## Timing stopped at: 0.001 0 0
</pre></div>

<p></div></div></p>

<p>The art of R performance improvement is to build up a good intuitions for what operations incur a copy, and what occurs in place. Each version of R usually implements a few performance improvements that eliminates copies, so it&#39;s impossible to give an up-to-date list, but some rules of thumb are:</p>

<ul>
<li><p><code>structure(x, class = &quot;c&quot;)</code> makes a copy.  <code>class(x) &lt;- c</code> does not.</p></li>
<li><p>Modifying a vector in place with <code>[&lt;-</code> or <code>[[&lt;-</code> does not make a copy.  Modifying a data frame in place does make a copy. Modifying a list in place makes a copy, but it&#39;s a shallow copy: each individual component of the list is not copied. </p></li>
<li><p><code>names&lt;-</code>, <code>attr&lt;-</code> and <code>attributes&lt;-</code> don&#39;t make a copy</p></li>
<li><p>Avoid modifying complex objects (like data frames) repeatedly and instead pull out the component you want to modify, modify it, and then put it back in.  If that doesn&#39;t work, converting it to a simpler object type and then converting back might help</p></li>
</ul>

<p>Generally, building up a rich vocabulaory of vectorised functions will help you write performant code.  Vectorisation basically means pushing a for-loop from R in C so that only one copy of the data structure is made.</p>

<p>If you thinking copying is causing a bottleneck in your program, then I recommend running some small experiments using <code>address()</code> and <code>microbenchmark</code> as described below. </p>

<h2>Micro-benchmarking</h2>

<p>Once you have identified the performance bottleneck in your code, you&#39;ll want to try out many variant approaches.</p>

<p>The <a href="http://cran.r-project.org/web/packages/microbenchmark/index.html">microbenchmark</a> package is much more precise than <code>system.time()</code> with nanosecond rather than millisecond precision. This makes it much easier to compare operations that only take a small amount of time. For example, we can determine the overhead of calling a function: (for an example in the package)</p>

<div class="chunk" id="unnamed-chunk-524"><div class="rcode"><div class="source"><pre class="knitr r">library(microbenchmark)

f <- function() NULL
microbenchmark(
  NULL,
  f()
)
</pre></div>

<div class="error"><pre class="knitr r">## Error: Measured negative execution time! Please investigate and/or contact
## the package author.
</pre></div>

<p></div></div></p>

<p>It&#39;s about ~150 ns on my computer (that&#39;s the time taken to set up the new environment for the function etc). </p>

<p>It&#39;s hard to accurately compute this difference with <code>system.time</code> because we need to repeat the operation about a million times, and we get no information about the variability of the estimate.  The results may also be systematically biased if some other computation is happening in the background during one of the runs.</p>

<div class="chunk" id="unnamed-chunk-525"><div class="rcode"><div class="source"><pre class="knitr r">x <- 1:1e6
system.time(for (i in x) NULL) * 1e3
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##     110       0     111
</pre></div>

<div class="source"><pre class="knitr r">system.time(for (i in x) f()) * 1e3
</pre></div>

<div class="output"><pre class="knitr r">##    user  system elapsed 
##     374       0     374
</pre></div>

<p></div></div></p>

<p>Running both examples on my computer a few times reveals that the estimate from <code>system.time</code> is about 20 nanoseconds higher than the median from <code>microbenchmark</code>.</p>

<p>By default, microbenchmark evaluates each expression 100 times, and in random order to control for any systematic variability. It also provides times each expression individually, so you get a distribution of times, which helps estimate error.  You can also display the results visually using either <code>boxplot</code>, or if you have <code>ggplot2</code> loaded, <code>autoplot</code>:</p>

<div class="chunk" id="unnamed-chunk-526"><div class="rcode"><div class="source"><pre class="knitr r">f <- function() NULL
g <- function() f()
h <- function() g()
i <- function() h()
m <- microbenchmark(
  NULL,
  f(), 
  g(),
  h(),
  i())
</pre></div>

<div class="error"><pre class="knitr r">## Error: Measured negative execution time! Please investigate and/or contact
## the package author.
</pre></div>

<div class="source"><pre class="knitr r">boxplot(m)
</pre></div>

<div class="error"><pre class="knitr r">## Error: non-numeric argument to binary operator
</pre></div>

<div class="source"><pre class="knitr r">library(ggplot2)
</pre></div>

<div class="message"><pre class="knitr r">## Attaching package: 'ggplot2'
## 
## The following object is masked _by_ '.GlobalEnv':
## 
## %+%, aes
</pre></div>

<div class="source"><pre class="knitr r">autoplot(m)
</pre></div>

<div class="error"><pre class="knitr r">## Error: Objects of type simpleMessage not supported by autoplot.  Please
## use qplot() or ggplot() instead. Objects of type message not supported by
## autoplot.  Please use qplot() or ggplot() instead. Objects of type
## condition not supported by autoplot.  Please use qplot() or ggplot()
## instead.
</pre></div>

<p></div></div></p>

<p>Microbenchmarking allows you to take the very small parts of a program that profiling has identified as being bottlenecks and explore alternative approaches.  It is easier to do this with very small parts of a program because you can rapidly try out alternatives without having to worry too much about correctness (i.e. you are comparing alternatives that are so simple it&#39;s obvious whether they&#39;re correct or not.)</p>

<p>Useful to think about the first part of the process, generating possible alternatives as brainstorming.  You want to come up with as many different approaches to the problem as possible.  Don&#39;t worry if some of the approaches seem like they will <em>obviously</em> be slow: you might be wrong, or that approach might be one step towards a better approach.  To get out of a local maxima, you must go down hill.</p>

<p>When doing microbenchmarking, you not only need to figure out what the best method is now, but you need to make sure that fact is recorded somewhere so that when you come back to the code in the future, you remember your reasoning and don&#39;t have to redo it again. I find it really useful to write microbenchmarking code as Rmarkdown documents so that I can easily integrate the benchmarking code as well as text describing my hypotheses about why one method is better than another, and listing things that I tried that weren&#39;t so effective.</p>

<p>Microbenchmarking is also a powerful tool to improve your intuition about what operations in R are fast and what are slow. The following XXX examples show how to use microbenchmarking to determine the costs of some common R actions, but I really recommend setting up some experiments for the R functions that you use most commonly.</p>

<ul>
<li>What&#39;s the cost of function vs S3 or S4 method dispatch? </li>
<li>What&#39;s the fastest way to extract a column out of data.frame?</li>
</ul>

<h3>Method dispatch</h3>

<p>The following microbenchmark compares the cost of generating one uniform number directly, with a function, with a S3 method, with a S4 method and a R5 </p>

<div class="chunk" id="unnamed-chunk-527"><div class="rcode"><div class="source"><pre class="knitr r">f <- function(x) NULL

s3 <- function(x) UseMethod("s3")
s3.integer <- function(x) NULL

A <- setClass("A", representation(a = "list"))
setGeneric("s4", function(x) standardGeneric("s4"))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s4"
</pre></div>

<div class="source"><pre class="knitr r">setMethod(s4, "A", function(x) NULL)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "s4"
## attr(,"package")
## [1] ".GlobalEnv"
</pre></div>

<div class="source"><pre class="knitr r">
B <- setRefClass("B")
B$methods(r5 = function(x) NULL)

a <- A()
b <- B$new()

microbenchmark(
  bare = NULL,
  fun = f(),
  s3 = s3(1L),
  s4 = s4(a),
  r5 = b$r5()
)
</pre></div>

<div class="error"><pre class="knitr r">## Error: Measured negative execution time! Please investigate and/or contact
## the package author.
</pre></div>

<p></div></div></p>

<p>On my computer, the bare call takes about 40 ns. Wrapping it in a function adds about an extra 200 ns - this is the cost of creating the environment where the function execution happens. S3 method dispatch adds around 3 µs and S4 around 12 µs.</p>

<p>However, it&#39;s important to notice the units: microseconds. There are a million microseconds in a second, so it will take hundreds of thousands of calls before the cost of S3 or S4 dispatch appreciable. Most problems don&#39;t involve hundreds of thousands of function calls, so it&#39;s unlikely to be a bottleneck in practice.This is why microbenchmarks can not considering in isolation: they must be  carefully considered in the context of your real problem.</p>

<h3>Extracting variables out of a data frame</h3>

<p>For the plyr package, I did a lot of experimentation to figure out the fastest way of extracting data out of a data frame.</p>

<div class="chunk" id="unnamed-chunk-528"><div class="rcode"><div class="source"><pre class="knitr r">n <- 1e5
df <- data.frame(matrix(runif(n * 100), ncol = 100))
x <- df[[1]]
x_ran <- sample(n, 1e3)

microbenchmark(
  x[x_ran],
  df[x_ran, 1],
  df[[1]][x_ran],
  df$X1[x_ran],
  df[["X1"]][x_ran],
  .subset2(df, 1)[x_ran],
  .subset2(df, "X1")[x_ran]
)
</pre></div>

<div class="output"><pre class="knitr r">## Unit: microseconds
##                       expr min lq median uq max neval
##                   x[x_ran]  14 16   17.0 17  40   100
##               df[x_ran, 1]  50 52   53.5 58  93   100
##             df[[1]][x_ran]  24 25   26.0 27  52   100
##               df$X1[x_ran]  16 17   18.0 19  89   100
##          df[["X1"]][x_ran]  25 26   27.0 28  53   100
##     .subset2(df, 1)[x_ran]  10 11   11.0 12  35   100
##  .subset2(df, "X1")[x_ran]  10 11   11.0 12  24   100
</pre></div>

<p></div></div></p>

<p>Again, the units are in microseconds, so you only need to care if you&#39;re doing hundreds of thousands of data frame subsets - but for plyr I am doing that so I do care.</p>

<h3>Vectorised operations on a data frame</h3>

<div class="chunk" id="unnamed-chunk-529"><div class="rcode"><div class="source"><pre class="knitr r">df <- data.frame(a = 1:10, b = -(1:10))
l <- list(0, 10)
l_2 <- list(rep(0, 10), rep(10, 10))
m <- matrix(c(0, 10), ncol = 2, nrow = 10, byrow = TRUE)
df_2 <- as.data.frame(m)
v <- as.numeric(m)

microbenchmark(
  df + v,
  df + l,
  df + l_2,
  df + m,
  df + df_2
)
</pre></div>

<div class="output"><pre class="knitr r">## Unit: microseconds
##       expr min  lq median  uq  max neval
##     df + v 606 636    646 655  851   100
##     df + l 416 430    444 460 3352   100
##   df + l_2 421 434    452 462 3380   100
##     df + m 611 634    644 653 3499   100
##  df + df_2 450 472    484 494  712   100
</pre></div>

<p></div></div></p>

<h2>Timing</h2>

<h2>Performance testing</h2>

<h2>Memory profiling</h2>

<p><code>object.size</code></p>

<p>There are three ways to explore memory usage:</p>

<ul>
<li><code>tracemem</code></li>
<li><code>Rprof</code> + <code>memory</code></li>
<li><code>Rprofmem</code></li>
</ul>

<h1>Performance</h1>

<p>General techniques for improving performance</p>

<h2>Brainstorming</h2>

<p>Most important step is to brainstorm as many possible alternative approaches.</p>

<p>Good to have a variety of approaches to call upon.  </p>

<ul>
<li>Read blogs</li>
<li>Algorithm/data structure courses (<a href="https://www.coursera.org/course/algs4partI">https://www.coursera.org/course/algs4partI</a>)</li>
<li>Book</li>
<li>Read R code</li>
</ul>

<p>We introduce a few at a high-level in the Rcpp chapter.</p>

<h2>Caching</h2>

<p><code>readRDS</code>, <code>saveRDS</code>, <code>load</code>, <code>save</code></p>

<p>Caching packages</p>

<h3>Memoisation</h3>

<p>A special case of caching is memoisation.</p>

<h3>Modifying in place vs. modifying a copy</h3>

<pre><code class="R">library(pryr)
x &lt;- 1:5
address(x)
x[2] &lt;- 3L
address(x)

# Assigning in a real number forces conversion of x to real
x[2] &lt;- 3
address(x)

# Modifying class or other attributes modifies in place
attr(x, &quot;a&quot;) &lt;- &quot;a&quot;
class(x) &lt;- &quot;b&quot;
address(x)

# But making a reference to x elsewhere, will create a modified
# copy when you modify x - no longer modifies in place
y &lt;- x
x[1] &lt;- 2
address(x)
</code></pre>

<h2>Byte code compilation</h2>

<p>R 2.13 introduced a new byte code compiler which can increase the speed of certain types of code 4-5 fold. This improvement is likely to get better in the future as the compiler implements more optimisations - this is an active area of research.</p>

<p>Using the compiler is an easy way to get speed ups - it&#39;s easy to use, and if it doesn&#39;t work well for your function, then you haven&#39;t invested a lot of time in it, and so you haven&#39;t lost much.</p>

<h2>Other people&#39;s code</h2>

<p>One of the easiest ways to speed up your code is to find someone who&#39;s already done it! Good idea to search for CRAN packages.</p>

<pre><code>RppGSL, RcppEigen, RcppArmadillo
</code></pre>

<p>Stackoverflow can be a useful place to ask.</p>

<h3>Important vectorised functions</h3>

<p>Not all base functions are fast, but many are. And if you can find the one that best matches your problem you may get big improvements</p>

<pre><code>cumsum, diff
rowSums, colSums, rowMeans, colMeans
rle
match
duplicated
</code></pre>

<p>Read the source code - implementation in C is usually correlated with high performance.</p>

<h2>Rewrite in a lower-level language</h2>

<p>C, C++ and Fortran are easy. C++ easiest, recommended, and described in the following chapter.</p>

<h1>High performance functions with Rcpp</h1>

<p>Sometimes R code just isn&#39;t fast enough - you&#39;ve used profiling to find the bottleneck, but there&#39;s simply no way to make the code any faster. This chapter is the answer to that problem. You&#39;ll learn how to rewrite key functions in C++ to get much better performance, while not taking too much longer to write. The key to this magic is <a href="http://dirk.eddelbuettel.com/code/rcpp.html">Rcpp</a>, a fantastic tool written by Dirk Eddelbuettel and Romain Francois (with key contributions by Doug Bates, John Chambers and JJ Allaire), that makes it dead simple to connect C++ to R. It is <em>possible</em> to write C or Fortran code for use in R, but it will be painful; Rcpp provides a clean, approachable API that lets you write high-performance code, insulated from R&#39;s arcane C API.</p>

<p>Typical bottlenecks that C++ can help with are:</p>

<ul>
<li><p>Loops that can&#39;t easily be vectorised because each iteration depends on the previous. C++ modifies objects in place, so there is little overhead when modifying a data structure many times.</p></li>
<li><p>Recursive functions, or problems which involve calling functions millions of times. The overhead of calling a function in C++ is much lower than the overhead of calling a function in R.  To give you some idea of the magnitude, on my computer when writing this book the overhead in C++ was ~5ns compared to ~200ns for R.</p></li>
<li><p>Problems that require advanced data structures and algorithms that R doesn&#39;t provide. Through the standard template library (STL), C++ has efficient implementations of many important data structures, from ordered maps to double ended queues.</p></li>
</ul>

<p>Rewriting a function in C++ can lead to a 2-3 order of magnitude speed up, but most improvements will be more modest. While pure R code is relatively slow compared to C or C++, many bottlenecks in base R have already been replaced with hand-written C functions. This means that if your function already uses vectorised operations, you are unlikely to see a large improvement in performance. Note, however, that if you do rewrite a base C function with Rcpp, it&#39;s likely to be much shorter, because you can use the more sophisticated tools provided by C++.</p>

<p>The aim of this chapter is to give you the absolute necessities of C++ and Rcpp.
A working knowledge of C++ is helpful, but not essential. Many good tutorials and references are freely available, including [<a href="http://www.learncpp.com/">http://www.learncpp.com/</a>] and [<a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a>]. For more advanced topics, the &quot;Effective C++&quot; series by Scott Meyers is popular choice. Dirk Eddelbuettel has written an entire book on Rcpp, <a href="http://www.springer.com/statistics/computational+statistics/book/978-1-4614-6867-7">&quot;Seamless R and C++ integration with Rcpp&quot;</a>, which provides much more detail than we can here. If you&#39;re serious about Rcpp, make sure to get that book!</p>

<p>In this chapter you&#39;ll learn:</p>

<ul>
<li>How to write C++ code by seeing R functions and their C++ equivalents.</li>
<li>Important Rcpp classes and methods</li>
<li>How to use Rcpp &quot;sugar&quot; to avoid C++ loops and convert directly from vectorised R code</li>
<li>How to work with missing values</li>
<li>Some of the most important techniques, data structures and algorithms from standard template library (STL)</li>
</ul>

<p>The chapter concludes with a selection of real case studies showing how others have used C++ and Rcpp to speed up their slow R code.</p>

<h2>Getting started</h2>

<p>All examples in this chapter need at least version 0.10.1 of the <code>Rcpp</code> package. This version includes <code>cppFunction</code> and <code>sourceCpp</code>, which makes it very easy to connect C++ to R. You&#39;ll also (obviously!) need a working C++ compiler.  </p>

<p><code>cppFunction</code> allows you to write C++ functions in R like this:</p>

<div class="chunk" id="unnamed-chunk-530"><div class="rcode"><div class="source"><pre class="knitr r">library(Rcpp)
cppFunction('
  int add(int x, int y, int z) {
    int sum = x + y + z;
    return sum;
  }'
)
add # like a regular R function, printing displays info about the function
</pre></div>

<div class="output"><pre class="knitr r">## function (x, y, z) 
## .Primitive(".Call")(<pointer: 0x2aaab88a2420>, x, y, z)
</pre></div>

<div class="source"><pre class="knitr r">add(1, 2, 3)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 6
</pre></div>

<p></div></div></p>

<p>When you run this code, Rcpp will compile the C++ code and construct an R function that connects to the compiled C++ function. If you&#39;re familiar with <code>inline::cxxfunction</code>, <code>cppFunction</code> is similar, except that you specify the function completely in the string, and it parses the C++ function arguments to figure out what the R function arguments should be.</p>

<h2>Getting starting with C++</h2>

<p>C++ is a large language, and there&#39;s no way to cover it exhaustively here.  Our aim here is to give you the basics so you can start writing useful functions that allow you to speed up slow parts of your R code.  We&#39;ll spend minimal time on advanced features like object oriented programming and templates, because our focus is not on writing big programs in C++, just small, self-contained function.</p>

<p>The following section shows the basics of C++ by translating simple R functions to their R equivalents. We&#39;ll start simple with a function that has no inputs and a scalar output, and then get progressively more complicated:</p>

<ul>
<li>Scalar input and scalar output</li>
<li>Vector input and scalar output</li>
<li>Vector input and vector output</li>
<li>Matrix input and vector output</li>
</ul>

<h3>No inputs, scalar output</h3>

<p>Let&#39;s start with a very simple function. It has no arguments and always returns the integer 1:</p>

<div class="chunk" id="unnamed-chunk-531"><div class="rcode"><div class="source"><pre class="knitr r">one <- function() 1L
</pre></div>

<p></div></div></p>

<p>The equivalent C++ function is: </p>

<pre><code class="c++">int one() {
  return 1;
}
</code></pre>

<p>We can compile and use this from R with <code>cppFunction</code></p>

<div class="chunk" id="unnamed-chunk-532"><div class="rcode"><div class="source"><pre class="knitr r">cppFunction('
  int one() {
    return 1;
  }
')
</pre></div>

<p></div></div></p>

<p>This small function illustrates a number of important differences between R and C++:</p>

<ul>
<li><p>The syntax to create a function looks like the syntax to call a function; you don&#39;t use assignment to create functions like in R.</p></li>
<li><p>You must declare the type of output the function returns. This function returns an <code>int</code> (a scalar integer). The classes for the most common types of R vectors are: <code>NumericVector</code>, <code>IntegerVector</code>, <code>CharacterVector</code> and <code>LogicalVector</code>.</p></li>
<li><p>Scalars and vectors are different. The scalar equivalents of numeric, integer, character and logical vectors are: <code>double</code>, <code>int</code>, <code>String</code> and <code>bool</code>. </p></li>
<li><p>You must use an explicit <code>return</code> statement to return a value from the function.</p></li>
<li><p>Every statement is terminated by a <code>;</code>.</p></li>
</ul>

<h3>Scalar input, scalar output</h3>

<p>The next example function makes things a little more complicated by implementating a scalar version of the <code>sign</code> function which returns 1 if the input is positive, and -1 if it&#39;s negative:</p>

<div class="chunk" id="unnamed-chunk-533"><div class="rcode"><div class="source"><pre class="knitr r">signR <- function(x) {
  if (x > 0) {
    1
  } else if (x == 0) {
    0
  } else {
    -1
  }
}

cppFunction('
  int signC(int x) {
    if (x > 0) {
      return 1;
    } else if (x == 0) {
      return 0;
    } else {
      return -1;
    }
  }'
)
</pre></div>

<p></div></div></p>

<p>In the C++ version:</p>

<ul>
<li><p>we declare the type of each input in the same way we declare the type of the output. While this makes the code a little more verbose, it also makes it very obvious what type of input the function needs. Similarly to S3 and S4 in R, C++ allows you to write different functions with the same name that have different inputs (number or type). </p></li>
<li><p>the <code>if</code> syntax is identical - while there are some big differences between R and C++, there are also lots of similarities!  C++ also has a <code>while</code> statement that works the same way as R&#39;s.  You can also use <code>break</code>, but use <code>continue</code>  instead of <code>next</code>.</p></li>
</ul>

<h3>Vector input, scalar output</h3>

<p>One big difference between R and C++ is that the cost of loops is much lower.  For example, we could implement the <code>sum</code> function in R using a loop. If you&#39;ve been programming in R a while, you&#39;ll probably have a visceral reaction to this function!</p>

<div class="chunk" id="unnamed-chunk-534"><div class="rcode"><div class="source"><pre class="knitr r">sumR <- function(x) {
  total <- 0
  for (i in seq_along(x)) {
    total <- total + x[i]
  }
  total
}
</pre></div>

<p></div></div></p>

<p>In C++, loops have very little overhead, so it&#39;s fine to use them (later, we&#39;ll see alternatives to <code>for</code> loops that more clearly express your intent; they&#39;re not faster, but they can make your code easier to understand).</p>

<div class="chunk" id="unnamed-chunk-535"><div class="rcode"><div class="source"><pre class="knitr r">cppFunction('
  double sumC(NumericVector x) {
    int n = x.size();
    double total = 0;
    for(int i = 0; i < n; ++i) {
      total += x[i];
    }
    return total;
  }
')
</pre></div>

<p></div></div></p>

<p>The C++ version is similar, but:</p>

<ul>
<li><p>To find the length of the vector, we use the <code>size()</code> method, which returns an integer. Again, whenever we create a new variable we have to tell C++ what type of object it will hold. An <code>int</code> is a scalar integer, but we could have used <code>double</code> for a scalar numeric, <code>bool</code> for a scalar logical, or a <code>String</code> for a scalar string.</p></li>
<li><p>The <code>for</code> statement has a different syntax: <code>for(intialisation; condition; increase)</code>. The initialise component creates a new variable called <code>i</code> and sets it equal to 0. The condition is checked in each iteration of the loop: the loop is continues while it&#39;s <code>true</code>. The increase statement is run after each loop iteration, but before the condition is checked. Here we use the special prefix operator <code>++</code> which increases the value of <code>i</code> by 1.</p></li>
<li><p>Vectors in C++ start at 0. I&#39;ll say this again because it&#39;s so important: VECTORS IN C++ START AT 0! This is a very common source of bugs when converting R functions to C++.</p></li>
<li><p>We can&#39;t use <code>&lt;-</code> (or <code>-&gt;</code>) for assignment, but instead use <code>=</code>.</p></li>
<li><p>We can take advantage of the in-place modification operators: <code>total += x[i]</code> is equivalent to <code>total = total + x[i]</code>.  Similar in-place operators are <code>-=</code>, <code>*=</code> and <code>/=</code>.  This is known as a side-effect, where the function <code>++</code> or <code>+=</code> modifies its argument <code>i</code> or <code>x</code> without us asking. Functions in R rarely have side-effects, and we need to be careful that our Rcpp functions don&#39;t modify their inputs. More on that later.</p></li>
</ul>

<p>This is a good example of where C++ is much more efficient than the R equivalent. As shown by the following microbenchmark, our <code>sumC</code> function is competitive with the built-in (and highly optimised) <code>sum</code> function, while <code>sumR</code> is several orders of magnitude slower.</p>

<div class="chunk" id="unnamed-chunk-536"><div class="rcode"><div class="source"><pre class="knitr r">library(microbenchmark)
x <- runif(1e3)
microbenchmark(
  sum(x),
  sumR(x),
  sumC(x)
)
</pre></div>

<div class="output"><pre class="knitr r">## Unit: microseconds
##     expr min  lq median   uq  max neval
##   sum(x)   9   9     10   10   17   100
##  sumR(x) 949 973    996 1024 4162   100
##  sumC(x)   3   4      5    6   24   100
</pre></div>

<p></div></div></p>

<h3>Vector input, vector output</h3>

<p>For our next example, we&#39;ll create a function that computes the distance between one value and a vector of other values:</p>

<div class="chunk" id="unnamed-chunk-537"><div class="rcode"><div class="source"><pre class="knitr r">pdistR <- function(x, ys) {
  sqrt( (x - ys) ^ 2 )
}
</pre></div>

<p></div></div></p>

<p>From the function definition, it&#39;s not obvious that we want <code>x</code> to be a scalar - that&#39;s something we&#39;d need to mention in the documentation. That&#39;s not a problem in the C++ version:</p>

<div class="chunk" id="unnamed-chunk-538"><div class="rcode"><div class="source"><pre class="knitr r">cppFunction('
  NumericVector pdistC(double x, NumericVector ys) {
    int n = ys.size();
    NumericVector out(n);

    for(int i = 0; i < n; ++i) {
      out[i] = sqrt(pow(ys[i] - x, 2.0));
    }
    return out;
  }
')
</pre></div>

<p></div></div></p>

<p>This function introduces only a few new concepts:</p>

<ul>
<li><p>We create a new numeric vector of length <code>n</code> with a constructor: <code>NumericVector out(n)</code>.  Another useful way of making a vector is to copy an existing vector: <code>NumericVector zs = clone(ys)</code>.</p></li>
<li><p>C++ doesn&#39;t use <code>^</code> for exponentiation, it instead uses the <code>pow</code> function.</p></li>
</ul>

<p>Note that because the R function is fully vectorised, it is already going to be fast. On my computer, it takes around 8 ms with a 1 million element <code>y</code> vector. The C++ function is twice as fast, ~4 ms, but assuming it took you 10 minutes to write the C++ function, you&#39;d need to run it ~150,000 times to make it a net saver of time. The reason why the C++ function is faster is subtle, and relates to memory management. The R version needs to create an intermediate vector the same length as y (<code>x - ys</code>), and allocating memory is an expensive operation. The C++ function avoids this overhead because it uses an intermediate scalar.</p>

<p>In the sugar section, you&#39;ll see how to rewrite this function to take advantage of Rcpp&#39;s vectorised operations so that the C++ code is barely longer than the R code.</p>

<h3>Matrix input, vector output</h3>

<p>Each vector type also has a matrix equivalent: <code>NumericMatrix</code>, <code>IntegerMatrix</code>, <code>CharacterMatrix</code> and <code>LogicalMatrix</code>. Using them is straightforward. For example, we could create a function that reproduces <code>rowSums</code>:</p>

<div class="chunk" id="unnamed-chunk-539"><div class="rcode"><div class="source"><pre class="knitr r">cppFunction('
  NumericVector rowSumsC(NumericMatrix x) {
    int nrow = x.nrow(), ncol = x.ncol();
    NumericVector out(nrow);

    for (int i = 0; i < nrow; i++) {
      double total = 0;
      for (int j = 0; j < ncol; j++) {
        total += x(i, j);
      }
      out[i] = total;
    }
    return out;
  }
')
x <- matrix(sample(100), 10)
rowSums(x)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 424 548 534 344 636 505 402 517 477 663
</pre></div>

<div class="source"><pre class="knitr r">rowSumsC(x)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 424 548 534 344 636 505 402 517 477 663
</pre></div>

<p></div></div></p>

<p>The main thing to notice is that when subsetting a matrix we use <code>()</code> and not <code>[]</code>, and that matrix objects have <code>nrow()</code> and <code>ncol()</code> methods. </p>

<h3>Using sourceCpp</h3>

<p>To simplify the initial presentation the examples in this section have used inline C++ via <code>cppFunction</code>. For real problems, it&#39;s usually easier to use standalone C++ files and then source them into R using the <code>sourceCpp</code> function. This will enable you to take advantage of text editor support for C++ files (e.g. syntax highlighting) as well as make it easier to identify the line numbers of compilation errors. Standalone C++ files can also contain embedded R code in special C++ comment blocks. This is really convenient if you want to run some R test code. </p>

<p>Your standalone C++ file should have extension <code>.cpp</code>, and needs to start with:</p>

<pre><code class="cpp">#include &lt;Rcpp.h&gt;
using namespace Rcpp;
</code></pre>

<p>And for each function that you want availble within R, you need to prefix it with:</p>

<pre><code class="cpp">// [[Rcpp::export]]
</code></pre>

<p>(Note that the space is mandatory)</p>

<p>(This is somewhat similar to roxygen2&#39;s <code>@export</code> tag, but <code>Rcpp::export</code> controls whether a function is exported from C++ to R, where <code>@export</code> controls whether a function is exported from a package and made available to a package user.)</p>

<p>Then using <code>sourceCpp(&quot;path/to/file.cpp&quot;)</code> will compile the C++ code, create the matching R functions and add them to your current session.  (Note that these functions will not persist across <code>save()</code> and <code>load()</code>, such as when you restore your workspace.)</p>

<p>For example, running <code>sourceCpp</code> on the following file first compiles the C++ code and then compares it to native equivalent:</p>

<pre><code class="cpp">#include &lt;Rcpp.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
double meanC(NumericVector x) {
  int n = x.size();
  double total = 0;

  for(int i = 0; i &lt; n; ++i) {
    total += x[i] / n;
  }
  return total;
}

/*** R 
  library(microbenchmark)
  x &lt;- runif(1e5)
  microbenchmark(
    mean(x),
    meanC(x))
*/
</code></pre>

<p>The R code is run with <code>source(echo = TRUE)</code> so you don&#39;t need to explicitly print output. </p>

<p>For the remainder of this chapter C++ code will typically be presented standalone rather than wrapped in a call to <code>cppFunction</code>. If you want to try compiling and/or modifying the examples you should paste them into a C++ source file that includes the elements described above.</p>

<h3>Exercises</h3>

<p>With the basics of C++ in hand, now is a great time to practice by reading and writing some simple C++ functions.  </p>

<p>For each of the following C++ functions, read the code and figure out what base R function it corresponds to.  You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.</p>

<pre><code class="cpp">double f1(NumericVector x) {
  int n = x.size();
  double y = 0;

  for(int i = 0; i &lt; n; ++i) {
    y += x[i] / n;
  }
  return y;
}

NumericVector f2(NumericVector x) {
  int n = x.size();
  NumericVector out(n);

  out[0] = x[0];
  for(int i = 1; i &lt; n; ++i) {
    out[i] = out[i - 1] + x[i];
  }
  return out;
}

bool f3(LogicalVector x) {
  int n = x.size();

  for(int i = 0; i &lt; n; ++i) {
    if (x[i]) return true;
  }
  return false;
}

int f4(Function pred, List x) {
  int n = x.size();

  for(int i = 0; i &lt; n; ++i) {
    LogicalVector res = pred(x[i]);
    if (res[0]) return i + 1;
  }
  return 0;
}

NumericVector f5(NumericVector x, NumericVector y) {
  int n = std::max(x.size(), y.size());
  NumericVector x1 = rep_len(x, n);
  NumericVector y1 = rep_len(y, n);

  NumericVector out(n);

  for (int i = 0; i &lt; n; ++i) {
    out[i] = std::min(x1[i], y1[i]);
  }

  return out;
}
</code></pre>

<p>To practice your function writing skills, convert the following functions into C++.  For now, assume the inputs have no missing values.</p>

<ul>
<li><p><code>all</code></p></li>
<li><p><code>cumprod</code>, <code>cummin</code>, <code>cummax</code>.</p></li>
<li><p><code>diff</code>. Start by assuming lag 1, and then generalise for lag n.</p></li>
<li><p><code>range</code>. </p></li>
<li><p><code>var</code>.  Read about the approaches you can take at <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">wikipedia</a>.  Whenever implementing a numerical algorithm it&#39;s always good to check what is already known about the problem.</p></li>
</ul>

<h2>Rcpp classes and methods</h2>

<p>You&#39;ve already seen the basic vector classes (<code>IntegerVector</code>, <code>NumericVector</code>, <code>LogicalVector</code>, <code>CharacterVector</code>) and their scalar (<code>int</code>, <code>double</code>, <code>bool</code>, <code>String</code>) and matrix (<code>IntegerMatrix</code>, <code>NumericMatrix</code>, <code>LogicalMatrix</code>, <code>CharacterMatrix</code>) equivalents. </p>

<p>All R objects have attributes, which can be queried and modified with the <code>attr</code> method.  Rcpp also provides a <code>names()</code> method for the commonly used attribute: <code>attr(&quot;names&quot;)</code>. The following code snippet illustrates these methods.  Note the use of the <code>create()</code> class method to easily create an R vector from C++ scalar values.</p>

<pre><code class="cpp">// [[Rcpp::export]]
NumericVector attribs() {
  NumericVector out = NumericVector::create(1, 2, 3);

  out.names() = CharacterVector::create(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
  out.attr(&quot;my-attr&quot;) = &quot;my-value&quot;;
  out.attr(&quot;class&quot;) = &quot;my-class&quot;;

  return out;
}
</code></pre>

<p>You can use the <code>slot()</code> method in a similar way to get and set slots of S4 objects.</p>

<p>Rcpp also provides classes <code>List</code> and <code>DataFrame</code>. These are more useful for output than input, because lists and data frames can contain arbitrary classes, and this does not fit well with C++&#39;s desire to have the types of all inputs known in advance. If, however, the list is an S3 object with components of known types, you can extract the components and manually convert to their C++ equivalents with <code>as</code>. </p>

<p>For example, the linear model objects that <code>lm</code> produces are lists and the components are always of the same type. The following code illustrates how you might component the mean percentage error (<code>mpe</code>) of a linear model.  This isn&#39;t a very good example for when you might use C++ (because it&#39;s so easily implemented in R), but it illustrates how to pull out the components of a list. Note the use of the <code>inherits()</code> method and the <code>stop()</code> function to check that the object really is a linear model.</p>

<pre><code class="cpp">// [[Rcpp::export]]
double mpe(List mod) {
  if (!mod.inherits(&quot;lm&quot;)) stop(&quot;Input must be a linear model&quot;);

  NumericVector resid = as&lt;NumericVector&gt;(mod[&quot;residuals&quot;]);
  NumericVector fitted = as&lt;NumericVector&gt;(mod[&quot;fitted.values&quot;]);

  int n = resid.size();
  double err = 0;
  for(int i = 0; i &lt; n; ++i) {
    err += resid[i] / (fitted[i] + resid[i]);
  }
  return err / n;
}

/*** R
  mod &lt;- lm(mpg ~ wt, data = mtcars)
  mpe(mod)
*/
</code></pre>

<p>It is possible to write code that works differently depending on the type of the R input, but it is beyond the scope of this book.</p>

<p>You can put R functions in an object of type <code>Function</code>. Calling an R function from C++ is straightforward. The string constructor of the function object will look for a function of that name in the global environment.</p>

<pre><code class="cpp">Function assign(&quot;assign&quot;);
</code></pre>

<p>You can call functions with arguments specified by position:</p>

<pre><code class="cpp">assign(&quot;y&quot;, 1);
</code></pre>

<p>Or by name, with a special syntax:</p>

<pre><code class="cpp">assign(_[&quot;x&quot;] = &quot;y&quot;, _[&quot;value&quot;] = 1);
</code></pre>

<p>The challenge is storing the output. If you don&#39;t know in advance what the output will be, store it in an <code>RObject</code> or in components of a <code>List</code>. For example, the following code is a basic implementation of <code>lapply</code> in C++:</p>

<pre><code class="cpp">// [[Rcpp::export]]
List lapply1(List input, Function f) {
  int n = input.size();
  List out(n);

  for(int i = 0; i &lt; n; i++) {
    out[i] = f(input[i]);
  }

  return out;
}

/*** R
  lapply1(1:10, sqrt)
  lapply1(list(&quot;a&quot;, 1, F), class)
*/
</code></pre>

<p>There are also classes for many more specialised language objects: <code>Environment</code>, <code>ComplexVector</code>, <code>RawVector</code>, <code>DottedPair</code>, <code>Language</code>,  <code>Promise</code>, <code>Symbol</code>, <code>WeakReference</code> and so on. These are beyond the scope of this chapter and won&#39;t be discussed further.</p>

<h2>Rcpp sugar</h2>

<p>Rcpp provides a lot of &quot;sugar&quot;, C++ functions that work very similarly to their R equivalents. (The main difference is that they don&#39;t recycle their inputs - you need to do that yourself). Rcpp sugar makes it possible to write efficient C++ code that looks almost identical to the R equivalent. If a sugar version of the function you&#39;re interested exists, you should use it: it&#39;s expressive and well tested. Sugar functions aren&#39;t always faster than your hand-written equivalent, but they will get faster as more time is spent on optimising Rcpp.</p>

<p>Sugar functions can be roughly broken down into</p>

<ul>
<li>arithmetic and logical operators</li>
<li>logical summary functions</li>
<li>vector views</li>
<li>other useful functions</li>
</ul>

<h3>Arithmetic and logical operators</h3>

<p>All the basic arithmetic and logical operators are vectorised: <code>+</code> <code>*</code>, <code>-</code>, <code>/</code>, <code>pow</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>!</code>.  For example, we could use sugar to considerably simplify the implementation of our <code>pdistC</code> function.  (If you don&#39;t remember I&#39;ve included the R version of <code>pdistC</code>, <code>pdistR</code>, as well.  Note the similarities with the Rcpp sugar version.)</p>

<pre><code class="r">pdistR &lt;- function(x, ys) {
  (x - ys) ^ 2
}
</code></pre>

<pre><code class="cpp">// [[Rcpp::export]]
NumericVector pdistC2(double x, NumericVector ys) {
  return pow((x - ys), 2);
}
</code></pre>

<h3>Logical summary functions</h3>

<p>The sugar function <code>any</code> and <code>all</code> are fully lazy, so that e.g <code>any(x == 0)</code> might only need to evaluate one element of the value, and return a special type that can be converted into a <code>bool</code> using <code>is_true</code>, <code>is_false</code>, or <code>is_na</code>.  </p>

<p>For example, we could use this to write an efficient funtion to determine whether or not a numeric vector contains any missing values. In R we could do <code>any(is.na(x))</code>:</p>

<pre><code class="r">any_naR &lt;- function(x) any(is.na(x))
</code></pre>

<p>However that will do almost the same amount of work whether there&#39;s a missing value in the first position or the last. Here&#39;s the C++ implementation:</p>

<pre><code class="cpp">// [[Rcpp::export]]
bool any_naC(NumericVector x) {
  return is_true(any(is_na(x)));
}
</code></pre>

<p>Our C++ <code>any_naC</code> function is slightly slower than <code>any_naR</code> when there are no missing values, or the missing value is at the end, but it&#39;s much faster when the first value is missing. </p>

<pre><code class="r">library(microbenchmark)
x0 &lt;- runif(1e5)
x1 &lt;- c(x0, NA)
x2 &lt;- c(NA, x0)

microbenchmark(
  any_naR(x0), any_naC(x0),
  any_naR(x1), any_naC(x1),
  any_naR(x2), any_naC(x2))
</code></pre>

<h3>Vector views</h3>

<p>A number of helpful functions provide a &quot;view&quot; of a vector: <code>head</code>, <code>tail</code>, <code>rep_each</code>, <code>rep_len</code>, <code>rev</code>, <code>seq_along</code>, <code>seq_len</code>. In R these would all produce copies of the vector, but in Rcpp they simply point to the existing vector and override the subsetting operator (<code>[</code>) to implement special behaviour. This makes them very efficient: <code>rep_len(x, 1e6)</code> does not have to make a million copies of x. </p>

<h3>Other useful functions</h3>

<p>Finally, there are a grab bag of sugar functions that mimic frequently used R functions:</p>

<ul>
<li><p>Math functions: <code>abs</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>beta</code>, <code>ceil</code>, <code>ceiling</code>, <code>choose</code>, <code>cos</code>, <code>cosh</code>, <code>digamma</code>, <code>exp</code>, <code>expm1</code>, <code>factorial</code>, <code>floor</code>, <code>gamma</code>, <code>lbeta</code>, <code>lchoose</code>, <code>lfactorial</code>, <code>lgamma</code>, <code>log</code>, <code>log10</code>, <code>log1p</code>, <code>pentagamma</code>, <code>psigamma</code>, <code>round</code>, <code>signif</code>, <code>sin</code>, <code>sinh</code>, <code>sqrt</code>, <code>tan</code>, <code>tanh</code>, <code>tetragamma</code>, <code>trigamma</code>, <code>trunc</code>, </p></li>
<li><p>Scalar summaries: <code>mean</code>, <code>min</code>, <code>max</code>, <code>range</code>, <code>sum</code>, <code>sd</code> and <code>var</code>.</p></li>
<li><p>Vector summaries: <code>cumsum</code>, <code>diff</code>, <code>pmin</code>, and <code>pmax</code></p></li>
<li><p>Finding values: <code>match</code>, <code>self_match</code>, <code>which_max</code>, <code>which_min</code></p></li>
<li><p><code>duplicated</code>, <code>unique</code></p></li>
<li><p><code>d/q/p/r</code> for all standard distributions in R.</p></li>
<li><p><code>noNA(x)</code>: this asserts that the vector <code>x</code> does not contain any missing values, and allows optimisation of some mathematical operations.</p></li>
</ul>

<h2>Missing values</h2>

<p>If you&#39;re working with missing values, you need to know two things:</p>

<ul>
<li>how R&#39;s missing values behave in C++&#39;s scalars (e.g. <code>double</code>)</li>
<li>how to get and set missing values in vectors (e.g. <code>NumericVector</code>)</li>
</ul>

<h3>Scalars</h3>

<p>The following code explores what happens when you take one of R&#39;s missing values, coerce it into a scalar, and then coerce back to an R vector. This is a generally useful technique: if you don&#39;t know what an operation will do, design an experiment to figure it out.</p>

<pre><code class="cpp">// [[Rcpp::export]]
List scalar_missings() {
  int int_s = NA_INTEGER;
  String chr_s = NA_STRING;
  bool lgl_s = NA_LOGICAL;
  double num_s = NA_REAL;

  return List::create(int_s, chr_s, lgl_s, num_s);
}

/*** R
  str(scalar_missings())
*/
</code></pre>

<p>Things look pretty good here: with the exception of <code>bool</code>, all of the missing values have been preserved. </p>

<h4>Integers</h4>

<p>However, things are not quite as they seem for integers. Missing values are stored as the smallest integer so stored so if you don&#39;t do anything to them, they&#39;ll be preserved, but C++ doesn&#39;t know that the smallest integer has special behaviour so if you do anything with it you&#39;re likely to get an incorrect value: <code>evalCpp(&#39;NA_INTEGER + 1&#39;)</code> gives -2147483647.</p>

<p>If you want to work with missing values in integers, either use length one <code>IntegerVectors</code> or be very careful with your code.</p>

<h4>Doubles</h4>

<p>If you&#39;re working with doubles, you may be able to get away with ignoring missing values and working with NaN (not a number). R&#39;s missing values are a special type of the IEEE 754 floating point number NaN. That means if you coerce them to <code>double</code> in your C++ code, they will behave like regular NaN&#39;s. That means, in a logical context they always evaluate to FALSE:</p>

<pre><code class="r">evalCpp(&quot;NAN == 1&quot;)
evalCpp(&quot;NAN &lt; 1&quot;)
evalCpp(&quot;NAN &gt; 1&quot;)
evalCpp(&quot;NAN == NAN&quot;)
</code></pre>

<p>But be careful when combining then with boolean values:</p>

<pre><code class="r">evalCpp(&quot;NAN &amp;&amp; TRUE&quot;)
evalCpp(&quot;NAN || FALSE&quot;)
</code></pre>

<p>In numeric contexts, they propagate similarly to NA in R:</p>

<pre><code class="r">evalCpp(&quot;NAN + 1&quot;)
evalCpp(&quot;NAN - 1&quot;)
evalCpp(&quot;NAN / 1&quot;)
evalCpp(&quot;NAN * 1&quot;)
</code></pre>

<h3>Strings</h3>

<p><code>String</code> is an scalar string class introduced by Rcpp, so it knows how to deal with missing values.</p>

<h3>Boolean</h3>

<p>C++&#39;s <code>bool</code> only stores two values (TRUE or FALSE), but R&#39;s logical vector has three possible values (TRUE, FALSE and NA). If you coerce a length 1 logical vector, first make sure it doesn&#39;t contain any missing values otherwise they will be converted to TRUE.</p>

<h3>Vectors</h3>

<p>To set a missing value in a vector, you need to use a missing value specific to the type of vector. Unfortunately these are not named terribly consistently:</p>

<pre><code class="cpp">// [[Rcpp::export]]
List missing_sampler() {
  return(List::create(
    NumericVector::create(NA_REAL), 
    IntegerVector::create(NA_INTEGER),
    LogicalVector::create(NA_LOGICAL), 
    CharacterVector::create(NA_STRING)));
}

/*** R
  str(missing_sampler())
*/
</code></pre>

<p>To check if a value in a vector is missing, use the class method <code>is_na</code>:</p>

<pre><code class="cpp">// [[Rcpp::export]]
LogicalVector is_naC(NumericVector x) {
  int n = x.size();
  LogicalVector out(n);

  for (int i = 0; i &lt; n; ++i) {
    out[i] = NumericVector::is_na(x[i]);
  }
  return out;
}

/*** R
  is_naC(c(NA, 5.4, 3.2, NA))
*/
</code></pre>

<p>Another alternative is the similarly named sugar function <code>is_na</code>: it takes a vector and returns a logical vector.</p>

<pre><code class="cpp">// [[Rcpp::export]]
LogicalVector is_naC2(NumericVector x) {
  return is_na(x);
}

/*** R
is_naC2(c(NA, 5.4, 3.2, NA))
*/
</code></pre>

<h3>Exercises</h3>

<ul>
<li><p>Rewrite any of the functions from the first exercises to correctly deal with missing values. If <code>na.rm</code> is true, ignore the missing values. If <code>na.rm</code> is false, return missing values the first time a missing value is encountered. Some functions you can practice with are: <code>min</code>, <code>max</code>, <code>range</code>, <code>mean</code>, <code>var</code></p></li>
<li><p><code>cumsum</code> and <code>diff</code> need slightly more complicated behaviour for missing values.</p></li>
</ul>

<h2>The STL</h2>

<p>The real strength of C++ shows itself when you need to implement more complex algorithms. The standard template library (STL) provides set of extremely useful data structures and algorithms. This section will explain the most important algorithms and data structures and point you in the right direction to learn more.  We can&#39;t teach you everything you need to know about the STL, but hopefully the examples will at least show you the power of the STL, and persuade that it&#39;s useful to learn more. </p>

<p>If you need an algorithm or data structure that isn&#39;t implemented in STL, a good place to look is <a href="http://www.boost.org/doc/">boost</a>. Installing boost on to your computer is beyond the scope of this chapter, but once you have it installed, you can use <code>boost</code> data structures and algorithms by including the appropriate header file with (e.g.) <code>#include &lt;boost/array.hpp&gt;</code>.</p>

<h3>Using iterators</h3>

<p>Iterators are used extensively in the STL: many functions either accept or return iterators. They are the next step up from basic loops, abstracting away the details of the underlying data structure. Iterators have three main operators: they can be advanced with <code>++</code>, dereferenced (to get the value they refer to) with <code>*</code> and compared using <code>==</code>. For example we could re-write our sum function using iterators:</p>

<pre><code class="cpp">// [[Rcpp::export]]
double sum3(NumericVector x) {
  double total = 0;

  for(NumericVector::iterator it = x.begin(); it != x.end(); ++it) {
    total += *it;
  }
  return total;
}
</code></pre>

<p>The main changes are in the for loop:</p>

<ul>
<li><p>we start at <code>x.begin()</code> and loop until we get to <code>x.end()</code>. A small optimisiation is to store the value of the end iterator so we don&#39;t need to look it up each time. This only saves about 2 ns per iteration, so it&#39;s only important when the calculations in the loop are very simple.</p></li>
<li><p>instead of indexing into x, we use the dereference operator to get its current value: <code>*it</code>.</p></li>
<li><p>notice the type of the iterator: <code>NumericVector::iterator</code>.  Each vector type has its own iterator type: <code>LogicalVector::iterator</code>, <code>CharacterVector::iterator</code> etc.</p></li>
</ul>

<p>Iterators also allow us to use the C++ equivalents of the apply family of functions. For example, we could again rewrite <code>sum</code> to use the <code>accumulate</code> function, which takes an starting and ending iterator and adds all the values in between. The third argument to accumulate gives the initial value: it&#39;s particularly important because this also determines the data type that accumulate uses (here we use <code>0.0</code> and not <code>0</code> so that accumulate uses a <code>double</code>, not an <code>int</code>.).  To use <code>accumulate</code> we need to include the <code>&lt;numeric&gt;</code> header.</p>

<pre><code class="cpp">#include &lt;numeric&gt;

// [[Rcpp::export]]
double sum4(NumericVector x) {
  return std::accumulate(x.begin(), x.end(), 0.0);
}
</code></pre>

<p><code>accumulate</code> (along with the other functions in <code>&lt;numeric&gt;</code>, <code>adjacent_difference</code>, <code>inner_product</code> and <code>partial_sum</code>) are not that important in Rcpp because Rcpp sugar provides equivalents.</p>

<h3>Algorithms</h3>

<p>The <code>&lt;algorithm&gt;</code> header provides a large number of algorithms that work with iterators. For example, we could write a basic Rcpp version of <code>findInterval</code> that takes two arguments a vector of values and a vector of breaks - the aim is to find the bin that each x falls into. This shows off a few more advanced iterator features.  Read the code below and see if you can figure out how it works.</p>

<pre><code class="cpp">#include &lt;algorithm&gt;

// [[Rcpp::export]]
IntegerVector findInterval2(NumericVector x, NumericVector breaks) {
  IntegerVector out(x.size());

  NumericVector::iterator it, pos;
  IntegerVector::iterator out_it;

  for(it = x.begin(), out_it = out.begin(); it != x.end(); ++it, ++out_it) {
    pos = std::upper_bound(breaks.begin(), breaks.end(), *it);
    *out_it = std::distance(breaks.begin(), pos);
  }

  return out;
}
</code></pre>

<p>The key points are:</p>

<ul>
<li><p>We step through two iterators (input and output) simultaneously.  </p></li>
<li><p>We can assign into an dereferenced iterator (<code>out_it</code>) to change the values in <code>out</code>.</p></li>
<li><p><code>upper_bound</code> returns an iterator. If we wanted the value of the <code>upper_bound</code> we could dereference it; to figure out its location, we use the <code>distance</code> function.</p></li>
<li><p>Small note: if we want this function to be as fast as <code>findInterval</code> in R (which uses hand-written C code), we need to compute the calls to <code>.begin()</code> and <code>.end()</code> once and save the results.  This is easy, but it distracts from this example so it has been omitted.  Making this change yields a function that&#39;s slightly faster than R&#39;s <code>findInterval</code> function, but is about 1/10 of the code.</p></li>
</ul>

<p>It&#39;s generally better to use algorithms from the STL than hand rolled loops.  In &quot;Effective STL&quot;, Scott Meyer gives three reasons: efficiency, correctness and maintainability. Algorithms from the STL are written by C++ experts to be extremely efficient, and they have been around for a long time so they are well tested. Using standard algorithms also makes the intent of your code more clear, helping to make it more readable and more maintainable.</p>

<p>A good reference guide for algorithms is <a href="http://www.cplusplus.com/reference/algorithm/">http://www.cplusplus.com/reference/algorithm/</a></p>

<h3>Data structures</h3>

<p>The STL provides a large set of data structures: <code>array</code>, <code>bitset</code>, <code>list</code>, <code>forward_list</code>, <code>map</code>, <code>multimap</code>, <code>multiset</code>, <code>priority_queue</code>, <code>queue</code>, <code>dequeue</code>, <code>set</code>, <code>stack</code>, <code>unordered_map</code>, <code>unordered_set</code>, <code>unordered_multimap</code>, <code>unordered_multiset</code>, and <code>vector</code>.  The most important of these datastructures are the <code>vector</code>, the <code>unordered_set</code>, and the <code>unordered_map</code>.  We&#39;ll focus on these three in this section, but using the others is similar: they just have different performance tradeoffs. For example, the <code>deque</code> (pronounced &quot;deck&quot;) has a very similar interface to vectors but a different underlying implementation that has different performance trade-offs. You may want to try them for your problem.  A good reference for STL data structures is <a href="http://www.cplusplus.com/reference/stl/">http://www.cplusplus.com/reference/stl/</a> - I recommend you keep it open while working with the STL.</p>

<p>Rcpp knows how to convert from many STL data structures to their R equivalents, so you can return them from your functions without explicitly converting to R data structures. </p>

<h3>Vectors</h3>

<p>A stl vector is very similar to an R vector, except that it expands efficiently.  This makes vectors appropriate to use when you don&#39;t know in advance how big the output will be.  Vectors are templated, which means that you need to specify the type of object the vector will contain when you create it: <code>vector&lt;int&gt;</code>, <code>vector&lt;bool&gt;</code>, <code>vector&lt;double&gt;</code>, <code>vector&lt;String&gt;</code>.  You can access individual elements of a vector using the standard <code>[]</code> notation, and you can add a new element to the end of the vector using <code>.push_back()</code>.  If you have some idea in advance how big the vector will be, you can use <code>.reserve()</code> to allocate sufficient storage.</p>

<p>The following code implements run length encoding (<code>rle</code>). It produces two vectors of output: a vector of values, and a vector <code>lengths</code> giving how many times each element is repeated. It works by looping through the input vector <code>x</code> comparing each value to the previous: if it&#39;s the same, then it increments the last value in <code>lengths</code>; if it&#39;s different, it adds the value to the end of <code>values</code>, and sets the corresponding length to 1.</p>

<pre><code class="cpp">// [[Rcpp::export]]
List rleC(NumericVector x) {
  std::vector&lt;int&gt; lengths;
  std::vector&lt;double&gt; values;

  // Initialise first value
  int i = 0;
  double prev = x[0];
  values.push_back(prev);
  lengths.push_back(1);

  for(NumericVector::iterator it = x.begin() + 1; it != x.end(); ++it) {
    if (prev == *it) {
      lengths[i]++;
    } else {
      values.push_back(*it);
      lengths.push_back(1);

      i++;
      prev = *it;
    }
  }

  return List::create(_[&quot;lengths&quot;] = lengths, _[&quot;values&quot;] = values);
}
</code></pre>

<p>(An alternative implementation would be to replace <code>i</code> with the iterator <code>lengths.rbegin()</code> which always points to the last element of the vector - you might want to try implementing that yourself.)</p>

<p>Other methods of a vector are described at <a href="http://www.cplusplus.com/reference/vector/vector/">http://www.cplusplus.com/reference/vector/vector/</a>.</p>

<h3>Sets</h3>

<p>Sets maintain a unique set of values, and can efficiently tell if you&#39;ve seen a value before. They are useful for problems that involve duplicates or unique values (like <code>unique</code>, <code>duplicated</code>, or <code>in</code>). C++ provides both ordered (<code>std::set</code>) and unordered sets (<code>std::tr1::unorded_set</code>), depending on whether or not order matters for you. Unordered sets tend to be much faster (because they use a hash table internally rather than a tree), so even if you need an ordered set, you should consider using an unordered set and then sorting the output. Like vectors, sets are templated, so you need to request the appropriate type of set for your purpose: <code>unordered_set&lt;int&gt;</code>, <code>unordered_set&lt;bool&gt;</code>, etc.</p>

<p><a href="http://www.cplusplus.com/reference/set/set/">http://www.cplusplus.com/reference/set/set/</a> and <a href="http://www.cplusplus.com/reference/unordered_set/unordered_set/">http://www.cplusplus.com/reference/unordered_set/unordered_set/</a> provide complete documentation for sets structures.</p>

<p>The following function uses an unordered set to implement an equivalent to <code>duplicated</code> for integer vectors. Note the use of <code>seen.insert(x[i]).second</code> - <code>insert</code> returns a pair, the <code>first</code> value is an iterator that points to element and the <code>second</code> value is a boolean that&#39;s true if the value was a new addition to the set.  </p>

<pre><code class="cpp">// [[Rcpp::export]]
LogicalVector duplicatedC(IntegerVector x) {
  std::tr1::unordered_set&lt;int&gt; seen;
  int n = x.size();
  LogicalVector out(n);

  for (int i = 0; i &lt; n; ++i) {
    out[i] = !seen.insert(x[i]).second;
  }

  return out;
}
</code></pre>

<h3>Map</h3>

<p>A map is similar to a set, but instead of storing presence or absence, it can store additional data. It&#39;s useful for functions like <code>table</code> or <code>match</code> that need to look up a value. As with sets, there are ordered (<code>std::map</code>) and unordered (<code>std::tr1::unorded_map</code>) versions, but if output order matters it&#39;s usually faster to use an unordered map and sort the results. </p>

<p>Since maps have a value and a key, you need to specify both when initialising a map: <code>map&lt;double, int&gt;</code>, <code>unordered_map&lt;int, double&gt;</code>, and so on.</p>

<p>XXX: Insert example implementation of match when <code>String</code> complete</p>

<h3>Exercises</h3>

<p>To practive using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:</p>

<ul>
<li><code>median.default</code> using <code>partial_sort</code></li>
<li><code>%in%</code> using <code>unordered_set</code> and the <code>find</code> or <code>count</code> methods</li>
<li><code>unique</code> using an <code>unordered_set</code> (challenge: do it in one line!)</li>
<li><code>min</code> using <code>std::min</code>, or <code>max</code> using <code>std::max</code></li>
<li><code>which.min</code> using <code>min_element</code>, or <code>which.max</code> using <code>max_element</code></li>
<li><code>setdiff</code>, <code>union</code> and <code>intersect</code> using sorted ranges and <code>set_union</code>, <code>set_intersection</code> and <code>set_difference</code></li>
</ul>

<h2>Case studies</h2>

<p>The following case studies illustrate some real life uses of C++ to replace slow R code. </p>

<h3>Gibbs sampler</h3>

<p>The following case study updates an example <a href="http://dirk.eddelbuettel.com/blog/2011/07/14/">blogged about</a> by Dirk Eddelbuettel, illustrating the conversion of a gibbs sampler in R to C++. The R and C++ code shown below is very similar (it only took a few minutes to convert the R version to the C++ version), but runs about 20 times faster on my computer. Dirk&#39;s blog post also shows another way to make it even faster: using the faster (but presumably less accurate) random number generator functions in GSL (easily accessible from R through RcppGSL) can eke out another 2-3x speed improvement.</p>

<p>The R code is as follows:</p>

<pre><code class="r">gibbs_r &lt;- function(N, thin) {
  mat &lt;- matrix(nrow = N, ncol = 2)
  x &lt;- y &lt;- 0

  for (i in 1:N) {
    for (j in 1:thin) {
      x &lt;- rgamma(1, 3, y * y + 4)
      y &lt;- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))
    }
    mat[i, ] &lt;- c(x, y)
  }
  mat
}
</code></pre>

<p>This is straightforward to convert to C++.  We:</p>

<ul>
<li>add type declarations to all variables</li>
<li>use <code>(</code> instead of <code>[</code> to index into the matrix</li>
<li>subscript the results of <code>rgamma</code> and <code>rnorm</code> to convert from a vector into a scalar</li>
</ul>

<pre><code class="cpp">// [[Rcpp::export]]
NumericMatrix gibbs_cpp(int N, int thin) {
  NumericMatrix mat(N, 2);
  double x = 0, y = 0;

  for(int i = 0; i &lt; N; i++) {
    for(int j = 0; j &lt; thin; j++) {
      x = rgamma(1, 3, 1 / (y * y + 4))[0];
      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];
    }
    mat(i, 0) = x;
    mat(i, 1) = y;
  }

  return(mat);
}
</code></pre>

<p>Benchmarking the two implementations yields:</p>

<pre><code class="r">  library(microbenchmark)
  microbenchmark(
    gibbs_r(100, 10),
    gibbs_cpp(100, 10)
  )
</code></pre>

<h3>R vectorisation vs. C++ vectorisation</h3>

<p>This example is adapted from <a href="http://www.babelgraph.org/wp/?p=358">Rcpp is smoking fast for agent-based models in data frames</a>. The challenge is to predict a model response from three inputs. The basic R version looks like:</p>

<pre><code class="r">vacc1a &lt;- function(age, female, ily) {
  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily
  p &lt;- p * if (female) 1.25 else 0.75
  p &lt;- max(0, p)
  p &lt;- min(1, p)
  p
}
</code></pre>

<p>We want to be able to apply this function to many inputs, so we might write a vectorised version using a for loop.</p>

<pre><code class="r">vacc1 &lt;- function(age, female, ily) {
  n &lt;- length(age)
  out &lt;- numeric(n)
  for (i in seq_len(n)) {
    out[i] &lt;- vacc1a(age[i], female[i], ily[i])
  }
  out
}
</code></pre>

<p>If you&#39;re familiar with R, you&#39;ll have a gut feeling that this will be slow, and indeed it is. There are two ways we could attack this problem. If you have a good R vocabulary, you might immediately see how to vectorise the function (using <code>ifelse</code>, <code>pmin</code> and <code>pmax</code>). Alternatively, we could rewrite <code>vacc1a</code> and <code>vacc1</code> in C++, using our knowledge that loops and function calls have much lower overhead in C++.</p>

<p>Either approach is fairly straighforward. In R:</p>

<pre><code class="r">vacc2 &lt;- function(age, female, ily) {
  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily
  p &lt;- p * ifelse(female, 1.25, 0.75)
  p &lt;- pmax(0, p)
  p &lt;- pmin(1, p)
  p
}
</code></pre>

<p>(If you&#39;ve worked R a lot you might recongise some potential bottlenecks in this code: <code>ifelse</code>, <code>pmin</code>, and <code>pmax</code> are known to be slow, and could be replaced with <code>p + 0.75 + 0.5 * female</code>, <code>p[p &lt; 0] &lt;- 0</code>, <code>p[p &gt; 1] &lt;- 1</code>.  You might want to try timing those variations yourself.)</p>

<p>Or in C++:</p>

<pre><code class="cpp">double vacc3a(double age, bool female, bool ily){
  double p = 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily;
  p = p * (female ? 1.25 : 0.75);
  p = std::max(p, 0.0); 
  p = std::min(p, 1.0);
  return p;
}

// [[Rcpp::export]]
NumericVector vacc3(NumericVector age, LogicalVector female, LogicalVector ily) {
  int n = age.size();
  NumericVector out(n);

  for(int i = 0; i &lt; n; ++i) {
    out[i] = vacc3a(age[i], female[i], ily[i]);
  }

  return out;
}
</code></pre>

<p>We next generate some sample data, and check that all three versions return the same values:</p>

<pre><code class="r">n &lt;- 1000
age &lt;- rnorm(n, mean = 50, sd = 10)
female &lt;- sample(c(T, F), n, rep = TRUE)
ily &lt;- sample(c(T, F), n, prob = c(0.8, 0.2), rep = TRUE)

stopifnot(
  all.equal(vacc1(age, female, ily), vacc2(age, female, ily)),
  all.equal(vacc1(age, female, ily), vacc3(age, female, ily))
)
</code></pre>

<p>The original blog post forgot to do this, and hence introduced a bug in the C++ version: it used <code>0.004</code> instead of <code>0.04</code>.  Finally, we can benchmark our three approaches:</p>

<pre><code class="r">microbenchmark(
  vacc1(age, female, ily),
  vacc2(age, female, ily),
  vacc3(age, female, ily))
</code></pre>

<p>Not surprisingly, our original approach with loops is very slow.  Vectorising in R gives a huge speedup, and we can eke out even more performance (~10x) with the C++ loop. I was a little surprised that the C++ was so much faster, but it is because the R version has to create 11 vectors to store intermediate results, where the C++ code only needs to create 1. </p>

<h2>Using Rcpp in a Package</h2>

<p>The same C++ code that is used with <code>sourceCpp</code> can also be bundled into a package. There are several benefits of moving code from a standalone C++ source file to a package:</p>

<ol>
<li>Your code can be made available to users without C++ development tools (at least on Windows or Mac OS X where binary packages are common)</li>
<li>Multiple source files and their dependencies are handled automatically by the R package build system</li>
<li>Packages provide additional infrastructure for testing, documentation and consistency </li>
</ol>

<p>To generate a new Rcpp package that includes a simple hello, world function you can use the <code>Rcpp.package.skeleton</code> function as follows:</p>

<pre><code class="r">Rcpp.package.skeleton(&quot;NewPackage&quot;, attributes = TRUE)
</code></pre>

<p>To generate a package based on C++ files that you&#39;ve been using with <code>sourceCpp</code> you can use the <code>cpp_files</code> parameter:</p>

<pre><code class="r">Rcpp.package.skeleton(&quot;NewPackage&quot;, example_code = FALSE, 
                        cpp_files = c(&quot;convolve.cpp&quot;))
</code></pre>

<p>To add <code>Rcpp</code> to an existing package, you put your C++ files in the <code>src/</code> directory and modify/create the following configuration files:</p>

<ul>
<li><p>In <code>DESCRIPTION</code> add    </p>

<pre><code>Depends: Rcpp (&gt;= 0.10.1) 
LinkingTo: Rcpp 
</code></pre></li>
<li><p>Make sure your <code>NAMESPACE</code> includes:</p>

<pre><code>useDynLib(mypackage)
</code></pre></li>
<li><p>You need <code>src/Makevars</code> which contains:</p>

<pre><code>PKG_LIBS = `$(R_HOME)/bin/Rscript -e &quot;Rcpp:::LdFlags()&quot;`
</code></pre>

<p>And <code>src/Makevars.win</code> that contains:</p>

<pre><code>PKG_LIBS = $(shell &quot;${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe&quot; -e &quot;Rcpp:::LdFlags()&quot;)
</code></pre></li>
</ul>

<p>For more details see the <a href="http://cran.rstudio.com/web/packages/Rcpp/vignettes/Rcpp-package.pdf">Writing a package that uses Rcpp vignette</a>. </p>

<p>If your packages uses the <code>Rcpp::export</code> attribute then one additional step in the package build process is requried. The <code>compileAttributes</code> function scans the source files within a package for <code>Rcpp::export</code> attributes and generates the code required to export the functions to R.</p>

<p>You should re-run <code>compileAttributes</code> whenever functions are added, removed, or have their signatures changed. Note that if you build your package using RStudio or <code>devtools</code> then this step occurs automatically.</p>

<h2>Learning more</h2>

<h3>More Rcpp</h3>

<p>This chapter has only touched on a small part of Rcpp, giving you the basic tools to rewrite poorly performing R code in C++. Rcpp has many other capabilities that make it easy to interface R to existing C++ code, including:</p>

<ul>
<li><p>Additional features of attributes including specifying default arguments, linking in external C++ dependencies, and exporting C++ interfaces from packages. These features and more are covered in the <a href="http://cran.rstudio.com/web/packages/Rcpp/vignettes/Rcpp-attributes.pdf">Rcpp attributes</a> vignette.</p></li>
<li><p>Automatically creating wrappers between C++ data structures and R data structures, including mapping C++ classes to reference classes. A good introduction to this topic is the vignette of <a href="http://cran.rstudio.com/web/packages/Rcpp/vignettes/Rcpp-modules.pdf">Rcpp modules</a></p></li>
<li><p>The <a href="http://cran.rstudio.com/web/packages/Rcpp/vignettes/Rcpp-quickref.pdf">Rcpp quick reference guide</a> contains a useful summary of Rcpp classes and common programming idioms.</p></li>
</ul>

<p>I strongly recommend keeping an eye on the <a href="http://dirk.eddelbuettel.com/code/rcpp.html">Rcpp homepage</a> and signing up for the <a href="http://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/rcpp-devel">Rcpp mailing list</a>. Rcpp is still under active development, and is getting better with every release.</p>

<h3>More C++</h3>

<p>Writing performant code may also require you to rethink your basic approach: a solid understand of basic data structures and algorithms is very helpful here.  That&#39;s beyond the scope of this book, but I&#39;d suggest the <a href="http://amzn.com/0387948600?tag=devtools-20">&quot;algorithm design manual&quot;</a> or MIT&#39;s <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/">Introduction to Algorithms</a>.</p>

<p>Other resources I&#39;ve found helpful in learning C++ are:</p>

<ul>
<li><p><a href="http://amzn.com/0321334876?tag=devtools-20">Effective C++</a> and <a href="http://amzn.com/0201749629?tag=devtools-20">Effective STL</a> by Scott Meyers.</p></li>
<li><p><a href="http://www.icce.rug.nl/documents/cplusplus/cplusplus.html">C++ Annotations</a>, aimed at&quot; knowledgeable users of C (or any other language using a C-like grammar, like Perl or Java) who would like to know more about, or make the transition to, C++&quot;</p></li>
<li><p><a href="http://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/">Algorithm Libraries</a>, which provides a more technical, but still precise, description of important STL concepts. (Follow the links under notes)</p></li>
<li><p>&quot;Algorithms&quot; by Robert Sedgewick and Kevin Wayne has a free <a href="http://algs4.cs.princeton.edu/home/">online textbook</a> and a matching <a href="https://www.coursera.org/course/algs4partI">coursera course</a>.</p></li>
</ul>

<h2>Acknowledgements</h2>

<p>I&#39;d like to thank the Rcpp-mailing list for many helpful conversations, particularly Romain Francois and Dirk Eddelbuettel who have not only provided detailed answers to many of my questions, but have been incredibly responsive at improving Rcpp. This chapter would not have been possible without JJ Allaire; he encouraged me to learn C++ and then answered many of my dumb questions along the way.</p>

<div class="chunk" id="unnamed-chunk-540"><div class="rcode"><div class="message"><pre class="knitr r">## Attaching package: 'inline'
## 
## The following object is masked from 'package:Rcpp':
## 
## registerPlugin
</pre></div>

<p></div></div></p>

<h1>R&#39;s C interface</h1>

<h2>Introduction</h2>

<p>Reading the source code of R is an extremely powerful technique for improving your R programming. However, at some point you will hit a brick wall: many R functions are implemented in C. This guide gives you a basic introduction to C and R&#39;s internal C api, giving you the basic knowledge needed to read the internals of R that are written in C.</p>

<p>If you want to write new high-performance code, we do not recommend using C, but instead strongly recommend using Rcpp to connect to C++. The Rcpp API protects you from many of the historical idiosyncracies of the R API, takes care of memory management for you, and provides many useful helper methods</p>

<p>The contents of this chapter are adapted from Section 5 (&quot;System and foreign language interfaces&quot;) of <a href="http://cran.r-project.org/doc/manuals/R-exts.html">Writing R extensions</a>, focussing on best practices and modern tools. This means it does not cover:</p>

<ul>
<li>the <code>.C</code> interface</li>
<li>the old api defined in <code>Rdefines.h</code></li>
<li>rarely used and esoteric language features</li>
</ul>

<p>To understand existing C code, it&#39;s useful to generate simple examples of your own that you can experiment with. To that end, all examples in this chapter use the <code>inline</code> package, which makes it extremely easy to get up and running with C code. Make sure you have it installed and loaded with the following code:</p>

<div class="chunk" id="unnamed-chunk-541"><div class="rcode"><div class="source"><pre class="knitr r">install.packages("inline")
library(inline)
</pre></div>

<p></div></div></p>

<p>You&#39;ll also (obviously) need a working C compiler. Windows users can use Duncan Murdoch&#39;s <a href="http://cran.r-project.org/bin/windows/Rtools/">Rtools</a>. Mac users will need the <a href="http://developer.apple.com/">Xcode command line tools</a>. Most linux distributions will come with the necessary compilers.</p>

<h2>Differences between R and C</h2>

<p>Even if you&#39;ve never used C before, you should be able to read C code because the basic structure is similar to R. If you want to learn it more formally <a href="http://amzn.com/0131101633?tag=devtools-20">The C programming language</a> by Kernigan and Ritchie is a classic.</p>

<p>Important differences from R include:</p>

<ul>
<li>variables can only store specific types of object, and must be declared before use</li>
<li>objects are modified in place, unless you specifically copy the object</li>
<li>indices start at 0, not 1</li>
<li>you must use a semi-colon at end of each line</li>
<li>you must have an explicit return statement</li>
<li>assignment is done with <code>=</code>, not <code>&lt;-</code></li>
</ul>

<h2>Calling C functions from R</h2>

<p>Generally, calling C functions from R involves two parts: a C function and an R function that uses <code>.Call</code>. The simple function below adds two numbers together and illustrates some of the important features of coding in C (creating new R vectors, coercing input arguments to the appropriate type and dealing with garbage collection).  </p>

<pre><code class="c">// In C ----------------------------------------
#include &lt;R.h&gt;
#include &lt;Rinternals.h&gt;

SEXP add(SEXP a, SEXP b) {
  SEXP result;

  PROTECT(result = allocVector(REALSXP, 1));
  REAL(result)[0] = asReal(a) + asReal(b);
  UNPROTECT(1);

  return(result);
}
</code></pre>

<div class="chunk" id="unnamed-chunk-542"><div class="rcode"><div class="source"><pre class="knitr r"># In R ----------------------------------------
add <- function(a, b) {
  .Call("add", a, b)
}
</pre></div>

<p></div></div></p>

<p>In this chapter we&#39;ll produce these two pieces in one step by using the <code>inline</code> package. This allows us to write:</p>

<div class="chunk" id="unnamed-chunk-543"><div class="rcode"><div class="source"><pre class="knitr r">add <- cfunction(signature(a = "integer", b = "integer"), "
  SEXP result;

  PROTECT(result = allocVector(REALSXP, 1));
  REAL(result)[0] = asReal(a) + asReal(b);
  UNPROTECT(1);

  return(result);
")
add(1, 5)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 6
</pre></div>

<p></div></div></p>

<p>The C functions and macros that R provides for us to modify R data structures are all defined in the header file <code>Rinternals.h</code>.  It&#39;s easiest to find and display this file from within R:</p>

<div class="chunk" id="unnamed-chunk-544"><div class="rcode"><div class="source"><pre class="knitr r">rinternals <- file.path(R.home(), "include", "Rinternals.h")
file.show(rinternals)
</pre></div>

<p></div></div></p>

<p>Before we begin writing and reading C code, we need to know a little about the basic data structures.</p>

<h2>Basic data structures</h2>

<p>At the C-level, all R objects are stored in a common datatype, the <code>SEXP</code>. (Technically, this is a pointer to a structure with typedef <code>SEXPREC</code>). A <code>SEXP</code> is a variant type, with subtypes for all R&#39;s data structures. The most important types are:</p>

<ul>
<li><code>REALSXP</code>: numeric vectors</li>
<li><code>INTSXP</code>: integer vectors</li>
<li><code>LGLSXP</code>: logical vectors</li>
<li><code>STRSXP</code>: character vectors</li>
<li><code>VECSXP</code>: lists</li>
<li><code>CLOSXP</code>: functions (closures)</li>
<li><code>ENVSXP</code>: environments</li>
</ul>

<p><strong>Beware:</strong> At the C level, R&#39;s lists are <code>VECSXP</code>s not <code>LISTSXP</code>s. This is because early implementations of R used LISP-like linked lists (now known as &quot;pairlists&quot;) before moving to the S-like generic vectors that we now know as lists.</p>

<p>There are also <code>SEXP</code>s for less common object types:</p>

<ul>
<li><code>CPLXSXP</code>: complex vectors</li>
<li><code>LISTSXP</code>: &quot;pair&quot; lists. At the R level, you only need to care about the distinction lists and pairlists for function arguments, but internally they are used in many more places.</li>
<li><code>DOTSXP</code>: &#39;...&#39;</li>
<li><code>SYMSXP</code>: names/symbols</li>
<li><code>NILSXP</code>: <code>NULL</code></li>
</ul>

<p>And <code>SEXP</code>s for internal objects, objects that are usually only created and used by C functions, not R functions:</p>

<ul>
<li><code>LANGSXP</code>: language constructs</li>
<li><code>CHARSXP</code>: &quot;scalar&quot; strings (see below)</li>
<li><code>PROMSXP</code>: promises, lazily evaluated function arguments</li>
<li><code>EXPRSXP</code>: expressions</li>
</ul>

<p>There&#39;s no built-in R function to easily access these names, but we can write one: (This is adapted from code in R&#39;s <code>inspect.c</code>)</p>

<div class="chunk" id="unnamed-chunk-545"><div class="rcode"><div class="source"><pre class="knitr r">sexp_type <- cfunction(c(x = "ANY"), '
  switch (TYPEOF(x)) {
    case NILSXP:      return mkString("NILSXP");
    case SYMSXP:      return mkString("SYMSXP");
    case LISTSXP:     return mkString("LISTSXP");
    case CLOSXP:      return mkString("CLOSXP");
    case ENVSXP:      return mkString("ENVSXP");
    case PROMSXP:     return mkString("PROMSXP");
    case LANGSXP:     return mkString("LANGSXP");
    case SPECIALSXP:  return mkString("SPECIALSXP");
    case BUILTINSXP:  return mkString("BUILTINSXP");
    case CHARSXP:     return mkString("CHARSXP");
    case LGLSXP:      return mkString("LGLSXP");
    case INTSXP:      return mkString("INTSXP");
    case REALSXP:     return mkString("REALSXP");
    case CPLXSXP:     return mkString("CPLXSXP");
    case STRSXP:      return mkString("STRSXP");
    case DOTSXP:      return mkString("DOTSXP");
    case ANYSXP:      return mkString("ANYSXP");
    case VECSXP:      return mkString("VECSXP");
    case EXPRSXP:     return mkString("EXPRSXP");
    case BCODESXP:    return mkString("BCODESXP");
    case EXTPTRSXP:   return mkString("EXTPTRSXP");
    case WEAKREFSXP:  return mkString("WEAKREFSXP");
    case S4SXP:       return mkString("S4SXP");
    case RAWSXP:      return mkString("RAWSXP");
    default:          return mkString("<unknown>");
}')
sexp_type(10)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "REALSXP"
</pre></div>

<div class="source"><pre class="knitr r">sexp_type(10L)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "INTSXP"
</pre></div>

<div class="source"><pre class="knitr r">sexp_type("a")
</pre></div>

<div class="output"><pre class="knitr r">## [1] "STRSXP"
</pre></div>

<div class="source"><pre class="knitr r">sexp_type(T)
</pre></div>

<div class="output"><pre class="knitr r">## [1] "LGLSXP"
</pre></div>

<div class="source"><pre class="knitr r">sexp_type(list(a = 1))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "VECSXP"
</pre></div>

<div class="source"><pre class="knitr r">sexp_type(pairlist(a = 1))
</pre></div>

<div class="output"><pre class="knitr r">## [1] "LISTSXP"
</pre></div>

<p></div></div></p>

<h3>Character vectors</h3>

<p>R character vectors are stored as <code>STRSXP</code>s, a vector type where every element is a <code>CHARSXP</code>. <code>CHARSXP</code>s are read-only objects and must never be modified. In particular, the C-style string contained in a <code>CHARSXP</code> should be treated as read-only; it&#39;s hard to do otherwise because the <code>CHAR</code> accessor function returns a <code>const char*</code>.</p>

<p>Strings have this more complicated design because individual <code>CHARSXP</code>&#39;s (elements of a character vector) can be shared between multiple strings. This is an optimisation to reduce memory usage, and can result in unexpected behaviour:</p>

<div class="chunk" id="unnamed-chunk-546"><div class="rcode"><div class="source"><pre class="knitr r">x <- "banana"
y <- rep(x, 1e6)
object.size(x)
# 32-bit: 64 bytes
# 64-bit: 96 bytes
object.size(y) / 1e6
# 32-bit: 4.000056 bytes
# 64-bit: 8.000088 bytes
</pre></div>

<p></div></div></p>

<p>In 32-bit R, factors occupy about the same amount of memory as strings: both pointers and integers are 4 bytes. In 64-bit R, pointers are 8 bytes, so factors take about twice as much memory as strings.</p>

<h2>Coercion and object creation</h2>

<p>At the heart of every C function will be a set of conversions between R data structures and C data structures. Inputs and output will always be R data structures (<code>SEXP</code>s) and you will need to convert them to C data structures in order to do any work. An additional complication is the garbage collector: if you don&#39;t claim every R object you create, the garbage collector will think they are unused and delete them.</p>

<h3>Object creation and garbage collection</h3>

<p>The simplest way to create an new R-level object is <code>allocVector</code>, which takes two arguments, the type of <code>SEXP</code> (or <code>SEXPTYPE</code>) to create, and the length of the vector. The following code code creates a three element list containing a logical vector, a numeric vector and an integer vector:</p>

<div class="chunk" id="unnamed-chunk-547"><div class="rcode"><div class="source"><pre class="knitr r">dummy <- cfunction(body = '
  SEXP vec, real, lgl, ints;

  PROTECT(real = allocVector(REALSXP, 2));
  PROTECT(lgl = allocVector(LGLSXP, 10));
  PROTECT(ints = allocVector(INTSXP, 10));

  PROTECT(vec = allocVector(VECSXP, 3));
  SET_VECTOR_ELT(vec, 0, real);
  SET_VECTOR_ELT(vec, 1, lgl);
  SET_VECTOR_ELT(vec, 2, ints);

  UNPROTECT(4);
  return(vec);
')
dummy()
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## [1] 8.49e-314 3.95e-323
## 
## [[2]]
##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
## 
## [[3]]
##  [1] 419022760         0 416621240         0 419022616         0 419022520
##  [8]         0 419022424         0
</pre></div>

<p></div></div></p>

<p>You might wonder what all the <code>PROTECT</code> calls do. They tell R that we&#39;re currently using each object, and not to delete it if the garbage collector is activated. (We don&#39;t need to protect objects that R already knows about, like function arguments).</p>

<p>You also need to make sure that every protected object is unprotected. <code>UNPROTECT</code> takes a single integer argument, n, and unprotects the last n objects that were protected. If your calls don&#39;t match, R will warn about a &quot;stack imbalance in .Call&quot;.</p>

<p>Other specialised forms of <code>PROTECT</code> and <code>UNPROTECT</code> are needed in some circumstances: <code>UNPROTECT_PTR(s)</code> unprotects the
object pointed to by the <code>SEXP</code> s, <code>PROTECT_WITH_INDEX</code> saves an index of the protection location that can be used to replace the protected value using <code>REPROTECT</code>. Consult the R externals section on <a href="http://cran.r-project.org/doc/manuals/R-exts.html#Garbage-Collection">garbage collection</a> for more details.</p>

<p>If you run <code>dummy()</code> a few times, you&#39;ll notice the output is basically random. This is because <code>allocVector</code> assigns memory to each output, but it doesn&#39;t clean it out first. For real functions, you&#39;ll want to loop through each element in the vector and zero it out. The most efficient way to do that is to use <code>memset</code>:</p>

<div class="chunk" id="unnamed-chunk-548"><div class="rcode"><div class="source"><pre class="knitr r">zeroes <- cfunction(c(n_ = "integer"), '
  int n = asInteger(n_);
  SEXP out;

  PROTECT(out = allocVector(INTSXP, n));
  memset(INTEGER(out), 0, n * sizeof(int));
  UNPROTECT(1);

  return out;
')
zeroes(10);
</pre></div>

<div class="output"><pre class="knitr r">##  [1] 0 0 0 0 0 0 0 0 0 0
</pre></div>

<p></div></div></p>

<h3>Allocation shortcuts</h3>

<p>There are a few shortcuts for allocating matrices and 3d arrays:</p>

<pre><code class="c">allocMatrix(SEXPTYPE mode, int nrow, int ncol)
alloc3DArray(SEXPTYPE mode, int nrow, int ncol, int nface)
</code></pre>

<p>Beware <code>allocList</code> - it creates a pairlist, not a regular list.</p>

<p>The <code>mkNamed</code> function simplifies the creation of named vectors.  The following code is equivalent to <code>list(a = NULL, b = NULL, c = NULL)</code>:</p>

<pre><code class="c">const char *names[] = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;};
mkNamed(VECSXP, names);
</code></pre>

<h3>Extracting C vectors</h3>

<p>There is a helper function for each atomic vector (apart from character, see following) that allows you to index into a <code>SEXP</code> and access the C-level data structure that lives at its heart.  </p>

<p>The following example shows how to use the helper function <code>REAL</code> to inspect and modify a numeric vector:</p>

<div class="chunk" id="unnamed-chunk-549"><div class="rcode"><div class="source"><pre class="knitr r">add_one <- cfunction(c(x = "numeric"), "
  SEXP out;
  int n = length(x);

  PROTECT(out = allocVector(REALSXP, n));
  for (int i = 0; i < n; i++) {
    REAL(out)[i] = REAL(x)[i] + 1;
  }
  UNPROTECT(1);

  return out;
")
add_one(as.numeric(1:10))
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  2  3  4  5  6  7  8  9 10 11
</pre></div>

<p></div></div></p>

<p>There are similar helpers for logical, <code>LOGICAL(x)</code>, integer, <code>INTEGER(x)</code>, complex <code>COMPLEX(x)</code> and raw vectors <code>RAW(x)</code>. </p>

<p>If you&#39;re working with long vectors, there&#39;s a performance advantage to using the helper function once and saving the result in a pointer:</p>

<div class="chunk" id="unnamed-chunk-550"><div class="rcode"><div class="source"><pre class="knitr r">add_two <- cfunction(c(x = "numeric"), "
  SEXP out;
  int n = length(x);
  double *px, *pout;

  PROTECT(out = allocVector(REALSXP, n));

  px = REAL(x);
  pout = REAL(out);
  for (int i = 0; i < n; i++) {
    pout[i] = px[i] + 2;
  }
  UNPROTECT(1);

  return out;
")
add_two(as.numeric(1:10))
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  3  4  5  6  7  8  9 10 11 12
</pre></div>

<div class="source"><pre class="knitr r">
library(microbenchmark)
x <- as.numeric(1:1e6)
microbenchmark(
  add_one(x),
  add_two(x)
)
</pre></div>

<div class="output"><pre class="knitr r">## Unit: milliseconds
##        expr  min   lq median   uq  max neval
##  add_one(x) 6.53 9.59   9.66 9.75 23.7   100
##  add_two(x) 3.67 6.15   6.20 6.25 20.6   100
</pre></div>

<p></div></div></p>

<p>On my computer, <code>add_two</code> is about twice as fast as <code>add_one</code> for a million element vector. This is a common idiom in the R source code.</p>

<p>Strings and lists are more complicated because the individual elements are <code>SEXP</code>s not C-level data structures. You can use <code>STRING_ELT(x, i)</code> and <code>VECTOR_ELT(x, i)</code> to extract individual components of strings and lists respectively. To get a single C string from a element in a R character vector, use <code>CHAR(STRING_ELT(x, i))</code>. Set values in a list or character vector with <code>SET_VECTOR_ELT</code> and <code>SET_STRING_ELT</code>.</p>

<h3>Modifying strings</h3>

<p>String vectors are a little more complicated. As discussed earlier, a string vector is a vector made up of pointers to immutable <code>CHARSXP</code>s, and it&#39;s the <code>CHARSXP</code> that contains the C string (which can be extracted using <code>CHAR</code>). The following function shows how to create a vector of fixed values:</p>

<div class="chunk" id="unnamed-chunk-551"><div class="rcode"><div class="source"><pre class="knitr r">abc <- cfunction(NULL, '
  SEXP out;
  PROTECT(out = allocVector(STRSXP, 3));

  SET_STRING_ELT(out, 0, mkChar("a"));
  SET_STRING_ELT(out, 1, mkChar("b"));
  SET_STRING_ELT(out, 2, mkChar("c"));

  UNPROTECT(1);

  return out;
')
abc()
</pre></div>

<div class="output"><pre class="knitr r">## [1] "a" "b" "c"
</pre></div>

<p></div></div></p>

<p>Things are a little harder if you want to modify the strings in the vector because you need to know a lot about string manipulation in C (which is hard, and harder to do right). For any problem that involves any kind of string modification, you&#39;re better off using Rcpp. </p>

<p>The following function just makes a copy of a string, so you can at least see how all the pieces work together.</p>

<div class="chunk" id="unnamed-chunk-552"><div class="rcode"><div class="source"><pre class="knitr r">copy <- cfunction(c(x = "character"), '
  SEXP out;
  int n = length(x);
  const char* letter;

  PROTECT(out = allocVector(STRSXP, n));
  for (int i = 0; i < n; i++) {
    letter = CHAR(STRING_ELT(x, i));
    SET_STRING_ELT(out, i, mkChar(letter));
  }
  UNPROTECT(1);
  
  return out;
')
copy(letters)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q"
## [18] "r" "s" "t" "u" "v" "w" "x" "y" "z"
</pre></div>

<p></div></div></p>

<p>One last useful function for operating with strings: we can use <code>STRING_PTR</code> to get a pointer to the <code>STRING_ELT</code>s in a vector, such that we can access the <code>STRING_ELT</code>s by de-referencing the pointer. Occasionally, this can be easier to work with. We&#39;ll show how this can make a simple example of reversing a vector of strings easier.</p>

<div class="chunk" id="unnamed-chunk-553"><div class="rcode"><div class="source"><pre class="knitr r">reverse <- cfunction( signature(x="character"), '
  SEXP out;
  int len = length(x);
  PROTECT( out = allocVector(STRSXP, len) );
  SEXP* out_ptr = STRING_PTR(out);
  SEXP* x_ptr = STRING_PTR(x);
  for( int i=0; i < len; ++i ) {
    out_ptr[i] = x_ptr[len-i-1];
  }
  UNPROTECT(1);
  return out;
')

reverse(letters)
</pre></div>

<div class="output"><pre class="knitr r">##  [1] "z" "y" "x" "w" "v" "u" "t" "s" "r" "q" "p" "o" "n" "m" "l" "k" "j"
## [18] "i" "h" "g" "f" "e" "d" "c" "b" "a"
</pre></div>

<p></div></div></p>

<h3>Coercing scalars</h3>

<p>There also a few helper functions if you want to turn the first element of an R vector into a C scalar:</p>

<ul>
<li><code>asLogical(x): INTSXP -&gt; int</code></li>
<li><code>asInteger(x): INTSXP -&gt; int</code></li>
<li><code>asReal(x): REALSXP -&gt; double</code></li>
<li><code>CHAR(asChar(x)): STRSXP -&gt; const char*</code></li>
</ul>

<p>And similarly it&#39;s easy to turn a C scalar into a length-one R vector:</p>

<ul>
<li><code>ScalarLogical(x): int -&gt; LGLSXP</code></li>
<li><code>ScalarInteger(x): int -&gt; INTSXP</code></li>
<li><code>ScalarReal(x): double -&gt; REALSXP</code></li>
<li><code>mkString(x): const char* -&gt; STRSXP</code></li>
</ul>

<p>These all create R-level objects, so need to be <code>PROTECT</code>ed.</p>

<h2>Modifying objects</h2>

<p>You must be very careful when modifying an object that the user has passed into the function. The following function has some very unexpected behaviour:</p>

<div class="chunk" id="unnamed-chunk-554"><div class="rcode"><div class="source"><pre class="knitr r">add_three <- cfunction(c(x = "numeric"), '
  REAL(x)[0] = REAL(x)[0] + 3;
  return(x);
')
x <- 1
y <- x
add_three(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<div class="source"><pre class="knitr r">x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<div class="source"><pre class="knitr r">y
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<p></div></div></p>

<p>Not only has it modified the value of <code>x</code>, but it has also modified <code>y</code>!  This happens because of the way that R implements it&#39;s copy-on-modify philosophy. It does so lazily, so a complete copy only has to be made if you make a change: <code>x</code> and <code>y</code> point to the same object, and the object is only duplicated if you change either <code>x</code> or <code>y</code>.</p>

<p>To avoid problems like this, always <code>duplicate()</code> inputs before modifying them:</p>

<div class="chunk" id="unnamed-chunk-555"><div class="rcode"><div class="source"><pre class="knitr r">add_four <- cfunction(c(x = "numeric"), '
  SEXP x_copy;
  PROTECT(x_copy = duplicate(x));
  REAL(x_copy)[0] = REAL(x_copy)[0] + 4;
  UNPROTECT(1);
  return(x_copy);
')
x <- 1
y <- x
add_four(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 5
</pre></div>

<div class="source"><pre class="knitr r">x
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">y
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<h2>Pairlists and symbols</h2>

<p>R hides a few details of the underlying datastructures it uses. In some places in R code, it looks like you&#39;re working with a list (<code>VECSXP</code>), but behind the scenes R you&#39;re actually modifying a pairlist (<code>LISTSXP</code>). These include attributes, calls and <code>...</code>. </p>

<p>Pairlists differ from lists in the following ways:</p>

<ul>
<li><p>Pairlists are <a href="http://en.wikipedia.org/wiki/Linked_list">linked lists</a>, a data structure which does not have any easy way to get to an arbitrary element of the list</p></li>
<li><p>Pairlists have <code>tags</code>, not <code>names</code>, and tags are symbols, not strings.</p></li>
</ul>

<p>Because you can&#39;t easily index into a specified location in a pairlist, R provides a set of helper functions to moved along the linked list. The basic helpers are <code>CAR</code> which extracts the first element of the first, and <code>CDR</code> which extracts the rest. These can be composed to get <code>CAAR</code>, <code>CDAR</code>, <code>CADDR</code>, <code>CADDR</code>, <code>CADDDR</code>. As well as the getters, R also provides <code>SETCAR</code>, <code>SETCDR</code> etc. (Or you can just use )</p>

<div class="chunk" id="unnamed-chunk-556"><div class="rcode"><div class="source"><pre class="knitr r">car <- cfunction(c(x = "ANY"), 'return(CAR(x));')
cdr <- cfunction(c(x = "ANY"), 'return(CDR(x));')
cadr <- cfunction(c(x = "ANY"), 'return(CADR(x));')

x <- quote(f(a = 1, b = 2))
car(x)
</pre></div>

<div class="output"><pre class="knitr r">## f
</pre></div>

<div class="source"><pre class="knitr r">cdr(x)
</pre></div>

<div class="output"><pre class="knitr r">## $a
## [1] 1
## 
## $b
## [1] 2
</pre></div>

<div class="source"><pre class="knitr r">car(cdr(x))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<div class="source"><pre class="knitr r">cadr(x)
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p>You can make new pairlists with <code>CONS</code> or <code>LCONS</code> (if you want a call object). A pairlist is always terminated with <code>R_NilValue</code>.</p>

<div class="chunk" id="unnamed-chunk-557"><div class="rcode"><div class="source"><pre class="knitr r">new_call <- cfunction(NULL, '
  SEXP out;

  out = LCONS(install("+"), LCONS(
      ScalarReal(10), LCONS(
        ScalarReal(5), R_NilValue)));
  return out;
')
new_call();
</pre></div>

<div class="output"><pre class="knitr r">## 10 + 5
</pre></div>

<p></div></div></p>

<p>Similarly, you can loop through all elements of a pairlist as follows:</p>

<div class="chunk" id="unnamed-chunk-558"><div class="rcode"><div class="source"><pre class="knitr r">count <- cfunction(c(x = "ANY"), '
  SEXP el, nxt;
  int i = 0;

  for(nxt = x; nxt != R_NilValue; el = CAR(nxt), nxt = CDR(nxt)) {
    i++;
  }
  return(ScalarInteger(i));
')
count(quote(f(a, b, c)))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 4
</pre></div>

<div class="source"><pre class="knitr r">count(quote(f()))
</pre></div>

<div class="output"><pre class="knitr r">## [1] 1
</pre></div>

<p></div></div></p>

<p><code>TAG</code> and <code>SET_TAG</code> allow you to get and set the tag (aka name) associated with an element of a pairlist. The tag should be a symbol. To create a symbol (the equivalent of <code>as.symbol</code> or <code>as.name</code> in R), use <code>install</code>. </p>

<p>Attributes are also pairlists behind the scenes, but come with the helper functions <code>setAttrib</code> and <code>getAttrib</code> to make access a little easier:</p>

<div class="chunk" id="unnamed-chunk-559"><div class="rcode"><div class="source"><pre class="knitr r">set_attr <- cfunction(c(obj = "ANY", attr = "character", value = "ANY"), '
  const char* attr_s = CHAR(asChar(attr));

  duplicate(obj);
  setAttrib(obj, install(attr_s), value);
  return(obj);
')
x <- 1:10
set_attr(x, "a", 1)
</pre></div>

<div class="output"><pre class="knitr r">##  [1]  1  2  3  4  5  6  7  8  9 10
## attr(,"a")
## [1] 1
</pre></div>

<p></div></div></p>

<p>There are some (confusingly named) shortcuts for common setting operations: <code>classgets</code>, <code>namesgets</code>, <code>dimgets</code> and <code>dimnamesgets</code> are the internal versions of the default methods of <code>class&lt;-</code>, <code>names&lt;-</code>, <code>dim&lt;-</code> and <code>dimnames&lt;-</code>. </p>

<div class="chunk" id="unnamed-chunk-560"><div class="rcode"><div class="source"><pre class="knitr r">tags <- cfunction(c(x = "ANY"), '
  SEXP el, nxt, out;
  int i = 0;

  for(nxt = CDR(x); nxt != R_NilValue; nxt = CDR(nxt)) {
    i++;
  }

  PROTECT(out = allocVector(VECSXP, i));

  for(nxt = CDR(x), i = 0; nxt != R_NilValue; i++, nxt = CDR(nxt)) {
    SET_VECTOR_ELT(out, i, TAG(nxt));
  }

  UNPROTECT(1);

  return out;
')
</pre></div>

<div class="output"><pre class="knitr r">## file7c75468a00d3.cpp: In function 'SEXPREC* file7c75468a00d3(SEXPREC*)':
## file7c75468a00d3.cpp:12: warning: unused variable 'el'
</pre></div>

<div class="source"><pre class="knitr r">tags(quote(f(a = 1, b = 2, c = 3)))
</pre></div>

<div class="output"><pre class="knitr r">## [[1]]
## a
## 
## [[2]]
## b
## 
## [[3]]
## c
</pre></div>

<div class="source"><pre class="knitr r">tags(quote(f()))
</pre></div>

<div class="output"><pre class="knitr r">## list()
</pre></div>

<p></div></div></p>

<h2>Missing and non-finite values</h2>

<p>For floating point numbers, R&#39;s <code>NA</code> is a subtype of <code>NaN</code> so IEEE 754 arithmetic should handle it correctly. However, it is unwise to depend on such details, and is better to deal with missings explicitly:</p>

<ul>
<li><p>In <code>REALSXP</code>s, use the <code>ISNA</code> macro, <code>ISNAN</code>, or <code>R_FINITE</code> macros to check for missing, NaN or non-finite values.  Use the constants <code>NA_REAL</code>, <code>R_NaN</code>, <code>R_PosInf</code> and <code>R_NegInf</code> to set those values</p></li>
<li><p>In <code>INTSXP</code>s, compare/set values to <code>NA_INTEGER</code></p></li>
<li><p>In <code>LGLSXP</code>s, compare/set values to <code>NA_LOGICAL</code></p></li>
<li><p>In <code>STRSXP</code>s, compare/set <code>CHAR(STRING_ELT(x, i))</code> values to <code>NA_STRING</code>. </p></li>
</ul>

<p>For example, a primitive implementation of <code>is.NA</code> might look like</p>

<div class="chunk" id="unnamed-chunk-561"><div class="rcode"><div class="source"><pre class="knitr r">is_na <- cfunction(c(x = "ANY"), '
  SEXP out;
  int n = length(x);

  PROTECT(out = allocVector(LGLSXP, n));

  for (int i = 0; i < n; i++) {
    switch(TYPEOF(x)) {
      case LGLSXP:
        LOGICAL(out)[i] = (LOGICAL(x)[i] == NA_LOGICAL);
        break;
      case INTSXP:
        LOGICAL(out)[i] = (INTEGER(x)[i] == NA_INTEGER);
        break;
      case REALSXP:
        LOGICAL(out)[i] = ISNA(REAL(x)[i]);
        break;
      case STRSXP:
        LOGICAL(out)[i] = (STRING_ELT(x, i) == NA_STRING);
        break;
      default:
        LOGICAL(out)[i] = NA_LOGICAL;
    }
  }
  UNPROTECT(1);

  return out;
')
is_na(c(NA, 1L))
</pre></div>

<div class="output"><pre class="knitr r">## [1]  TRUE FALSE
</pre></div>

<div class="source"><pre class="knitr r">is_na(c(NA, 1))
</pre></div>

<div class="output"><pre class="knitr r">## [1]  TRUE FALSE
</pre></div>

<div class="source"><pre class="knitr r">is_na(c(NA, "a"))
</pre></div>

<div class="output"><pre class="knitr r">## [1]  TRUE FALSE
</pre></div>

<div class="source"><pre class="knitr r">is_na(c(NA, TRUE))
</pre></div>

<div class="output"><pre class="knitr r">## [1]  TRUE FALSE
</pre></div>

<p></div></div></p>

<p>It&#39;s worth noting that R&#39;s <code>base::is.na</code> returns <code>TRUE</code> for both <code>NA</code> and <code>NaN</code>s in a numeric vector, as opposed to the C level <code>ISNA</code> macro, which returns <code>TRUE</code> only for <code>NA_REAL</code>s.</p>

<p>There are a few other special values:</p>

<div class="chunk" id="unnamed-chunk-562"><div class="rcode"><div class="source"><pre class="knitr r">nil <- cfunction(NULL, 'return(R_NilValue);')
unbound <- cfunction(NULL, 'return(R_UnboundValue);')
missing_arg <- cfunction(NULL, 'return(R_MissingArg);')

x <- missing_arg()
x
</pre></div>

<div class="error"><pre class="knitr r">## Error: argument "x" is missing, with no default
</pre></div>

<p></div></div></p>

<h2>Checking types in C</h2>

<p>If the user provides different input to your function to what you&#39;re expecting (e.g. provides a list instead of a numeric vector), it&#39;s very easy to crash R. For this reason, it&#39;s a good idea to write a wrapper function that checks arguments are of the correct type, or coerces them if necessary. It&#39;s usually easier to do this at the R level. For example, going back to our first example of C code, we might rename it to <code>add_</code> and then write a wrapper function to check the inputs are ok:</p>

<div class="chunk" id="unnamed-chunk-563"><div class="rcode"><div class="source"><pre class="knitr r">add_ <- cfunction(signature(a = "integer", b = "integer"), "
  SEXP result;

  PROTECT(result = allocVector(REALSXP, 1));
  REAL(result)[0] = asReal(a) + asReal(b);
  UNPROTECT(1);

  return(result);
")
add <- function(a, b) {
  stopifnot(is.numeric(a), is.numeric(b), length(a) == 1, length(b) == 1)
  add_(a, b)
}
</pre></div>

<p></div></div></p>

<p>Or if we wanted to be more accepting of diverse inputs:</p>

<div class="chunk" id="unnamed-chunk-564"><div class="rcode"><div class="source"><pre class="knitr r">add <- function(a, b) {
  a <- as.numeric(a)
  b <- as.numeric(b)

  if (length(a) > 1) warning("Only first element of a used")
  if (length(a) > 1) warning("Only first element of b used")
  
  add_(a, b)
}
</pre></div>

<p></div></div></p>

<p>To coerce objects at the C level, use <code>PROTECT(new = coerceVector(old, SEXPTYPE))</code>. This will return an error if the <code>SEXP</code> can not be converted to the desired type.  Note that these coercion functions do not use S3 dispatch.</p>

<p>To check if an object is of a specified type, you can use <code>TYPEOF</code>, which returns a <code>SEXPTYPE</code>:</p>

<div class="chunk" id="unnamed-chunk-565"><div class="rcode"><div class="source"><pre class="knitr r">is_numeric <- cfunction(c("x" = "ANY"), "
  return(ScalarLogical(TYPEOF(x) == REALSXP));
")
is_numeric(7)
</pre></div>

<div class="output"><pre class="knitr r">## [1] TRUE
</pre></div>

<div class="source"><pre class="knitr r">is_numeric("a")
</pre></div>

<div class="output"><pre class="knitr r">## [1] FALSE
</pre></div>

<p></div></div></p>

<p>Or you can use one of the many helper functions. They all return 0 for FALSE and 1 for TRUE:</p>

<ul>
<li><p>For atomic vectors: <code>isInteger</code>, <code>isReal</code>, <code>isComplex</code>, <code>isLogical</code>, <code>isString</code>.</p></li>
<li><p>For combinations of atomic vectors: <code>isNumeric</code> (integer, logical, real), <code>isNumber</code> (integer, logical, real, complex), <code>isVectorAtomic</code> (logical, interger, numeric, complex, string, raw)</p></li>
<li><p>Matrices (<code>isMatrix</code>) and arrays (<code>isArray</code>)</p></li>
<li><p>For other more esoteric object: <code>isEnvironment</code>, <code>isExpression</code>, <code>isList</code> (a pair list), <code>isNewList</code> (a list), <code>isSymbol</code>, <code>isNull</code>, <code>isObject</code> (S4 objects), <code>isVector</code> (atomic vectors, lists, expressions)</p></li>
</ul>

<p>Note that some of these functions behave differently to the R-level functions with similar names. For example <code>isVector</code> is true for any atomic vector type, lists and expression, where <code>is.vector</code> is returns <code>TRUE</code> only if its input has no attributes apart from names.</p>

<h2>Finding the C source code for a function</h2>

<p>In many R functions you&#39;ll find code like <code>.Internal(mean(x))</code> or <code>.Primitive(&quot;sum&quot;)</code>. That means that most of the function is implemented at the C-level.  There are two steps to finding the corresponding C source code:</p>

<ul>
<li><p>First, open <a href="https://github.com/wch/r-source/blob/trunk/src/main/names.c">src/main/names.c</a> and search for the name of the function.  You&#39;ll find an entry that tells you the name of the function (which always starts with <code>do_</code>)</p></li>
<li><p>Next, search the R source code for the name of that function.  To make it easier to find where it&#39;s defined (rather than everywhere it&#39;s used), you can add <code>(SEXP</code>.  e.g. to find the source code for <code>findInterval</code>, search for <code>do_findinterval(SEXP</code>.</p></li>
</ul>

<h2><code>.External</code></h2>

<p>An alternative to using <code>.Call</code> is to use <code>.External</code>.  It is used almost identically, except that the C function will recieve a single arugment containing a <code>LISTSXP</code>, a pairlist from which the arguments can be extracted. This makes it possible to write functions that take a variable number of arguments.</p>

<p><code>inline</code> does not currently support <code>.External</code> functions.</p>

<h2>Using C code in a package</h2>

<p>If you&#39;re putting your code in a package, it&#39;s generally a good idea to stop using <code>inline</code> and revert back to separate R and C functions.  At a minimum, you&#39;ll need:</p>

<ul>
<li>R files in a <code>R/</code> directory</li>
<li>C files in <code>src/</code> directory</li>
<li>A <code>DESCRIPTION</code> in the main directory</li>
<li>A <code>NAMESPACE</code> file containing <code>useDynLib(packagename)</code>, which can be generated using a <code>roxygen2</code> tag: <code>@useDynLib packagename</code></li>
</ul>

<p>Running <code>load_all(path/to/package)</code> will automatically compile and reload the code in your package.</p>

<p>Your C code will need these headers:</p>

<pre><code class="C">#include &lt;R.h&gt;
#include &lt;Rinternals.h&gt;
</code></pre>

</body>

</html>
